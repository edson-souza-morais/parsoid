require('../../core-upgrade.js');
module.exports = (function() {
  "use strict";
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.org/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;

    this.name     = "SyntaxError";
  }

  peg$subclass(peg$SyntaxError, Error);

  var exports = {
    SyntaxError:   peg$SyntaxError,
  };


  function peg$parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},
        parser = this,
        peg$currPos = 0,
        peg$savedPos = 0,
        peg$FAILED = {};

    var peg$cache = {};
    var visitCounts = new Uint8Array(input.length);

    // common-helpers.js
    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function error(message) {
      throw peg$buildException(
        message,
        null,
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    var peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [];

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos],
          p, ch;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column,
          seenCR: details.seenCR
        };

        while (p < pos) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, found, location) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        /*
         * This works because the bytecode generator guarantees that every
         * expectation object exists only once, so it's enough to use |===| instead
         * of deeper structural comparison.
         */
        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          /*
           * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
           * literal except for the closing quote character, backslash, carriage
           * return, line separator, paragraph separator, and line feed. Any character
           * may appear in the form of an escape sequence.
           *
           * For portability, we also escape all control and non-ASCII characters.
           * Note that "\0" and "\v" escape sequences are not used because JSHint does
           * not like the first and IE the second.
           */
          return s
            .replace(/\\/g,   '\\\\')       // backslash
            .replace(/"/g,    '\\"')        // closing double quote
            .replace(/\x08/g, '\\b')        // backspace
            .replace(/\t/g,   '\\t')        // horizontal tab
            .replace(/\n/g,   '\\n')        // line feed
            .replace(/\f/g,   '\\f')        // form feed
            .replace(/\r/g,   '\\r')        // carriage return
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new peg$SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        location
      );
    }


  // consts
  function peg$c0() {

        if (endOffset() === input.length) {
            emitChunk([ new EOFTk() ]);
        }
        // terminate the loop
        return false;
      
  }
  function peg$c1() {

        // end is passed inline as a token, as well as a separate event for now.
        emitChunk([ new EOFTk() ]);
        return true;
    
  }
  var peg$c2 = {"type":"other","description":"start"};
  function peg$c3(sc, startPos) {
   return endOffset(); 
  }
  function peg$c4(sc, startPos, b, p) {
   return stops.push('table', false); 
  }
  function peg$c5(sc, startPos, b, p, ta) {
   console.assert(false); return false; 
  }
  function peg$c6(sc, startPos, b, p, ta, tsEndPos) {
   stops.pop('table'); return endOffset(); 
  }
  function peg$c7(sc, startPos, b, p, ta, tsEndPos, s2) {

          var coms = tu.popComments(ta);
          if (coms) {
            tsEndPos = coms.commentStartPos;
          }

          var da = { tsr: [startPos, tsEndPos] };
          if (p !== "|") {
              // Variation from default
              da.startTagSrc = b + p;
          }

          sc.push(new TagTk('table', ta, da));
          if (coms) {
            sc = sc.concat(coms.buf);
          }
          return sc.concat(s2);
      
  }
  var peg$c8 = {"type":"other","description":"table_start_tag"};
  function peg$c9(proto, addr, path, c) {
   return c; 
  }
  function peg$c10(proto, addr, path, s) {
   return s; 
  }
  function peg$c11(proto, addr, path, r, he) {
   return he; 
  }
  function peg$c12(proto, addr, path, r) {
   return r; 
  }
  function peg$c13(proto, addr, path) {
   return addr.length > 0 || path.length > 0; 
  }
  function peg$c14(proto, addr, path) {

      return tu.flattenString([proto, addr].concat(path));

  }
  var peg$c15 = {"type":"other","description":"url"};
  function peg$c16() {
   return stops.push('tableCellArg', true); 
  }
  function peg$c17(as, s, p) {

          stops.pop('tableCellArg');
          return [as, s, p];
      
  }
  function peg$c18() {
   return stops.pop('tableCellArg'); 
  }
  function peg$c19(b) {
   return b; 
  }
  var peg$c20 = {"type":"other","description":"table_attributes"};
  var peg$c21 = {"type":"other","description":"generic_newline_attributes"};
  function peg$c22(r) {
   return tu.flattenIfArray(r); 
  }
  var peg$c23 = {"type":"other","description":"tplarg_or_template_or_bust"};
  function peg$c24(c) {
   return tu.flattenIfArray(c); 
  }
  var peg$c25 = {"type":"other","description":"nowiki_content"};
  function peg$c26() {
   return stops.onStack('extlink'); 
  }
  function peg$c27(r) {
   return stops.push('extlink', true); 
  }
  function peg$c28(r, addr, target) {

            // Protocol must be valid and there ought to be at least one
            // post-protocol character.  So strip last char off target
            // before testing protocol.
            var flat = tu.flattenString([addr, target]);
            if (Array.isArray(flat)) {
               // There are templates present, alas.
               return flat.length > 0;
            }
            return Util.isProtocolValid(flat.slice(0, -1), env);
          
  }
  function peg$c29(r, addr, target, sp, targetOff) {
   return endOffset(); 
  }
  function peg$c30(r, addr, target, sp, targetOff, content) {

              stops.pop('extlink');
              return [
                  new SelfclosingTagTk('extlink', [
                      new KV('href', tu.flattenString([addr, target])),
                      new KV('mw:content', content || ''),
                      new KV('spaces', sp),
                  ], {
                      targetOff: targetOff,
                      tsr: tsrOffsets(),
                      contentOffsets: [targetOff, endOffset() - 1],
                  }),
              ];
          
  }
  function peg$c31(r) {
   return stops.pop('extlink'); 
  }
  function peg$c32(r) {
   return r; 
  }
  var peg$c33 = {"type":"other","description":"extlink"};
  function peg$c34(b) {

      // Clear the tokenizer's backtracking cache after matching each
      // toplevelblock. There won't be any backtracking as a document is just a
      // sequence of toplevelblocks, so the cache for previous toplevelblocks
      // will never be needed.
      var end = startOffset();
      for (; prevOffset < end; prevOffset++) {
          peg$cache[prevOffset] = undefined;
      }

      var tokens;
      if (Array.isArray(b) && b.length) {
          tokens = tu.flattenIfArray(b);
      } else if (b && b.constructor === String) {
          tokens = [b];
      }

      // Emit tokens for this toplevelblock. This feeds a chunk to the parser pipeline.
      if (tokens) {
          emitChunk(tokens);
      }

      // We don't return any tokens to the start rule to save memory. We
      // just emitted them already to our consumers.
      return true;
    
  }
  var peg$c35 = {"type":"other","description":"tlb"};
  function peg$c36() {
   return [new NlTk(tsrOffsets())]; 
  }
  var peg$c37 = {"type":"class","value":"[ \\t]","description":"[ \\t]"};
  var peg$c38 = {"type":"literal","value":"<!--","description":"\"<!--\""};
  var peg$c39 = {"type":"any","description":"any character"};
  var peg$c40 = {"type":"literal","value":"-->","description":"\"-->\""};
  function peg$c41(c) {

          var data = DU.encodeComment(c);
          return [new CommentTk(data, { tsr: tsrOffsets() })];
      
  }
  var peg$c42 = {"type":"literal","value":"|","description":"\"|\""};
  var peg$c43 = {"type":"literal","value":"{{!}}","description":"\"{{!}}\""};
  function peg$c44() {
   return Util.isProtocolValid(input.substr(endOffset()), env); 
  }
  var peg$c45 = {"type":"literal","value":"//","description":"\"//\""};
  var peg$c46 = {"type":"class","value":"[A-Za-z]","description":"[A-Za-z]"};
  var peg$c47 = {"type":"class","value":"[-A-Za-z0-9+.]","description":"[-A-Za-z0-9+.]"};
  var peg$c48 = {"type":"literal","value":":","description":"\":\""};
  function peg$c49(p) {
   return p; 
  }
  var peg$c50 = {"type":"literal","value":"[","description":"\"[\""};
  var peg$c51 = {"type":"class","value":"[0-9A-Fa-f:.]","description":"[0-9A-Fa-f:.]"};
  var peg$c52 = {"type":"literal","value":"]","description":"\"]\""};
  function peg$c53() {
   return inlineBreaks(input, endOffset(), stops); 
  }
  var peg$c54 = {"type":"class","value":"[^ :\\]\\[\\r\\n\"'<>\\x00-\\x20\\x7f,.&%\\u00A0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000{]","description":"[^ :\\]\\[\\r\\n\"'<>\\x00-\\x20\\x7f,.&%\\u00A0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000{]"};
  function peg$c55() {

        // Refuse to recurse beyond `maxDepth` levels. Default in the PHP parser
        // is $wgMaxTemplateDepth = 40; This is to prevent crashing from
        // buggy wikitext with lots of unclosed template calls, as in
        // eswiki/Usuario:C%C3%A1rdenas/PRUEBAS?oldid=651094
        if (stops.onCount('templatedepth') === undefined ||
            stops.onCount('templatedepth') < env.conf.parsoid.maxDepth) {
          return true;
        } else {
          return false;
        }
      
  }
  function peg$c56(t) {
   return t; 
  }
  function peg$c57(cc) {

      // if this is an invalid entity, don't tag it with 'mw:Entity'
      if (cc.length > 2 /* decoded entity would be 1 or 2 UTF-16 characters */) {
          return cc;
      }
      return [
          new TagTk('span', [new KV('typeof', 'mw:Entity')], { src: text(), srcContent: cc, tsr: tsrOffsets('start') }),
          cc,
          new EndTagTk('span', [], { tsr: tsrOffsets('end') }),
      ];

  }
  function peg$c58(s, namePos0) {
   return endOffset(); 
  }
  function peg$c59(s, namePos0, name, namePos) {
   return endOffset(); 
  }
  var peg$c60 = {"type":"literal","value":"=","description":"\"=\""};
  function peg$c61(s, namePos0, name, namePos, vd, v) {
   return v; 
  }
  function peg$c62(s, namePos0, name, namePos, vd) {

      // NB: Keep in sync w/ generic_newline_attribute
      var res;
      // Encapsulate protected attributes.
      if (typeof name === 'string') {
          name = tu.protectAttrs(name);
      }
      if (vd !== null) {
          res = new KV(name, vd.value, [namePos0, namePos, vd.srcOffsets[0], vd.srcOffsets[1]]);
          res.vsrc = input.substring(vd.srcOffsets[0], vd.srcOffsets[1]);
      } else {
          res = new KV(name, '', [namePos0, namePos, namePos, namePos]);
      }
      if (Array.isArray(name)) {
          res.ksrc = input.substring(namePos0, namePos);
      }
      return res;

  }
  function peg$c63(s) {

        if (s.length) {
            return [s];
        } else {
            return [];
        }
    
  }
  var peg$c64 = {"type":"class","value":"[\\0/=>]","description":"[\\0/=>]"};
  function peg$c65(c) {
   return new KV(c, ''); 
  }
  function peg$c66(namePos0) {
   return endOffset(); 
  }
  function peg$c67(namePos0, name, namePos) {
   return endOffset(); 
  }
  function peg$c68(namePos0, name, namePos, vd, v) {
   return v; 
  }
  function peg$c69(namePos0, name, namePos, vd) {

      // NB: Keep in sync w/ table_attibute
      var res;
      // Encapsulate protected attributes.
      if (typeof name === 'string') {
          name = tu.protectAttrs(name);
      }
      if (vd !== null) {
          res = new KV(name, vd.value, [namePos0, namePos, vd.srcOffsets[0], vd.srcOffsets[1]]);
          res.vsrc = input.substring(vd.srcOffsets[0], vd.srcOffsets[1]);
      } else {
          res = new KV(name, '', [namePos0, namePos, namePos, namePos]);
      }
      if (Array.isArray(name)) {
          res.ksrc = input.substring(namePos0, namePos);
      }
      return res;

  }
  function peg$c70() {

      // Prevent breaking on pipes when we're in a link description.
      // See the test, 'Images with the "|" character in the comment'.
      return stops.push('linkdesc', false);
    
  }
  var peg$c71 = {"type":"class","value":"[^'<~[{\\n\\r|!\\]}\\-\\t&=\"' \\u00A0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]","description":"[^'<~[{\\n\\r|!\\]}\\-\\t&=\"' \\u00A0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]"};
  var peg$c72 = {"type":"class","value":"[&|{\\-]","description":"[&|{\\-]"};
  function peg$c73(r, s) {
   return s; 
  }
  var peg$c74 = {"type":"class","value":"[.:,]","description":"[.:,]"};
  var peg$c75 = {"type":"class","value":"[']","description":"[']"};
  function peg$c76(r) {

        stops.pop('linkdesc');
        return tu.flattenString(r);
    
  }
  function peg$c77() {
   return stops.pop('linkdesc'); 
  }
  var peg$c78 = {"type":"class","value":"[ \\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]","description":"[ \\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]"};
  var peg$c79 = {"type":"class","value":"[^\\r\\n]","description":"[^\\r\\n]"};
  function peg$c80(c, r) {
   return r; 
  }
  function peg$c81(c) {

        return tu.flattenStringlist(c);
    
  }
  function peg$c82() {
   return endOffset() === input.length; 
  }
  function peg$c83(r, cil, bl) {
   return [r].concat(cil, bl || []); 
  }
  function peg$c84(rs, c) {
   return c; 
  }
  function peg$c85(rs) {
   return rs; 
  }
  function peg$c86(s) {
   return s; 
  }
  var peg$c87 = {"type":"literal","value":"\n","description":"\"\\n\""};
  var peg$c88 = {"type":"literal","value":"\r\n","description":"\"\\r\\n\""};
  function peg$c89() {
   return stops.inc('templatedepth'); 
  }
  function peg$c90(r, a) {
   return a; 
  }
  var peg$c91 = {"type":"literal","value":"{","description":"\"{\""};
  function peg$c92(r, a, b) {
   return [a].concat(b); 
  }
  function peg$c93(r) {

        stops.dec('templatedepth');
        return r;
      
  }
  function peg$c94() {
   return stops.dec('templatedepth'); 
  }
  var peg$c95 = {"type":"literal","value":"&","description":"\"&\""};
  var peg$c96 = {"type":"class","value":"[#0-9a-zA-Z]","description":"[#0-9a-zA-Z]"};
  var peg$c97 = {"type":"literal","value":";","description":"\";\""};
  function peg$c98(m) {

      return Util.decodeWtEntities(m);

  }
  var peg$c99 = {"type":"class","value":"[\"'=]","description":"[\"'=]"};
  var peg$c100 = {"type":"class","value":"[^ \\t\\r\\n\\0/=><&{}\\-!|\\[]","description":"[^ \\t\\r\\n\\0/=><&{}\\-!|\\[]"};
  function peg$c101(q, r, t, ill) {
   return ill; 
  }
  function peg$c102(q, r, t, c) {
   return c; 
  }
  function peg$c103(q, r, t) {
   return t; 
  }
  function peg$c104(q, r) {
   return r.length > 0 || q.length > 0; 
  }
  function peg$c105(q, r) {
   return tu.flattenString([q].concat(r)); 
  }
  var peg$c106 = {"type":"literal","value":"'","description":"\"'\""};
  function peg$c107(s, t, q) {

        return tu.getAttrVal(t, startOffset() + s.length, endOffset() - q.length);
      
  }
  var peg$c108 = {"type":"literal","value":"\"","description":"\"\\\"\""};
  function peg$c109(s, t) {

        return tu.getAttrVal(t, startOffset() + s.length, endOffset());
      
  }
  var peg$c110 = {"type":"literal","value":"/","description":"\"/\""};
  var peg$c111 = {"type":"class","value":"[^ \\t\\r\\n\\0/=><&{}\\-!|]","description":"[^ \\t\\r\\n\\0/=><&{}\\-!|]"};
  var peg$c112 = {"type":"class","value":"[ \\t\\n\\r\\x0c]","description":"[ \\t\\n\\r\\x0c]"};
  function peg$c113(v) {
   return v; 
  }
  function peg$c114(e) {
   return e; 
  }
  var peg$c115 = {"type":"class","value":"[^-'<~[{\\n/A-Za-z_|!:;\\]} &=]","description":"[^-'<~[{\\n/A-Za-z_|!:;\\]} &=]"};
  function peg$c116(al) {
   return al; 
  }
  function peg$c117(he) {
   return he; 
  }
  var peg$c118 = {"type":"literal","value":" ","description":"\" \""};
  function peg$c119() {

                var toks = TokenUtils.placeholder('\u00a0', {
                  src: ' ',
                  tsr: tsrOffsets('start'),
                  isDisplayHack: true,
                }, { tsr: tsrOffsets('end'), isDisplayHack: true });
                var typeOf = toks[0].getAttribute('typeof');
                toks[0].setAttribute('typeof', 'mw:DisplaySpace ' + typeOf);
                return toks;
            
  }
  function peg$c120(bs) {
   return bs; 
  }
  var peg$c121 = {"type":"literal","value":"[[","description":"\"[[\""};
  function peg$c122() {
   return endOffset() === 0 && !options.pipelineOffset; 
  }
  function peg$c123(rw, sp, c, wl) {

        return wl.length === 1 && wl[0] && wl[0].constructor !== String;
    
  }
  function peg$c124(rw, sp, c, wl) {

      var link = wl[0];
      if (sp) { rw += sp; }
      if (c) { rw += c; }
      // Build a redirect token
      var redirect = new SelfclosingTagTk('mw:redirect',
              // Put 'href' into attributes so it gets template-expanded
              [KV.lookupKV(link.attribs, 'href')],
              {
                  src: rw,
                  tsr: tsrOffsets(),
                  linkTk: link,
              });
      return redirect;

  }
  function peg$c125() {
   return stops.push("sol_il", true); 
  }
  function peg$c126(i) {
   stops.pop("sol_il"); return true; 
  }
  function peg$c127(i) {
   return i; 
  }
  function peg$c128() {
   return stops.pop("sol_il"); 
  }
  function peg$c129(st, r, tl) {
   return tl; 
  }
  function peg$c130(st, r, bts, bt, stl) {
   return bt.concat(stl); 
  }
  function peg$c131(st, r, bts) {
   return bts; 
  }
  function peg$c132(st, r) {

            return st.concat(r);
        
  }
  function peg$c133(s, s2, os, so) {
   return os.concat(so); 
  }
  function peg$c134(s, s2, bl) {

          return s.concat(s2 || [], bl);
      
  }
  function peg$c135() {

        // By the time we get to `doTableStuff` in the php parser, we've already
        // safely encoded element attributes. See 55313f4e in core.
        stops.push('table', false);
        stops.push('tableCellArg', false);
        return true;
      
  }
  var peg$c136 = {"type":"literal","value":"<","description":"\"<\""};
  function peg$c137(end, name, tn) {

        return isXMLTag(tn, true);  // NOTE: 'extTag' stop was pushed.
      
  }
  var peg$c138 = {"type":"literal","value":">","description":"\">\""};
  function peg$c139(end, name, attribs, selfclose) {

        stops.pop('table');
        stops.pop('tableCellArg');
        stops.pop('extTag');
        var t = tu.buildXMLTag(name, name.toLowerCase(), attribs, end, !!selfclose, tsrOffsets());
        var met = maybeExtensionTag(t);
        return Array.isArray(met) ? met : [met];
      
  }
  function peg$c140() {
   return stops.pop('extTag'); 
  }
  function peg$c141() {
   stops.pop('table'); return stops.pop('tableCellArg'); 
  }
  function peg$c142(s1, s2, c) {

        return s1.concat(s2, c);
    
  }
  function peg$c143(stopLen) {
   return stops.push('preproc', /* {{ */'}}'); 
  }
  function peg$c144(stopLen, t) {
   return stops.popTo('preproc', stopLen); 
  }
  function peg$c145(stopLen, t) {
   stops.popTo('preproc', stopLen); return t; 
  }
  function peg$c146() {
   return stops.push('preproc', 'broken'); 
  }
  var peg$c147 = {"type":"literal","value":"{{","description":"\"{{\""};
  function peg$c148(stopLen) {
   return stops.push('preproc', ']]'); 
  }
  function peg$c149(stopLen, w) {
   return stops.popTo('preproc', stopLen); 
  }
  function peg$c150(stopLen, w) {
   stops.popTo('preproc', stopLen); return w; 
  }
  function peg$c151(end, name, tn) {

        return isXMLTag(tn, false);  // NOTE: 'extTag' stop was pushed.
      
  }
  function peg$c152(end, name, attribs, selfclose) {

          stops.pop('table');
          stops.pop('tableCellArg');
          stops.pop('extTag');

          var lcName = name.toLowerCase();

          // Extension tags don't necessarily have the same semantics as html tags,
          // so don't treat them as void elements.
          var isVoidElt = Util.isVoidElement(lcName) && !env.conf.wiki.extConfig.tags.has(lcName);

          // Support </br>
          if (lcName === 'br' && end) {
              end = null;
          }

          var res = tu.buildXMLTag(name, lcName, attribs, end, !!selfclose || isVoidElt, tsrOffsets());

          // change up data-attribs in one scenario
          // void-elts that aren't self-closed ==> useful for accurate RT-ing
          if (!selfclose && isVoidElt) {
              res.dataAttribs.selfClose = undefined;
              res.dataAttribs.noClose = true;
          }

          return maybeExtensionTag(res);
      
  }
  var peg$c153 = {"type":"class","value":"[^{}&<\\-!\\['\\r\\n|]","description":"[^{}&<\\-!\\['\\r\\n|]"};
  var peg$c154 = {"type":"class","value":"[{}&<\\-!\\[]","description":"[{}&<\\-!\\[]"};
  function peg$c155(r) {

      return tu.flattenString(r);
    
  }
  var peg$c156 = {"type":"class","value":"[^{}&<\\-!\\[\"\\r\\n|]","description":"[^{}&<\\-!\\[\"\\r\\n|]"};
  var peg$c157 = {"type":"class","value":"[^{}&<\\-!\\[ \\t\\n\\r\\x0c|]","description":"[^{}&<\\-!\\[ \\t\\n\\r\\x0c|]"};
  function peg$c158() {
   return stops.onStack('extTag'); 
  }
  var peg$c159 = {"type":"class","value":"[^{}&<\\-|/'>]","description":"[^{}&<\\-|/'>]"};
  var peg$c160 = {"type":"class","value":"[{}&\\-|/]","description":"[{}&\\-|/]"};
  var peg$c161 = {"type":"class","value":"[^{}&<\\-|/\">]","description":"[^{}&<\\-|/\">]"};
  var peg$c162 = {"type":"class","value":"[^{}&<\\-|/ \\t\\n\\r\\x0c>]","description":"[^{}&<\\-|/ \\t\\n\\r\\x0c>]"};
  function peg$c163() {
   return !stops.onStack('extTag'); 
  }
  function peg$c164(extToken) {
   return (Array.isArray(extToken) ? extToken[0] : extToken).name === 'extension'; 
  }
  function peg$c165(extToken) {
   return extToken; 
  }
  function peg$c166(a) {
   return a; 
  }
  var peg$c167 = {"type":"literal","value":"-","description":"\"-\""};
  function peg$c168(a, b) {
   return [a].concat(b); 
  }
  function peg$c169(n) {
   return tu.isIncludeTag(n.toLowerCase()); 
  }
  function peg$c170(il) {

      il = Array.isArray(il) ? il[0] : il;
      var lname = il.name.toLowerCase();
      if (!tu.isIncludeTag(lname)) { return false; }
      // Preserve SOL where necessary (for onlyinclude and noinclude)
      // Note that this only works because we encounter <*include*> tags in
      // the toplevel content and we rely on the php preprocessor to expand
      // templates, so we shouldn't ever be tokenizing inInclude.
      // Last line should be empty (except for comments)
      if (lname !== "includeonly" && stops.onStack("sol_il") && il.constructor === TagTk) {
          var dp = il.dataAttribs;
          var inclContent = dp.src.substring(dp.tagWidths[0], dp.src.length - dp.tagWidths[1]);
          var last = lastItem(inclContent.split('\n'));
          if (!/^(<!--([^-]|-(?!->))*-->)*$/.test(last)) {
              return false;
          }
      }
      return true;
    
  }
  function peg$c171(il) {
   return il; 
  }
  function peg$c172() {
   return /\w/.test(input[endOffset() - 1] || ''); 
  }
  function peg$c173(r, target) {

          var res = [new SelfclosingTagTk('urllink', [new KV('href', target)], { tsr: tsrOffsets() })];
            return res;
        
  }
  var peg$c174 = {"type":"literal","value":"__","description":"\"__\""};
  function peg$c175(bs) {

      if (env.conf.wiki.isMagicWord(bs)) {
        return [
          new SelfclosingTagTk('behavior-switch', [ new KV('word', bs) ],
            { tsr: tsrOffsets(), src: bs, magicSrc: bs }
          ),
        ];
      } else {
        return [ bs ];
      }
    
  }
  var peg$c176 = {"type":"class","value":"[^-'<~[{\\n\\r:;\\]}|!=]","description":"[^-'<~[{\\n\\r:;\\]}|!=]"};
  var peg$c177 = {"type":"literal","value":"''","description":"\"''\""};
  function peg$c178(quotes) {

      // sequences of four or more than five quotes are assumed to start
      // with some number of plain-text apostrophes.
      var plainticks = 0;
      var result = [];
      if (quotes.length === 4) {
          plainticks = 1;
      } else if (quotes.length > 5) {
          plainticks = quotes.length - 5;
      }
      if (plainticks > 0) {
          result.push(quotes.substring(0, plainticks));
      }
      // mw-quote token Will be consumed in token transforms
      var tsr = tsrOffsets();
      tsr[0] += plainticks;
      var mwq = new SelfclosingTagTk('mw-quote', [], { tsr: tsr });
      mwq.value = quotes.substring(plainticks);
      result.push(mwq);
      return result;

  }
  var peg$c179 = {"type":"class","value":"[ \\t\\n\\r\\0\\x0b]","description":"[ \\t\\n\\r\\0\\x0b]"};
  function peg$c180(rw) {
   return env.conf.wiki.getMagicWordMatcher('redirect').test(rw); 
  }
  function peg$c181(r) {
   return stops.inc('h'); 
  }
  function peg$c182(r, s, ce, ill) {
   return ill || []; 
  }
  function peg$c183(r, s, ce) {
   return ce || s.length > 2; 
  }
  function peg$c184(r, s, ce, endTPos) {
   return endOffset(); 
  }
  function peg$c185(r, s, ce, endTPos, spc) {

          var c;
          var e;
          var level;
          stops.dec('h');
          if (ce) {
              c = ce[0];
              e = ce[1];
              level = Math.min(s.length, e.length);
          } else {
              // split up equal signs into two equal parts, with at least
              // one character in the middle.
              level = Math.floor((s.length - 1) / 2);
              c = ['='.repeat(s.length - 2 * level)];
              s = e = '='.repeat(level);
          }
          level = Math.min(6, level);
          // convert surplus equals into text
          // FIXME: Manipulating a potentially cached result (c) can lead to
          // subtle breakage!
          if (s.length > level) {
              var extras1 = s.substr(0, s.length - level);
              if (c[0].constructor === String) {
                  c[0] = extras1 + c[0];
              } else {
                  c.unshift(extras1);
              }
          }
          if (e.length > level) {
              var extras2 = e.substr(0, e.length - level);
              var lastElem = lastItem(c);
              if (lastElem.constructor === String) {
                  c[c.length - 1] += extras2;
              } else {
                  c.push(extras2);
              }
          }

          var tsr = tsrOffsets('start');
          tsr[1] += level;
          return [
            new TagTk('h' + level, [], { tsr: tsr }),
          ].concat(c, [
            new EndTagTk('h' + level, [], { tsr: [endTPos - level, endTPos] }),
            spc,
          ]);
        
  }
  function peg$c186(r) {
   stops.dec('h'); return false; 
  }
  var peg$c187 = {"type":"literal","value":"----","description":"\"----\""};
  function peg$c188(d, lineContent) {
   return undefined; 
  }
  function peg$c189(d, lineContent) {
   return true; 
  }
  function peg$c190(d, lineContent) {

      var dataAttribs = {
        tsr: tsrOffsets(),
        lineContent: lineContent,
      };
      if (d.length > 0) {
        dataAttribs.extra_dashes = d.length;
      }
      return new SelfclosingTagTk('hr', [], dataAttribs);
    
  }
  function peg$c191(r) {
   return stops.push('table', true); 
  }
  function peg$c192(r, tl) {

              stops.pop('table');
              return tl;
          
  }
  function peg$c193(r) {
   return stops.pop('table'); 
  }
  function peg$c194(sp, p) {
   return endOffset(); 
  }
  function peg$c195(sp, p, c) {

          return [
              sp,
              new SelfclosingTagTk("meta", [new KV('typeof', 'mw:EmptyLine')], {
                  tokens: tu.flattenIfArray(c),
                  tsr: [p, endOffset()],
              }),
          ];
      
  }
  function peg$c196() {

        // Use the sol flag only at the start of the input
        // NOTE: Explicitly check for 'false' and not a falsy value
        return endOffset() === 0 && options.sol !== false;
    
  }
  function peg$c197() {
   return []; 
  }
  var peg$c198 = {"type":"literal","value":"{{{","description":"\"{{{\""};
  function peg$c199(p) {
   return endOffset(); 
  }
  function peg$c200(p, target, params, r, p0) {
   return endOffset(); 
  }
  function peg$c201(p, target, params, r, p0, v, p1) {
   return endOffset(); 
  }
  function peg$c202(p, target, params, r, p0, v, p1) {
   return { tokens: v, srcOffsets: [p0, p1] }; 
  }
  function peg$c203(p, target, params, r) {
   return r; 
  }
  var peg$c204 = {"type":"literal","value":"}}}","description":"\"}}}\""};
  function peg$c205(p, target, params) {

        params = params.map(function(o) {
          var s = o.srcOffsets;
          return new KV('', tu.flattenIfArray(o.tokens), [s[0], s[0], s[0], s[1]]);
        });
        if (target === null) { target = { tokens: '', srcOffsets: [p, p, p, p] }; }
        // Insert target as first positional attribute, so that it can be
        // generically expanded. The TemplateHandler then needs to shift it out
        // again.
        params.unshift(new KV(tu.flattenIfArray(target.tokens), '', target.srcOffsets));
        var obj = new SelfclosingTagTk('templatearg', params, { tsr: tsrOffsets(), src: text() });
        return obj;
      
  }
  function peg$c206(target, params, r, p0) {
   return endOffset(); 
  }
  function peg$c207(target, params, r, p0, v, p) {
   return endOffset(); 
  }
  function peg$c208(target, params, r, p0, v, p) {
   return new KV('', tu.flattenIfArray(v), [p0, p0, p0, p]); 
  }
  function peg$c209(target, params, r) {
   return r; 
  }
  var peg$c210 = {"type":"literal","value":"}}","description":"\"}}\""};
  function peg$c211(target, params) {

        // Insert target as first positional attribute, so that it can be
        // generically expanded. The TemplateHandler then needs to shift it out
        // again.
        params.unshift(new KV(tu.flattenIfArray(target.tokens), '', target.srcOffsets));
        var obj = new SelfclosingTagTk('template', params, { tsr: tsrOffsets(), src: text() });
        return obj;
      
  }
  function peg$c212(target, tpos) {
   return endOffset(); 
  }
  var peg$c213 = {"type":"literal","value":"]]","description":"\"]]\""};
  function peg$c214(target, tpos, lcs) {

        var pipeTrick = (lcs.length === 1 && lcs[0].v === null);
        var textTokens = [];
        if (target === null || pipeTrick) {
          textTokens.push("[[");
          if (target) {
            textTokens.push(target);
          }
          lcs.forEach(function(a) {
            // a is a mw:maybeContent attribute
            textTokens.push("|");
            if (a.v !== null) { textTokens.push(a.v); }
          });
          textTokens.push("]]");
          return textTokens;
        }
        var obj = new SelfclosingTagTk('wikilink');
        var hrefKV = new KV('href', target);
        hrefKV.vsrc = input.substring(startOffset() + 2, tpos);
        // XXX: Point to object with path, revision and input information
        // obj.source = input;
        obj.attribs.push(hrefKV);
        obj.attribs = obj.attribs.concat(lcs);
        obj.dataAttribs = {
            tsr: tsrOffsets(),
            src: text(),
        };
        return [obj];
    
  }
  function peg$c215(stopLen) {
   return stops.push('preproc', /* -{ */ '}-'); 
  }
  function peg$c216(stopLen, lv) {
   return stops.popTo('preproc', stopLen); 
  }
  function peg$c217(stopLen, lv) {
   stops.popTo('preproc', stopLen); return lv; 
  }
  function peg$c218() {
   return stops.push('autourl', { sawLParen: false }); 
  }
  function peg$c219(r, proto, addr, path, c) {
   return c; 
  }
  var peg$c220 = {"type":"literal","value":"(","description":"\"(\""};
  function peg$c221(r, proto, addr, path) {
   stops.onStack('autourl').sawLParen = true; return "("; 
  }
  function peg$c222(r, proto, addr, path, rhe) {
   return /^[<>\u00A0]$/.test(rhe); 
  }
  function peg$c223(r, proto, addr, path, he) {
   return he; 
  }
  var peg$c224 = {"type":"class","value":"[&%{]","description":"[&%{]"};
  function peg$c225(r, proto, addr, path) {
   return r; 
  }
  function peg$c226(r, proto, addr, path) {

      // as in Parser.php::makeFreeExternalLink, we're going to
      // yank trailing punctuation out of this match.
      var url = tu.flattenStringlist([proto, addr].concat(path));
      // only need to look at last element; HTML entities are strip-proof.
      var last = lastItem(url);
      var trim = 0;
      if (last && last.constructor === String) {
        var strip = ',;\\.:!?';
        if (!stops.onStack('autourl').sawLParen) {
          strip += ')';
        }
        strip = new RegExp('[' + JSUtils.escapeRegExp(strip) + ']*$');
        trim = strip.exec(last)[0].length;
        url[url.length - 1] = last.slice(0, last.length - trim);
      }
      url = tu.flattenStringlist(url);
      if (url.length === 1 && url[0].constructor === String && url[0].length <= proto.length) {
        return null; // ensure we haven't stripped everything: T106945
      }
      peg$currPos -= trim;
      stops.pop('autourl');
      return url;

  }
  function peg$c227(r) {
   return r !== null; 
  }
  function peg$c228(r) {
  return r; 
  }
  function peg$c229() {
   return stops.pop('autourl'); 
  }
  var peg$c230 = {"type":"literal","value":"RFC","description":"\"RFC\""};
  var peg$c231 = {"type":"literal","value":"PMID","description":"\"PMID\""};
  var peg$c232 = {"type":"class","value":"[0-9]","description":"[0-9]"};
  function peg$c233(ref, sp, identifier) {

      var base_urls = {
        'RFC': 'https://tools.ietf.org/html/rfc%s',
        'PMID': '//www.ncbi.nlm.nih.gov/pubmed/%s?dopt=Abstract',
      };
      return [
          new SelfclosingTagTk('extlink', [
             new KV('href', tu.sprintf(base_urls[ref], identifier)),
             new KV('mw:content', tu.flattenString([ref, sp, identifier])),
             new KV('typeof', 'mw:ExtLink/' + ref),
          ],
          { stx: "magiclink", tsr: tsrOffsets() }),
      ];

  }
  var peg$c234 = {"type":"literal","value":"ISBN","description":"\"ISBN\""};
  function peg$c235(sp, isbn, s) {
   return s; 
  }
  var peg$c236 = {"type":"class","value":"[xX]","description":"[xX]"};
  function peg$c237(sp, isbn, isbncode) {

          // Convert isbn token-and-entity array to stripped string.
          return tu.flattenStringlist(isbn).filter(function(e) {
            return e.constructor === String;
          }).join('').replace(/[^\dX]/ig, '').toUpperCase();
        
  }
  function peg$c238(sp, isbn, isbncode) {

         // ISBNs can only be 10 or 13 digits long (with a specific format)
         return isbncode.length === 10 ||
               (isbncode.length === 13 && /^97[89]/.test(isbncode));
      
  }
  function peg$c239(sp, isbn, isbncode) {

        return [
          new SelfclosingTagTk('extlink', [
             new KV('href', 'Special:BookSources/' + isbncode),
             new KV('mw:content', tu.flattenString(['ISBN', sp, isbn])),
             new KV('typeof', 'mw:WikiLink/ISBN'),
          ],
          { stx: "magiclink", tsr: tsrOffsets() }),
        ];

  }
  var peg$c240 = {"type":"class","value":"[^'\"<~[{\\n\\r:;\\]}|!=]","description":"[^'\"<~[{\\n\\r:;\\]}|!=]"};
  function peg$c241(bullets, lc) {
   return lc; 
  }
  function peg$c242(bullets) {
  return stops.inc('colon');
  }
  function peg$c243(bullets, c, cpos) {
   return endOffset(); 
  }
  function peg$c244(bullets, c, cpos) {
   stops.counters.colon = 0; return true;
  }
  function peg$c245(bullets, c, cpos, d) {

          // Leave bullets as an array -- list handler expects this
          // TSR: +1 for the leading ";"
          var numBullets = bullets.length + 1;
          var tsr = tsrOffsets('start');
          tsr[1] += numBullets;
          var li1 = new TagTk('listItem', [], { tsr: tsr });
          li1.bullets = bullets.slice();
          li1.bullets.push(";");
          // TSR: -1 for the intermediate ":"
          var li2 = new TagTk('listItem', [], { tsr: [cpos - 1, cpos], stx: 'row' });
          li2.bullets = bullets.slice();
          li2.bullets.push(":");

          return [ li1 ].concat(c || [], [ li2 ], d || []);
      
  }
  function peg$c246() {
   stops.counters.colon = 0; return false; 
  }
  function peg$c247(bullets, tbl, line) {

      // Leave bullets as an array -- list handler expects this
      var tsr = tsrOffsets('start');
      tsr[1] += bullets.length;
      var li = new TagTk('listItem', [], { tsr: tsr });
      li.bullets = bullets;
      return tu.flattenIfArray([li, tbl || [], line || []]);

  }
  function peg$c248(bullets, c) {

      // Leave bullets as an array -- list handler expects this
      var tsr = tsrOffsets('start');
      tsr[1] += bullets.length;
      var li = new TagTk('listItem', [], { tsr: tsr });
      li.bullets = bullets;
      return [ li ].concat(c || []);

  }
  var peg$c249 = {"type":"class","value":"[\\n\\r\\t ]","description":"[\\n\\r\\t ]"};
  function peg$c250(spc) {

          if (spc.length) {
              return [spc];
          } else {
              return [];
          }
      
  }
  var peg$c251 = {"type":"literal","value":"}","description":"\"}\""};
  function peg$c252(sc, startPos, p, b) {

        var tblEnd = new EndTagTk('table', [], { tsr: [startPos, endOffset()] });
        if (p !== "|") {
            // p+"<brace-char>" is triggering some bug in pegJS
            // I cannot even use that expression in the comment!
            tblEnd.dataAttribs.endTagSrc = p + b;
        }
        return sc.concat([tblEnd]);
    
  }
  var peg$c253 = {"type":"class","value":"[^\\t\\n\\v />\\0]","description":"[^\\t\\n\\v />\\0]"};
  function peg$c254() {
   return stops.push('equal', false); 
  }
  function peg$c255(tpt) {

          stops.pop('equal');
          return { tokens: tpt, srcOffsets: tsrOffsets() };
      
  }
  function peg$c256() {
   return stops.pop('equal'); 
  }
  function peg$c257(name, val, kEndPos) {
   return endOffset(); 
  }
  function peg$c258(name, val, kEndPos, vStartPos) {
   return endOffset(); 
  }
  function peg$c259(name, val, kEndPos, vStartPos, tpv) {

              return { kEndPos: kEndPos, vStartPos: vStartPos, value: (tpv && tpv.tokens) || [] };
          
  }
  function peg$c260(name, val) {

        if (val !== null) {
            if (val.value !== null) {
              return new KV(name, tu.flattenIfArray(val.value), [startOffset(), val.kEndPos, val.vStartPos, endOffset()]);
            } else {
              return new KV(tu.flattenIfArray(name), '', [startOffset(), val.kEndPos, val.vStartPos, endOffset()]);
            }
        } else {
          return new KV('', tu.flattenIfArray(name), [startOffset(), startOffset(), startOffset(), endOffset()]);
        }
      
  }
  function peg$c261() {

      return new KV('', '', [startOffset(), startOffset(), startOffset(), endOffset()]);
    
  }
  var peg$c262 = {"type":"class","value":"[^<[{\\n\\r\\t|!\\]}{ &\\-]","description":"[^<[{\\n\\r\\t|!\\]}{ &\\-]"};
  var peg$c263 = {"type":"class","value":"[!<\\-\\}\\]\\n\\r]","description":"[!<\\-\\}\\]\\n\\r]"};
  function peg$c264(r, t, wr) {
   return wr; 
  }
  function peg$c265(r) {

        return tu.flattenStringlist(r);
    
  }
  function peg$c266(startPos) {
   return endOffset(); 
  }
  function peg$c267(startPos, lt) {

          var maybeContent = new KV('mw:maybeContent', lt, [startPos, endOffset()]);
          maybeContent.vsrc = input.substring(startPos, endOffset());
          return maybeContent;
    
  }
  var peg$c268 = {"type":"literal","value":"-{","description":"\"-{\""};
  function peg$c269(lv0) {
   return startOffset(); 
  }
  function peg$c270(lv0, f) {
   return env.langConverterEnabled(); 
  }
  function peg$c271(lv0, f, ff) {

           // Avoid mutating cached expression results
           ff = Util.clone(ff, true);
           // if flags contains 'R', then don't treat ; or : specially inside.
           if (ff.flags) {
             ff.raw = ff.flags.has('R') || ff.flags.has('N');
           } else if (ff.variants) {
             ff.raw = true;
           }
           return ff;
         
  }
  function peg$c272(lv0, f) {
   return !env.langConverterEnabled(); 
  }
  function peg$c273(lv0, f) {

           // if language converter not enabled, don't try to parse inside.
           return { raw: true };
         
  }
  function peg$c274(lv0, f, ts) {
   return f.raw; 
  }
  function peg$c275(lv0, f, ts, lv) {
   return [{ text: lv }]; 
  }
  function peg$c276(lv0, f, ts) {
   return !f.raw; 
  }
  function peg$c277(lv0, f, ts, lv) {
   return lv; 
  }
  var peg$c278 = {"type":"literal","value":"}-","description":"\"}-\""};
  function peg$c279(lv0, f, ts, lv1) {
   return endOffset(); 
  }
  function peg$c280(lv0, f, ts, lv1) {


        if (!env.langConverterEnabled()) {
          return [ "-{", ts[0].text.tokens, "}-" ];
        }
        var lvsrc = input.substring(lv0, lv1);
        var attribs = [];

        // Do a deep clone since we may be destructively modifying
        // (the `t[fld] = name;` below) the result of a cached expression
        ts = Util.clone(ts, true);

        ts.forEach(function(t) {
          // move token strings into KV attributes so that they are
          // properly expanded by early stages of the token pipeline
          ['text','from','to'].forEach(function(fld) {
            if (t[fld] === undefined) { return; }
            var name = 'mw:lv' + attribs.length;
            // Note that AttributeExpander will expect the tokens array to be
            // flattened.  We do that in lang_variant_text / lang_variant_nowiki
            attribs.push(new KV(name, t[fld].tokens, t[fld].srcOffsets));
            t[fld] = name;
          });
        });
        return [
          new SelfclosingTagTk(
            'language-variant',
             attribs,
             {
               tsr: [lv0, lv1],
               src: lvsrc,
               flags: f.flags && Array.from(f.flags).sort(),
               variants: f.variants && Array.from(f.variants).sort(),
               original: f.original,
               flagSp: f.sp,
               texts: ts,
             }),
        ];
      
  }
  function peg$c281(he) {
   return Array.isArray(he) && /^\u00A0$/.test(he[1]); 
  }
  var peg$c282 = {"type":"class","value":"[*#:;]","description":"[*#:;]"};
  var peg$c283 = {"type":"literal","value":"!","description":"\"!\""};
  function peg$c284() {
   return stops.push('th', endOffset()); 
  }
  var peg$c285 = {"type":"literal","value":"!!","description":"\"!!\""};
  function peg$c286(th, ths, pp, tht) {

              // FIXME: Manipulating a potentially cached result (tht) can lead to
              // subtle breakage!
              var da = tht[0].dataAttribs;
              da.stx = 'row';
              da.tsr[0] -= pp.length; // include "!!" or "||"

              if (pp !== "!!" || (da.startTagSrc && da.startTagSrc !== pp)) {
                  // Variation from default
                  da.startTagSrc = pp + (da.startTagSrc ? da.startTagSrc.substring(1) : '');
              }
              return tht;
            
  }
  function peg$c287(th, ths) {

          stops.pop('th');
          // FIXME: Here too!
          th[0].dataAttribs.tsr[0]--; // include "!"
          return th.concat(ths);
      
  }
  function peg$c288() {
   return stops.onStack('th') !== false ? stops.pop('th') : false; 
  }
  function peg$c289() {
   return stops.onStack('tableDataBlock'); 
  }
  function peg$c290(p, dashes) {
   return stops.push('table', false); 
  }
  function peg$c291(p, dashes, a) {
   console.assert(false); return false; 
  }
  function peg$c292(p, dashes, a, tagEndPos) {
   stops.pop('table'); return endOffset(); 
  }
  function peg$c293(p, dashes, a, tagEndPos) {

          var coms = tu.popComments(a);
          if (coms) {
            tagEndPos = coms.commentStartPos;
          }

          var da = {
            tsr: [ startOffset(), tagEndPos ],
            startTagSrc: p + dashes,
          };

          // We rely on our tree builder to close the row as needed. This is
          // needed to support building tables from fragment templates with
          // individual cells or rows.
          var trToken = new TagTk('tr', a, da);

          var res = [ trToken ];
          if (coms) {
            res = res.concat(coms.buf);
          }
          return res;
      
  }
  function peg$c294(p, td, tagEndPos) {
   return endOffset(); 
  }
  function peg$c295(p, td, tagEndPos, tds) {

          // FIXME: Manipulating a potentially cached result (td) can lead to
          // subtle breakage!
          var da = td[0].dataAttribs;
          da.tsr[0] -= p.length; // include "|"
          if (p !== "|") {
              // Variation from default
              da.startTagSrc = p;
          }
          return td.concat(tds);
      
  }
  var peg$c296 = {"type":"literal","value":"+","description":"\"+\""};
  function peg$c297(p, args, tagEndPos) {
   return endOffset(); 
  }
  function peg$c298(p, args, tagEndPos, c) {

          return tu.buildTableTokens("caption", "|+", args, [startOffset(), tagEndPos], endOffset(), c, true);
      
  }
  function peg$c299() {
   // re-enable tables within template parameters
          stops.push('table', false);
          stops.push('extlink', false);
          stops.push('templateArg', true);
          stops.push('tableCellArg', false);
          return stops.inc('template');
      
  }
  function peg$c300(il) {

          stops.pop('table');
          stops.pop('extlink');
          stops.pop('templateArg');
          stops.pop('tableCellArg');
          stops.dec('template');
          // il is guaranteed to be an array -- so, tu.flattenIfArray will
          // always return an array
          var r = tu.flattenIfArray(il);
          if (r.length === 1 && r[0].constructor === String) {
              r = r[0];
          }
          return r;
      
  }
  function peg$c301() {
   stops.pop('table');
          stops.pop('extlink');
          stops.pop('templateArg');
          stops.pop('tableCellArg');
          return stops.dec('template');
      
  }
  function peg$c302() {
   return stops.push('equal', true); 
  }
  function peg$c303(tpt) {
   return ''; 
  }
  function peg$c304(tpt) {

          stops.pop('equal');
          return tpt;
      
  }
  function peg$c305() {

        // Suppress the flag temporarily in this rule to consume the '=' here.
        stops.push('equal', false);
        return stops.push('linkdesc', true);
      
  }
  function peg$c306(c) {

        stops.pop('equal');
        stops.pop('linkdesc');
        return tu.flattenStringlist(c);
      
  }
  function peg$c307() {
   stops.pop('equal'); return stops.pop('linkdesc'); 
  }
  function peg$c308(f, ff) {
   return ff; 
  }
  function peg$c309(f) {

      // Collect & separate flags and variants into a set and ordered list
      var flags = new Set();
      var variants = new Set();
      var flagList = [];
      var flagSpace = [];
      var variantList = [];
      var variantSpace = [];
      var useVariants = false;
      var internalSp = []; // internal whitespace, for round-tripping
      if (f !== null) {
        // lang_variant_flags returns arrays in reverse order.
        f.flags.reverse();
        f.sp.reverse();
        var spPtr = 0;
        f.flags.forEach(function(item) {
          if (item.flag) {
            flagSpace.push(f.sp[spPtr++]);
            flags.add(item.flag);
            flagList.push(item.flag);
            flagSpace.push(f.sp[spPtr++]);
          }
          if (item.variant) {
            variantSpace.push(f.sp[spPtr++]);
            variants.add(item.variant);
            variantList.push(item.variant);
            variantSpace.push(f.sp[spPtr++]);
          }
        });
        if (spPtr < f.sp.length) {
          // handle space after a trailing semicolon
          flagSpace.push(f.sp[spPtr]);
          variantSpace.push(f.sp[spPtr]);
        }
      }
      // Parse flags (this logic is from core/languages/ConverterRule.php
      // in the parseFlags() function)
      if (flags.size === 0 && variants.size === 0) {
        flags.add('$S');
      } else if (flags.has('R')) {
        flags = new Set(['R']); // remove other flags
      } else if (flags.has('N')) {
        flags = new Set(['N']); // remove other flags
      } else if (flags.has('-')) {
        flags = new Set(['-']); // remove other flags
      } else if (flags.has('T') && flags.size === 1) {
        flags.add('H');
      } else if (flags.has('H')) {
        // Replace A flag, and remove other flags except T and D
        var nf = new Set(['$+', 'H']);
        if (flags.has('T')) { nf.add('T'); }
        if (flags.has('D')) { nf.add('D'); }
        flags = nf;
      } else if (variants.size > 0) {
        useVariants = true;
      } else {
        if (flags.has('A')) {
          flags.add('$+');
          flags.add('$S');
        }
        if (flags.has('D')) {
          flags.delete('$S');
        }
      }
      if (useVariants) {
        return { variants: variants, original: variantList, sp: variantSpace };
      } else {
        return { flags: flags, original: flagList, sp: flagSpace };
      }
    
  }
  function peg$c310(start) {
  return startOffset();
  }
  function peg$c311(start, tokens, end) {
  return endOffset();
  }
  function peg$c312(start, tokens, end) {
   return { tokens: tu.flattenStringlist(tokens || []), srcOffsets: [start, end] }; 
  }
  function peg$c313(o, rest, oo) {
   return oo; 
  }
  function peg$c314(o, rest, tr) {

        var r = [ o ].concat(rest);
        if (tr) { r.push({ semi: true, sp: tr[1].join('') }); }
        return r;
      
  }
  function peg$c315(lvtext) {
   return [{ text: lvtext }]; 
  }
  function peg$c316(arg, tagEndPos) {
   return endOffset(); 
  }
  function peg$c317(arg, tagEndPos, c) {

        // This SyntaxStop is only true until we hit the end of the line.
        if (stops.onStack('th') !== false &&
                /\n/.test(input.substring(stops.onStack('th'), endOffset()))) {
            // There's been a newline. Remove the break and continue
            // tokenizing nested_block_in_tables.
            stops.pop('th');
        }
        return true;
      
  }
  function peg$c318(arg, tagEndPos, c, d) {
   return d; 
  }
  function peg$c319(arg, tagEndPos, c) {

          return tu.buildTableTokens("th", "!", arg, [startOffset(), tagEndPos], endOffset(), c);
      
  }
  var peg$c320 = {"type":"literal","value":"||","description":"\"||\""};
  var peg$c321 = {"type":"literal","value":"{{!}}{{!}}","description":"\"{{!}}{{!}}\""};
  function peg$c322(arg, tagEndPos, td) {

          return tu.buildTableTokens("td", "|", arg, [startOffset(), tagEndPos], endOffset(), td);
      
  }
  function peg$c323(pp, p) {
   return p; 
  }
  function peg$c324(pp, tdt) {

          // FIXME: Manipulating a potentially cached result (tdt) can lead to
          // subtle breakage!
          var da = tdt[0].dataAttribs;
          da.stx = "row";
          da.tsr[0] -= pp.length; // include "||"
          if (pp !== "||" || (da.startTagSrc && da.startTagSrc !== pp)) {
            // Variation from default
            da.startTagSrc = pp + (da.startTagSrc ? da.startTagSrc.substring(1) : '');
          }
          return tdt;
        
  }
  function peg$c325() {
   return stops.push('tableDataBlock', true); 
  }
  function peg$c326(b) {

          stops.pop('tableDataBlock');
          return b;
      
  }
  function peg$c327() {
   return stops.pop('tableDataBlock'); 
  }
  function peg$c328(r) {
   stops.push('linkdesc', false); return stops.push('table', true); 
  }
  function peg$c329(r, tbl) {

              stops.pop('linkdesc');
              stops.pop('table');
              return tbl;
          
  }
  function peg$c330(r) {
   stops.pop('linkdesc'); return stops.pop('table'); 
  }
  function peg$c331(sp1, f, sp2, more) {

      var r = more && more[1] ? more[1] : { sp: [], flags: [] };
      // Note that sp and flags are in reverse order, since we're using
      // right recursion and want to push instead of unshift.
      r.sp.push(sp2.join(''));
      r.sp.push(sp1.join(''));
      r.flags.push(f);
      return r;
    
  }
  function peg$c332(sp) {

      return { sp: [ sp.join('') ], flags: [] };
    
  }
  function peg$c333(sp1, lang, sp2, sp3, lvtext) {

        return {
          twoway: true,
          lang: lang,
          text: lvtext,
          sp: [sp1.join(''), sp2.join(''), sp3.join('')]
        };
      
  }
  var peg$c334 = {"type":"literal","value":"=>","description":"\"=>\""};
  function peg$c335(sp1, from, sp2, lang, sp3, sp4, to) {

        return {
          oneway: true,
          from: from,
          lang: lang,
          to: to,
          sp: [sp1.join(''), sp2.join(''), sp3.join(''), sp4.join('')]
        };
      
  }
  var peg$c336 = {"type":"class","value":"[-+A-Z]","description":"[-+A-Z]"};
  function peg$c337(f) {
   return { flag: f }; 
  }
  function peg$c338(v) {
   return { variant: v }; 
  }
  var peg$c339 = {"type":"class","value":"[^{}|;]","description":"[^{}|;]"};
  function peg$c340(b) {
   return { bogus: b.join('') }; /* bad flag */
  }
  var peg$c341 = {"type":"class","value":"[a-z]","description":"[a-z]"};
  var peg$c342 = {"type":"class","value":"[-a-z]","description":"[-a-z]"};
  function peg$c343(h, t) {
   return h + t.join(''); 
  }
  function peg$c344(start, n, end) {
   return endOffset();
  }
  function peg$c345(start, n, end) {

    return { tokens: [ n ], srcOffsets: [start, end] };

  }
  function peg$c346() {
   return stops.push('semicolon', true); 
  }
  function peg$c347(lvtext) {
   stops.pop('semicolon'); return lvtext; 
  }
  function peg$c348() {
   return stops.pop('semicolon'); 
  }
  function peg$c349() {
   return stops.push('arrow', true); 
  }
  function peg$c350(lvtext) {
   stops.pop('arrow'); return lvtext; 
  }
  function peg$c351() {
   return stops.pop('arrow'); 
  }
  function peg$c352(extToken) {
   return extToken.getAttribute('name') === 'nowiki'; 
  }
  function peg$c353(extToken) {

      var txt = Util.getExtArgInfo(extToken).dict.body.extsrc;
      return Util.decodeWtEntities(txt);
    
  }

  // generated
  function peg$streamstart_async(silence) {
    var r1,p2,r3,r4;
    return {
      next: function() {
        choice_1: {
        r1 = peg$parsetlb(silence);
        if (r1!== peg$FAILED) {
          break choice_1;
        }
        seq_1: {
        p2 = peg$currPos;
        r3 = [];
        r4 = peg$parsenewlineToken(silence);
        while (r4 !== peg$FAILED) {
          r3.push(r4);
          r4 = peg$parsenewlineToken(silence);
        }
        // free r4
        peg$savedPos = peg$currPos;
        r4 = peg$c0();
        if (r4) {
          r4 = void 0;
        } else {
          r4 = peg$FAILED;
          peg$currPos = p2;
          r1 = peg$FAILED;
          break seq_1;
        }
        r1 = [r3,r4];
        } // seq_1
        // free r3,r4,p2
        } // choice_1
        if (r1!== peg$FAILED) {
          return {done: false, value: r1};
        } else {
          if (peg$currPos < input.length) {
            peg$fail({ type: "end", description: "end of input ( " + input.length + ")" });
            throw peg$buildException(
              null,
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length
                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
          return {done: true};
        }
      }
    };
  }

  function peg$parsestart(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*0).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$discardtlb(true);
    while (r5 !== peg$FAILED) {
      r5 = peg$discardtlb(true);
    }
    // free r5
    r4 = true;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$discardnewlineToken(true);
    while (r5 !== peg$FAILED) {
      r5 = peg$discardnewlineToken(true);
    }
    // free r5
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c1();
    } else {
      if (!silence) {peg$fail(peg$c2);}
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_start_tag(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,r10,r11,p12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*88).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = [];
    choice_1: {
    r6 = peg$parsespace(true);
    if (r6!== peg$FAILED) {
      break choice_1;
    }
    r6 = peg$parsecomment(true);
    } // choice_1
    while (r6 !== peg$FAILED) {
      r5.push(r6);
      choice_2: {
      r6 = peg$parsespace(true);
      if (r6!== peg$FAILED) {
        break choice_2;
      }
      r6 = peg$parsecomment(true);
      } // choice_2
    }
    // sc <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r6 = '';
    // startPos <- r6
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c3(r5,r6);
    }
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // b <- r8
    if (input.charCodeAt(peg$currPos) === 123) {
      r8 = "{";
      peg$currPos += 1;
    } else {
      r8 = peg$FAILED;
    }
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$parsepipe(true);
    // p <- r9
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c4(r5,r6,r8,r9);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_3: {
    r10 = peg$parsetable_attributes(true);
    if (r10!== peg$FAILED) {
      break choice_3;
    }
    peg$savedPos = peg$currPos;
    r10 = peg$c5(r5,r6,r8,r9,r10);
    if (r10) {
      r10 = void 0;
    } else {
      r10 = peg$FAILED;
    }
    } // choice_3
    // ta <- r10
    r4 = r10;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p12 = peg$currPos;
    r11 = '';
    // tsEndPos <- r11
    if (r11!== peg$FAILED) {
      peg$savedPos = p12;
      r11 = peg$c6(r5,r6,r8,r9,r10,r11);
    }
    r4 = r11;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r13 = [];
    r14 = peg$parsespace(true);
    while (r14 !== peg$FAILED) {
      r13.push(r14);
      r14 = peg$parsespace(true);
    }
    // s2 <- r13
    // free r14
    r4 = r13;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c7(r5,r6,r8,r9,r10,r11,r13);
    } else {
      if (!silence) {peg$fail(peg$c8);}
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseurl(silence) {
    var r1,p2,p3,r4,r5,r6,r7,r8,p9,p10,r11,p12,r13,p14,r15,p16,p17,r18,p19,r20,r21,p22,r23,p24,p25,r26,p27,r28,r29;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*28).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parseurl_protocol(true);
    // proto <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r6 = peg$parseurladdr(true);
    if (r6!== peg$FAILED) {
      break choice_1;
    }
    r6 = '';
    } // choice_1
    // addr <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    choice_2: {
    p9 = peg$currPos;
    seq_2: {
    p10 = peg$currPos;
    p12 = peg$currPos;
    r11 = peg$discardinline_breaks(true);
    if (r11 === peg$FAILED) {
      r11 = void 0;
    } else {
      r11 = peg$FAILED;
      peg$currPos = p12;
      r8 = peg$FAILED;
      break seq_2;
    }
    // free p12
    r13 = peg$parseno_punctuation_char(true);
    // c <- r13
    r11 = r13;
    if (r11 === peg$FAILED) {
      peg$currPos = p10;
      r8 = peg$FAILED;
      break seq_2;
    }
    r8 = true;
    } // seq_2
    if (r8!== peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$c9(r5,r6,r7,r13);
      break choice_2;
    }
    // free r11,p10
    p10 = peg$currPos;
    r11 = input.charAt(peg$currPos);
    // s <- r11
    if (/^[.:,']/.test(r11)) {
      peg$currPos++;
    } else {
      r11 = peg$FAILED;
    }
    r8 = r11;
    if (r8!== peg$FAILED) {
      peg$savedPos = p10;
      r8 = peg$c10(r5,r6,r7,r11);
      break choice_2;
    }
    r8 = peg$parsecomment(true);
    if (r8!== peg$FAILED) {
      break choice_2;
    }
    r8 = peg$parsetplarg_or_template(true);
    if (r8!== peg$FAILED) {
      break choice_2;
    }
    p12 = peg$currPos;
    seq_3: {
    p14 = peg$currPos;
    p16 = peg$currPos;
    seq_4: {
    p17 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      r18 = "&";
      peg$currPos += 1;
    } else {
      r18 = peg$FAILED;
      r15 = peg$FAILED;
      break seq_4;
    }
    choice_3: {
    seq_5: {
    p19 = peg$currPos;
    r20 = input.charAt(peg$currPos);
    if (/^[lL]/.test(r20)) {
      peg$currPos++;
    } else {
      r20 = peg$FAILED;
      r18 = peg$FAILED;
      break seq_5;
    }
    r20 = input.charAt(peg$currPos);
    if (/^[tT]/.test(r20)) {
      peg$currPos++;
    } else {
      r20 = peg$FAILED;
      peg$currPos = p19;
      r18 = peg$FAILED;
      break seq_5;
    }
    r18 = true;
    } // seq_5
    if (r18!== peg$FAILED) {
      break choice_3;
    }
    // free r20,p19
    seq_6: {
    p19 = peg$currPos;
    r20 = input.charAt(peg$currPos);
    if (/^[gG]/.test(r20)) {
      peg$currPos++;
    } else {
      r20 = peg$FAILED;
      r18 = peg$FAILED;
      break seq_6;
    }
    r20 = input.charAt(peg$currPos);
    if (/^[tT]/.test(r20)) {
      peg$currPos++;
    } else {
      r20 = peg$FAILED;
      peg$currPos = p19;
      r18 = peg$FAILED;
      break seq_6;
    }
    r18 = true;
    } // seq_6
    // free r20,p19
    } // choice_3
    if (r18 === peg$FAILED) {
      peg$currPos = p17;
      r15 = peg$FAILED;
      break seq_4;
    }
    if (input.charCodeAt(peg$currPos) === 59) {
      r18 = ";";
      peg$currPos += 1;
    } else {
      r18 = peg$FAILED;
      peg$currPos = p17;
      r15 = peg$FAILED;
      break seq_4;
    }
    r15 = true;
    } // seq_4
    // free r18,p17
    if (r15 === peg$FAILED) {
      r15 = void 0;
    } else {
      r15 = peg$FAILED;
      peg$currPos = p16;
      r8 = peg$FAILED;
      break seq_3;
    }
    // free p16
    choice_4: {
    p16 = peg$currPos;
    seq_7: {
    p17 = peg$currPos;
    p19 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      r20 = "&";
      peg$currPos += 1;
      r20 = void 0;
      peg$currPos = p19;
    } else {
      r20 = peg$FAILED;
      r18 = peg$FAILED;
      break seq_7;
    }
    // free p19
    r21 = peg$parsehtmlentity(true);
    // he <- r21
    r20 = r21;
    if (r20 === peg$FAILED) {
      peg$currPos = p17;
      r18 = peg$FAILED;
      break seq_7;
    }
    r18 = true;
    } // seq_7
    if (r18!== peg$FAILED) {
      peg$savedPos = p16;
      r18 = peg$c11(r5,r6,r7,r18,r21);
      break choice_4;
    }
    // free r20,p17
    r18 = input.charAt(peg$currPos);
    if (/^[&%{]/.test(r18)) {
      peg$currPos++;
    } else {
      r18 = peg$FAILED;
    }
    } // choice_4
    // r <- r18
    r15 = r18;
    if (r15 === peg$FAILED) {
      peg$currPos = p14;
      r8 = peg$FAILED;
      break seq_3;
    }
    r8 = true;
    } // seq_3
    if (r8!== peg$FAILED) {
      peg$savedPos = p12;
      r8 = peg$c12(r5,r6,r7,r18);
    }
    // free r15,p14
    } // choice_2
    while (r8 !== peg$FAILED) {
      r7.push(r8);
      choice_5: {
      p14 = peg$currPos;
      seq_8: {
      p17 = peg$currPos;
      p19 = peg$currPos;
      r15 = peg$discardinline_breaks(true);
      if (r15 === peg$FAILED) {
        r15 = void 0;
      } else {
        r15 = peg$FAILED;
        peg$currPos = p19;
        r8 = peg$FAILED;
        break seq_8;
      }
      // free p19
      r20 = peg$parseno_punctuation_char(true);
      // c <- r20
      r15 = r20;
      if (r15 === peg$FAILED) {
        peg$currPos = p17;
        r8 = peg$FAILED;
        break seq_8;
      }
      r8 = true;
      } // seq_8
      if (r8!== peg$FAILED) {
        peg$savedPos = p14;
        r8 = peg$c9(r5,r6,r7,r20);
        break choice_5;
      }
      // free r15,p17
      p17 = peg$currPos;
      r15 = input.charAt(peg$currPos);
      // s <- r15
      if (/^[.:,']/.test(r15)) {
        peg$currPos++;
      } else {
        r15 = peg$FAILED;
      }
      r8 = r15;
      if (r8!== peg$FAILED) {
        peg$savedPos = p17;
        r8 = peg$c10(r5,r6,r7,r15);
        break choice_5;
      }
      r8 = peg$parsecomment(true);
      if (r8!== peg$FAILED) {
        break choice_5;
      }
      r8 = peg$parsetplarg_or_template(true);
      if (r8!== peg$FAILED) {
        break choice_5;
      }
      p19 = peg$currPos;
      seq_9: {
      p22 = peg$currPos;
      p24 = peg$currPos;
      seq_10: {
      p25 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        r26 = "&";
        peg$currPos += 1;
      } else {
        r26 = peg$FAILED;
        r23 = peg$FAILED;
        break seq_10;
      }
      choice_6: {
      seq_11: {
      p27 = peg$currPos;
      r28 = input.charAt(peg$currPos);
      if (/^[lL]/.test(r28)) {
        peg$currPos++;
      } else {
        r28 = peg$FAILED;
        r26 = peg$FAILED;
        break seq_11;
      }
      r28 = input.charAt(peg$currPos);
      if (/^[tT]/.test(r28)) {
        peg$currPos++;
      } else {
        r28 = peg$FAILED;
        peg$currPos = p27;
        r26 = peg$FAILED;
        break seq_11;
      }
      r26 = true;
      } // seq_11
      if (r26!== peg$FAILED) {
        break choice_6;
      }
      // free r28,p27
      seq_12: {
      p27 = peg$currPos;
      r28 = input.charAt(peg$currPos);
      if (/^[gG]/.test(r28)) {
        peg$currPos++;
      } else {
        r28 = peg$FAILED;
        r26 = peg$FAILED;
        break seq_12;
      }
      r28 = input.charAt(peg$currPos);
      if (/^[tT]/.test(r28)) {
        peg$currPos++;
      } else {
        r28 = peg$FAILED;
        peg$currPos = p27;
        r26 = peg$FAILED;
        break seq_12;
      }
      r26 = true;
      } // seq_12
      // free r28,p27
      } // choice_6
      if (r26 === peg$FAILED) {
        peg$currPos = p25;
        r23 = peg$FAILED;
        break seq_10;
      }
      if (input.charCodeAt(peg$currPos) === 59) {
        r26 = ";";
        peg$currPos += 1;
      } else {
        r26 = peg$FAILED;
        peg$currPos = p25;
        r23 = peg$FAILED;
        break seq_10;
      }
      r23 = true;
      } // seq_10
      // free r26,p25
      if (r23 === peg$FAILED) {
        r23 = void 0;
      } else {
        r23 = peg$FAILED;
        peg$currPos = p24;
        r8 = peg$FAILED;
        break seq_9;
      }
      // free p24
      choice_7: {
      p24 = peg$currPos;
      seq_13: {
      p25 = peg$currPos;
      p27 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        r28 = "&";
        peg$currPos += 1;
        r28 = void 0;
        peg$currPos = p27;
      } else {
        r28 = peg$FAILED;
        r26 = peg$FAILED;
        break seq_13;
      }
      // free p27
      r29 = peg$parsehtmlentity(true);
      // he <- r29
      r28 = r29;
      if (r28 === peg$FAILED) {
        peg$currPos = p25;
        r26 = peg$FAILED;
        break seq_13;
      }
      r26 = true;
      } // seq_13
      if (r26!== peg$FAILED) {
        peg$savedPos = p24;
        r26 = peg$c11(r5,r6,r7,r26,r29);
        break choice_7;
      }
      // free r28,p25
      r26 = input.charAt(peg$currPos);
      if (/^[&%{]/.test(r26)) {
        peg$currPos++;
      } else {
        r26 = peg$FAILED;
      }
      } // choice_7
      // r <- r26
      r23 = r26;
      if (r23 === peg$FAILED) {
        peg$currPos = p22;
        r8 = peg$FAILED;
        break seq_9;
      }
      r8 = true;
      } // seq_9
      if (r8!== peg$FAILED) {
        peg$savedPos = p19;
        r8 = peg$c12(r5,r6,r7,r26);
      }
      // free r23,p22
      } // choice_5
    }
    // path <- r7
    // free r8
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c13(r5,r6,r7);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c14(r5,r6,r7);
    } else {
      if (!silence) {peg$fail(peg$c15);}
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parserow_syntax_table_args(silence) {
    var r1,p2,p3,r4,r5,r6,r7,p8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*97).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c16();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsetable_attributes(silence);
    // as <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = [];
    r7 = peg$parsespace(silence);
    while (r7 !== peg$FAILED) {
      r6.push(r7);
      r7 = peg$parsespace(silence);
    }
    // s <- r6
    // free r7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsepipe(silence);
    // p <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p8 = peg$currPos;
    r4 = peg$discardpipe(true);
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p8;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p8
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c17(r5,r6,r7);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c18();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_attributes(silence) {
    var r1,r2,p3,p4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*3).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = [];
    choice_1: {
    r2 = peg$parsetable_attribute(true);
    if (r2!== peg$FAILED) {
      break choice_1;
    }
    p3 = peg$currPos;
    seq_1: {
    p4 = peg$currPos;
    r5 = peg$discardoptionalSpaceToken(true);
    if (r5 === peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parsebroken_table_attribute_name_char(true);
    // b <- r6
    r5 = r6;
    if (r5 === peg$FAILED) {
      peg$currPos = p4;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      peg$savedPos = p3;
      r2 = peg$c19(r6);
    }
    // free r5,p4
    } // choice_1
    while (r2 !== peg$FAILED) {
      r1.push(r2);
      choice_2: {
      r2 = peg$parsetable_attribute(true);
      if (r2!== peg$FAILED) {
        break choice_2;
      }
      p4 = peg$currPos;
      seq_2: {
      p7 = peg$currPos;
      r5 = peg$discardoptionalSpaceToken(true);
      if (r5 === peg$FAILED) {
        r2 = peg$FAILED;
        break seq_2;
      }
      r8 = peg$parsebroken_table_attribute_name_char(true);
      // b <- r8
      r5 = r8;
      if (r5 === peg$FAILED) {
        peg$currPos = p7;
        r2 = peg$FAILED;
        break seq_2;
      }
      r2 = true;
      } // seq_2
      if (r2!== peg$FAILED) {
        peg$savedPos = p4;
        r2 = peg$c19(r8);
      }
      // free r5,p7
      } // choice_2
    }
    // free r2
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsegeneric_newline_attributes(silence) {
    var r1,r2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*2).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = [];
    r2 = peg$parsegeneric_newline_attribute(true);
    while (r2 !== peg$FAILED) {
      r1.push(r2);
      r2 = peg$parsegeneric_newline_attribute(true);
    }
    // free r2
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetplarg_or_template_or_bust(silence) {
    var r1,p2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*33).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    choice_1: {
    r4 = peg$parsetplarg_or_template(true);
    if (r4!== peg$FAILED) {
      break choice_1;
    }
    if (peg$currPos < input.length) {
      r4 = input.charAt(peg$currPos++);
    } else {
      r4 = peg$FAILED;
    }
    } // choice_1
    if (r4!== peg$FAILED) {
      r3 = [];
      while (r4 !== peg$FAILED) {
        r3.push(r4);
        choice_2: {
        r4 = peg$parsetplarg_or_template(true);
        if (r4!== peg$FAILED) {
          break choice_2;
        }
        if (peg$currPos < input.length) {
          r4 = input.charAt(peg$currPos++);
        } else {
          r4 = peg$FAILED;
        }
        } // choice_2
      }
    } else {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c22(r3);
    } else {
      if (!silence) {peg$fail(peg$c23);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsenowiki_content(silence) {
    var r1,p2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*65).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    r3 = [];
    choice_1: {
    r4 = peg$parsehtmlentity(true);
    if (r4!== peg$FAILED) {
      break choice_1;
    }
    if (peg$currPos < input.length) {
      r4 = input.charAt(peg$currPos++);
    } else {
      r4 = peg$FAILED;
    }
    } // choice_1
    while (r4 !== peg$FAILED) {
      r3.push(r4);
      choice_2: {
      r4 = peg$parsehtmlentity(true);
      if (r4!== peg$FAILED) {
        break choice_2;
      }
      if (peg$currPos < input.length) {
        r4 = input.charAt(peg$currPos++);
      } else {
        r4 = peg$FAILED;
      }
      } // choice_2
    }
    // c <- r3
    // free r4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c24(r3);
    } else {
      if (!silence) {peg$fail(peg$c25);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseextlink(silence) {
    var r1,p2,p3,r4,r5,p6,p7,r8,r9,p10,r11,r12,r13,r14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*23).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c26();
    if (!r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r8 = "[";
      peg$currPos += 1;
    } else {
      r8 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    peg$savedPos = peg$currPos;
    r8 = peg$c27(r5);
    if (r8) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    choice_2: {
    seq_3: {
    p10 = peg$currPos;
    r11 = peg$parseurl_protocol(true);
    if (r11 === peg$FAILED) {
      r9 = peg$FAILED;
      break seq_3;
    }
    r12 = peg$parseurladdr(true);
    if (r12 === peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    r9 = [r11,r12];
    } // seq_3
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    // free r11,r12,p10
    r9 = '';
    } // choice_2
    // addr <- r9
    r8 = r9;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    choice_3: {
    r12 = peg$parseextlink_preprocessor_text(true);
    if (r12!== peg$FAILED) {
      break choice_3;
    }
    r12 = '';
    } // choice_3
    // target <- r12
    r8 = r12;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    peg$savedPos = peg$currPos;
    r8 = peg$c28(r5,r9,r12);
    if (r8) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    p10 = peg$currPos;
    choice_4: {
    r13 = peg$discardspace(true);
    if (r13!== peg$FAILED) {
      break choice_4;
    }
    r13 = peg$discardunispace(true);
    } // choice_4
    while (r13 !== peg$FAILED) {
      choice_5: {
      r13 = peg$discardspace(true);
      if (r13!== peg$FAILED) {
        break choice_5;
      }
      r13 = peg$discardunispace(true);
      } // choice_5
    }
    // free r13
    r11 = true;
    // sp <- r11
    if (r11!== peg$FAILED) {
      r11 = input.substring(p10,peg$currPos);
    } else {
      r11 = peg$FAILED;
    }
    // free p10
    r8 = r11;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    p10 = peg$currPos;
    r13 = '';
    // targetOff <- r13
    if (r13!== peg$FAILED) {
      peg$savedPos = p10;
      r13 = peg$c29(r5,r9,r12,r11,r13);
    }
    r8 = r13;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r14 = peg$parseinlineline(true);
    if (r14 === peg$FAILED) {
      r14 = null;
    }
    // content <- r14
    r8 = r14;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 93) {
      r8 = "]";
      peg$currPos += 1;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c30(r5,r9,r12,r11,r13,r14);
      break choice_1;
    }
    // free r8,p7
    seq_4: {
    p7 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r8 = "[";
      peg$currPos += 1;
    } else {
      r8 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_4;
    }
    peg$savedPos = peg$currPos;
    r15 = peg$c31(r5);
    if (r15) {
      r15 = void 0;
    } else {
      r15 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_4;
    }
    r5 = [r8,r15];
    } // seq_4
    // free r8,r15,p7
    } // choice_1
    // r <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c32(r5);
    } else {
      if (!silence) {peg$fail(peg$c33);}
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetlb(silence) {
    var r1,p2,p3,r4,p5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*6).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = peg$discardeof(true);
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r6 = peg$parseblock(true);
    // b <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c34(r6);
    } else {
      if (!silence) {peg$fail(peg$c35);}
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsenewlineToken(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*121).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    r1 = peg$discardnewline(silence);
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c36();
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardtlb(silence) {
    var r1,p2,p3,r4,p5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*6).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = peg$discardeof(true);
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r6 = peg$parseblock(true);
    // b <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c34(r6);
    } else {
      if (!silence) {peg$fail(peg$c35);}
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardnewlineToken(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*121).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    r1 = peg$discardnewline(silence);
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c36();
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsespace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*103).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \t]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c37);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsecomment(silence) {
    var r1,p2,p3,r4,r5,p6,r7,p8,r9,p10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*19).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "<!--") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c38);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    p10 = peg$currPos;
    r9 = input.substr(peg$currPos,3);
    if (r9 === "-->") {
      peg$currPos += 3;
    } else {
      r9 = peg$FAILED;
    }
    if (r9 === peg$FAILED) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p10;
      r7 = peg$FAILED;
      break seq_2;
    }
    // free p10
    if (peg$currPos < input.length) {
      r9 = input.charAt(peg$currPos++);
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c39);}
      peg$currPos = p8;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = true;
    } // seq_2
    // free r9,p8
    while (r7 !== peg$FAILED) {
      seq_3: {
      p8 = peg$currPos;
      p10 = peg$currPos;
      r9 = input.substr(peg$currPos,3);
      if (r9 === "-->") {
        peg$currPos += 3;
      } else {
        r9 = peg$FAILED;
      }
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p10;
        r7 = peg$FAILED;
        break seq_3;
      }
      // free p10
      if (peg$currPos < input.length) {
        r9 = input.charAt(peg$currPos++);
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c39);}
        peg$currPos = p8;
        r7 = peg$FAILED;
        break seq_3;
      }
      r7 = true;
      } // seq_3
      // free r9,p8
    }
    // free r7
    r5 = true;
    // c <- r5
    if (r5!== peg$FAILED) {
      r5 = input.substring(p6,peg$currPos);
    } else {
      r5 = peg$FAILED;
    }
    // free p6
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r4 = input.substr(peg$currPos,3);
    if (r4 === "-->") {
      peg$currPos += 3;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c40);}
      r4 = peg$FAILED;
    }
    r4 = peg$discardeof(silence);
    } // choice_1
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c41(r5);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsepipe(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*133).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 124) {
      r1 = "|";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,5);
    if (r1 === "{{!}}") {
      peg$currPos += 5;
    } else {
      if (!silence) {peg$fail(peg$c43);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseurl_protocol(silence) {
    var r1,p2,p3,r4,r5,p6,p7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*26).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c44();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    choice_1: {
    r5 = input.substr(peg$currPos,2);
    if (r5 === "//") {
      peg$currPos += 2;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c45);}
      r5 = peg$FAILED;
    }
    seq_2: {
    p7 = peg$currPos;
    r8 = input.charAt(peg$currPos);
    if (/^[A-Za-z]/.test(r8)) {
      peg$currPos++;
    } else {
      r8 = peg$FAILED;
      if (!silence) {peg$fail(peg$c46);}
      r5 = peg$FAILED;
      break seq_2;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[\-A-Za-z0-9+.]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c47);}
    }
    while (r9 !== peg$FAILED) {
      r9 = input.charAt(peg$currPos);
      if (/^[\-A-Za-z0-9+.]/.test(r9)) {
        peg$currPos++;
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c47);}
      }
    }
    // free r9
    r8 = true;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 58) {
      r8 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c48);}
      r8 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r8 = input.substr(peg$currPos,2);
    if (r8 === "//") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c45);}
      r8 = peg$FAILED;
      r8 = null;
    }
    r5 = true;
    } // seq_2
    // free r8,p7
    } // choice_1
    // p <- r5
    if (r5!== peg$FAILED) {
      r5 = input.substring(p6,peg$currPos);
    } else {
      r5 = peg$FAILED;
    }
    // free p6
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c49(r5);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseurladdr(silence) {
    var p1,r2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*30).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r4 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c50);}
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    r5 = input.charAt(peg$currPos);
    if (/^[0-9A-Fa-f:.]/.test(r5)) {
      peg$currPos++;
      r4 = true;
      while (r5 !== peg$FAILED) {
        r5 = input.charAt(peg$currPos);
        if (/^[0-9A-Fa-f:.]/.test(r5)) {
          peg$currPos++;
        } else {
          r5 = peg$FAILED;
          if (!silence) {peg$fail(peg$c51);}
        }
      }
    } else {
      r5 = peg$FAILED;
      if (!silence) {peg$fail(peg$c51);}
      r4 = peg$FAILED;
    }
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r5
    if (input.charCodeAt(peg$currPos) === 93) {
      r4 = "]";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c52);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      r2 = input.substring(p1,peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r4,p3
    // free p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$discardinline_breaks(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*15).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    peg$savedPos = peg$currPos;
    r1 = peg$c53();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseno_punctuation_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*27).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[^ :\][\r\n"'<>\0- ,.&%\xA0\u1680\u180E\u2000-\u200A\u202F\u205F\u3000{]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c54);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetplarg_or_template(silence) {
    var r1,p2,p3,r4,p5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*31).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "{{") {
      peg$currPos += 2;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    peg$savedPos = peg$currPos;
    r4 = peg$c55();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parsetplarg_or_template_guarded(silence);
    // t <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c56(r6);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsehtmlentity(silence) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*101).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    r3 = peg$parseraw_htmlentity(silence);
    // cc <- r3
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c57(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardpipe(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*133).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 124) {
      r1 = "|";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,5);
    if (r1 === "{{!}}") {
      peg$currPos += 5;
    } else {
      if (!silence) {peg$fail(peg$c43);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_attribute(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,p10,r11,p12,p13,r14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*73).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parseoptionalSpaceToken(silence);
    // s <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r6 = '';
    // namePos0 <- r6
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c58(r5,r6);
    }
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parsetable_attribute_name(silence);
    // name <- r8
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p10 = peg$currPos;
    r9 = '';
    // namePos <- r9
    if (r9!== peg$FAILED) {
      peg$savedPos = p10;
      r9 = peg$c59(r5,r6,r8,r9);
    }
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p12 = peg$currPos;
    seq_2: {
    p13 = peg$currPos;
    r14 = peg$discardoptionalSpaceToken(silence);
    if (r14 === peg$FAILED) {
      r11 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 61) {
      r14 = "=";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c60);}
      r14 = peg$FAILED;
      peg$currPos = p13;
      r11 = peg$FAILED;
      break seq_2;
    }
    r15 = peg$parsetable_att_value(silence);
    if (r15 === peg$FAILED) {
      r15 = null;
    }
    // v <- r15
    r14 = r15;
    if (r14 === peg$FAILED) {
      peg$currPos = p13;
      r11 = peg$FAILED;
      break seq_2;
    }
    r11 = true;
    } // seq_2
    if (r11!== peg$FAILED) {
      peg$savedPos = p12;
      r11 = peg$c61(r5,r6,r8,r9,r11,r15);
    } else {
      r11 = null;
    }
    // free r14,p13
    // vd <- r11
    r4 = r11;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c62(r5,r6,r8,r9,r11);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardoptionalSpaceToken(silence) {
    var r1,p2,r3,p4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*104).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    r5 = peg$discardspace(silence);
    while (r5 !== peg$FAILED) {
      r5 = peg$discardspace(silence);
    }
    // free r5
    r3 = true;
    // s <- r3
    if (r3!== peg$FAILED) {
      r3 = input.substring(p4,peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c63(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsebroken_table_attribute_name_char(silence) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*76).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    r3 = input.charAt(peg$currPos);
    // c <- r3
    if (/^[\0\/=>]/.test(r3)) {
      peg$currPos++;
    } else {
      r3 = peg$FAILED;
      if (!silence) {peg$fail(peg$c64);}
    }
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c65(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsegeneric_newline_attribute(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,r10,p11,p12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*72).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$discardspace_or_newline_or_solidus(silence);
    while (r5 !== peg$FAILED) {
      r5 = peg$discardspace_or_newline_or_solidus(silence);
    }
    // free r5
    r4 = true;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // namePos0 <- r5
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c66(r5);
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsegeneric_attribute_name(silence);
    // name <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p9 = peg$currPos;
    r8 = '';
    // namePos <- r8
    if (r8!== peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$c67(r5,r7,r8);
    }
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p11 = peg$currPos;
    seq_2: {
    p12 = peg$currPos;
    r14 = peg$discardspace_or_newline(silence);
    while (r14 !== peg$FAILED) {
      r14 = peg$discardspace_or_newline(silence);
    }
    // free r14
    r13 = true;
    if (r13 === peg$FAILED) {
      r10 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 61) {
      r13 = "=";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c60);}
      r13 = peg$FAILED;
      peg$currPos = p12;
      r10 = peg$FAILED;
      break seq_2;
    }
    r14 = peg$parsegeneric_att_value(silence);
    if (r14 === peg$FAILED) {
      r14 = null;
    }
    // v <- r14
    r13 = r14;
    if (r13 === peg$FAILED) {
      peg$currPos = p12;
      r10 = peg$FAILED;
      break seq_2;
    }
    r10 = true;
    } // seq_2
    if (r10!== peg$FAILED) {
      peg$savedPos = p11;
      r10 = peg$c68(r5,r7,r8,r10,r14);
    } else {
      r10 = null;
    }
    // free r13,p12
    // vd <- r10
    r4 = r10;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c69(r5,r7,r8,r10);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseextlink_preprocessor_text(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,p9,p10,r11,p12,r13,p14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*126).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c70();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    p7 = peg$currPos;
    r8 = input.charAt(peg$currPos);
    if (/^[^'<~[{\n\r|!\]}\-\t&="' \xA0\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(r8)) {
      peg$currPos++;
      r6 = true;
      while (r8 !== peg$FAILED) {
        r8 = input.charAt(peg$currPos);
        if (/^[^'<~[{\n\r|!\]}\-\t&="' \xA0\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(r8)) {
          peg$currPos++;
        } else {
          r8 = peg$FAILED;
          if (!silence) {peg$fail(peg$c71);}
        }
      }
    } else {
      r8 = peg$FAILED;
      if (!silence) {peg$fail(peg$c71);}
      r6 = peg$FAILED;
    }
    if (r6!== peg$FAILED) {
      r6 = input.substring(p7,peg$currPos);
      break choice_2;
    } else {
      r6 = peg$FAILED;
    }
    // free r8
    // free p7
    p7 = peg$currPos;
    seq_2: {
    p9 = peg$currPos;
    p10 = peg$currPos;
    r8 = peg$discardinline_breaks(true);
    if (r8 === peg$FAILED) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p10;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free p10
    choice_3: {
    r11 = peg$parsedirective(silence);
    if (r11!== peg$FAILED) {
      break choice_3;
    }
    r11 = peg$parseno_punctuation_char(silence);
    if (r11!== peg$FAILED) {
      break choice_3;
    }
    r11 = input.charAt(peg$currPos);
    if (/^[&|{\-]/.test(r11)) {
      peg$currPos++;
    } else {
      r11 = peg$FAILED;
      if (!silence) {peg$fail(peg$c72);}
    }
    } // choice_3
    // s <- r11
    r8 = r11;
    if (r8 === peg$FAILED) {
      peg$currPos = p9;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c73(r5,r11);
      break choice_2;
    }
    // free r8,p9
    p9 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    r8 = input.charAt(peg$currPos);
    if (/^[.:,]/.test(r8)) {
      peg$currPos++;
    } else {
      r8 = peg$FAILED;
      if (!silence) {peg$fail(peg$c74);}
      r6 = peg$FAILED;
      break seq_3;
    }
    p12 = peg$currPos;
    choice_4: {
    r8 = peg$discardspace(true);
    if (r8!== peg$FAILED) {
      break choice_4;
    }
    r8 = peg$discardeolf(true);
    } // choice_4
    if (r8 === peg$FAILED) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p12;
      peg$currPos = p10;
      r6 = peg$FAILED;
      break seq_3;
    }
    // free p12
    r6 = true;
    } // seq_3
    if (r6!== peg$FAILED) {
      r6 = input.substring(p9,peg$currPos);
      break choice_2;
    } else {
      r6 = peg$FAILED;
    }
    // free r8,p10
    // free p9
    p9 = peg$currPos;
    seq_4: {
    p10 = peg$currPos;
    r8 = input.charAt(peg$currPos);
    if (/^[']/.test(r8)) {
      peg$currPos++;
    } else {
      r8 = peg$FAILED;
      if (!silence) {peg$fail(peg$c75);}
      r6 = peg$FAILED;
      break seq_4;
    }
    p12 = peg$currPos;
    r8 = input.charAt(peg$currPos);
    if (/^[']/.test(r8)) {
      peg$currPos++;
    } else {
      r8 = peg$FAILED;
    }
    if (r8 === peg$FAILED) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p12;
      peg$currPos = p10;
      r6 = peg$FAILED;
      break seq_4;
    }
    // free p12
    r6 = true;
    } // seq_4
    if (r6!== peg$FAILED) {
      r6 = input.substring(p9,peg$currPos);
    } else {
      r6 = peg$FAILED;
    }
    // free r8,p10
    // free p9
    } // choice_2
    if (r6!== peg$FAILED) {
      r5 = [];
      while (r6 !== peg$FAILED) {
        r5.push(r6);
        choice_5: {
        p9 = peg$currPos;
        r8 = input.charAt(peg$currPos);
        if (/^[^'<~[{\n\r|!\]}\-\t&="' \xA0\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(r8)) {
          peg$currPos++;
          r6 = true;
          while (r8 !== peg$FAILED) {
            r8 = input.charAt(peg$currPos);
            if (/^[^'<~[{\n\r|!\]}\-\t&="' \xA0\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(r8)) {
              peg$currPos++;
            } else {
              r8 = peg$FAILED;
              if (!silence) {peg$fail(peg$c71);}
            }
          }
        } else {
          r8 = peg$FAILED;
          if (!silence) {peg$fail(peg$c71);}
          r6 = peg$FAILED;
        }
        if (r6!== peg$FAILED) {
          r6 = input.substring(p9,peg$currPos);
          break choice_5;
        } else {
          r6 = peg$FAILED;
        }
        // free r8
        // free p9
        p9 = peg$currPos;
        seq_5: {
        p10 = peg$currPos;
        p12 = peg$currPos;
        r8 = peg$discardinline_breaks(true);
        if (r8 === peg$FAILED) {
          r8 = void 0;
        } else {
          r8 = peg$FAILED;
          peg$currPos = p12;
          r6 = peg$FAILED;
          break seq_5;
        }
        // free p12
        choice_6: {
        r13 = peg$parsedirective(silence);
        if (r13!== peg$FAILED) {
          break choice_6;
        }
        r13 = peg$parseno_punctuation_char(silence);
        if (r13!== peg$FAILED) {
          break choice_6;
        }
        r13 = input.charAt(peg$currPos);
        if (/^[&|{\-]/.test(r13)) {
          peg$currPos++;
        } else {
          r13 = peg$FAILED;
          if (!silence) {peg$fail(peg$c72);}
        }
        } // choice_6
        // s <- r13
        r8 = r13;
        if (r8 === peg$FAILED) {
          peg$currPos = p10;
          r6 = peg$FAILED;
          break seq_5;
        }
        r6 = true;
        } // seq_5
        if (r6!== peg$FAILED) {
          peg$savedPos = p9;
          r6 = peg$c73(r5,r13);
          break choice_5;
        }
        // free r8,p10
        p10 = peg$currPos;
        seq_6: {
        p12 = peg$currPos;
        r8 = input.charAt(peg$currPos);
        if (/^[.:,]/.test(r8)) {
          peg$currPos++;
        } else {
          r8 = peg$FAILED;
          if (!silence) {peg$fail(peg$c74);}
          r6 = peg$FAILED;
          break seq_6;
        }
        p14 = peg$currPos;
        choice_7: {
        r8 = peg$discardspace(true);
        if (r8!== peg$FAILED) {
          break choice_7;
        }
        r8 = peg$discardeolf(true);
        } // choice_7
        if (r8 === peg$FAILED) {
          r8 = void 0;
        } else {
          r8 = peg$FAILED;
          peg$currPos = p14;
          peg$currPos = p12;
          r6 = peg$FAILED;
          break seq_6;
        }
        // free p14
        r6 = true;
        } // seq_6
        if (r6!== peg$FAILED) {
          r6 = input.substring(p10,peg$currPos);
          break choice_5;
        } else {
          r6 = peg$FAILED;
        }
        // free r8,p12
        // free p10
        p10 = peg$currPos;
        seq_7: {
        p12 = peg$currPos;
        r8 = input.charAt(peg$currPos);
        if (/^[']/.test(r8)) {
          peg$currPos++;
        } else {
          r8 = peg$FAILED;
          if (!silence) {peg$fail(peg$c75);}
          r6 = peg$FAILED;
          break seq_7;
        }
        p14 = peg$currPos;
        r8 = input.charAt(peg$currPos);
        if (/^[']/.test(r8)) {
          peg$currPos++;
        } else {
          r8 = peg$FAILED;
        }
        if (r8 === peg$FAILED) {
          r8 = void 0;
        } else {
          r8 = peg$FAILED;
          peg$currPos = p14;
          peg$currPos = p12;
          r6 = peg$FAILED;
          break seq_7;
        }
        // free p14
        r6 = true;
        } // seq_7
        if (r6!== peg$FAILED) {
          r6 = input.substring(p10,peg$currPos);
        } else {
          r6 = peg$FAILED;
        }
        // free r8,p12
        // free p10
        } // choice_5
      }
    } else {
      r5 = peg$FAILED;
    }
    // r <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c76(r5);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c77();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardspace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*103).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \t]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c37);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardunispace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*107).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c78);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseinlineline(silence) {
    var r1,p2,r3,r4,p5,p6,r7,p8,r9,p10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*16).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    choice_1: {
    r4 = peg$parseurltext(silence);
    if (r4!== peg$FAILED) {
      break choice_1;
    }
    p5 = peg$currPos;
    seq_1: {
    p6 = peg$currPos;
    p8 = peg$currPos;
    r7 = peg$discardinline_breaks(true);
    if (r7 === peg$FAILED) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p8;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p8
    choice_2: {
    r9 = peg$parseinline_element(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[^\r\n]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c79);}
    }
    } // choice_2
    // r <- r9
    r7 = r9;
    if (r7 === peg$FAILED) {
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_1;
    }
    r4 = true;
    } // seq_1
    if (r4!== peg$FAILED) {
      peg$savedPos = p5;
      r4 = peg$c80(r3,r9);
    }
    // free r7,p6
    } // choice_1
    if (r4!== peg$FAILED) {
      r3 = [];
      while (r4 !== peg$FAILED) {
        r3.push(r4);
        choice_3: {
        r4 = peg$parseurltext(silence);
        if (r4!== peg$FAILED) {
          break choice_3;
        }
        p6 = peg$currPos;
        seq_2: {
        p8 = peg$currPos;
        p10 = peg$currPos;
        r7 = peg$discardinline_breaks(true);
        if (r7 === peg$FAILED) {
          r7 = void 0;
        } else {
          r7 = peg$FAILED;
          peg$currPos = p10;
          r4 = peg$FAILED;
          break seq_2;
        }
        // free p10
        choice_4: {
        r11 = peg$parseinline_element(silence);
        if (r11!== peg$FAILED) {
          break choice_4;
        }
        r11 = input.charAt(peg$currPos);
        if (/^[^\r\n]/.test(r11)) {
          peg$currPos++;
        } else {
          r11 = peg$FAILED;
          if (!silence) {peg$fail(peg$c79);}
        }
        } // choice_4
        // r <- r11
        r7 = r11;
        if (r7 === peg$FAILED) {
          peg$currPos = p8;
          r4 = peg$FAILED;
          break seq_2;
        }
        r4 = true;
        } // seq_2
        if (r4!== peg$FAILED) {
          peg$savedPos = p6;
          r4 = peg$c80(r3,r11);
        }
        // free r7,p8
        } // choice_3
      }
    } else {
      r3 = peg$FAILED;
    }
    // c <- r3
    // free r4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c81(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardeof(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*119).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    peg$savedPos = peg$currPos;
    r1 = peg$c82();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseblock(silence) {
    var r1,p2,p3,r4,p5,r6,r7,r8,p9,r10,p11,r12,r13,p14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*7).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = peg$discardsof(true);
    if (r4!== peg$FAILED) {
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r6 = peg$parseredirect(silence);
    // r <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsecomment_or_includes(silence);
    // cil <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parseblock_line(silence);
    if (r8 === peg$FAILED) {
      r8 = null;
    }
    // bl <- r8
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c83(r6,r7,r8);
      break choice_1;
    }
    // free r4,p3
    r1 = peg$parseblock_lines(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    p3 = peg$currPos;
    seq_2: {
    p5 = peg$currPos;
    p9 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
      r4 = void 0;
      peg$currPos = p9;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p9
    choice_2: {
    p9 = peg$currPos;
    seq_3: {
    p11 = peg$currPos;
    r13 = peg$parsecomment(silence);
    // c <- r13
    r12 = r13;
    if (r12 === peg$FAILED) {
      r10 = peg$FAILED;
      break seq_3;
    }
    p14 = peg$currPos;
    r12 = peg$discardeolf(true);
    if (r12!== peg$FAILED) {
      r12 = void 0;
      peg$currPos = p14;
    } else {
      peg$currPos = p11;
      r10 = peg$FAILED;
      break seq_3;
    }
    // free p14
    r10 = true;
    } // seq_3
    if (r10!== peg$FAILED) {
      peg$savedPos = p9;
      r10 = peg$c84(r10,r13);
      break choice_2;
    }
    // free r12,p11
    r12 = peg$parseblock_tag(silence);
    // bt <- r12
    r10 = r12;
    } // choice_2
    // rs <- r10
    r4 = r10;
    if (r4 === peg$FAILED) {
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = true;
    } // seq_2
    if (r1!== peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$c85(r10);
      break choice_1;
    }
    // free r4,p5
    r1 = peg$parseparagraph(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseinlineline(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    p5 = peg$currPos;
    seq_4: {
    p11 = peg$currPos;
    r15 = peg$parsesol(silence);
    // s <- r15
    r4 = r15;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_4;
    }
    p14 = peg$currPos;
    r4 = peg$discardinline_breaks(true);
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p14;
      peg$currPos = p11;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free p14
    r1 = true;
    } // seq_4
    if (r1!== peg$FAILED) {
      peg$savedPos = p5;
      r1 = peg$c86(r15);
    }
    // free r4,p11
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardnewline(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*120).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 10) {
      r1 = "\n";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c87);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,2);
    if (r1 === "\r\n") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c88);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetplarg_or_template_guarded(silence) {
    var r1,p2,p3,r4,r5,p6,p7,r8,p9,p10,r11,p12,p13,r14,r15,p16,r17,r18,p19,r20,p21;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*32).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c89();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    p9 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    r11 = input.substr(peg$currPos,2);
    if (r11 === "{{") {
      peg$currPos += 2;
    } else {
      r11 = peg$FAILED;
      r8 = peg$FAILED;
      break seq_3;
    }
    p12 = peg$currPos;
    seq_4: {
    p13 = peg$currPos;
    r15 = input.substr(peg$currPos,3);
    if (r15 === "{{{") {
      peg$currPos += 3;
      r14 = true;
      while (r15 !== peg$FAILED) {
        r15 = input.substr(peg$currPos,3);
        if (r15 === "{{{") {
          peg$currPos += 3;
        } else {
          r15 = peg$FAILED;
        }
      }
    } else {
      r15 = peg$FAILED;
      r14 = peg$FAILED;
    }
    if (r14 === peg$FAILED) {
      r11 = peg$FAILED;
      break seq_4;
    }
    // free r15
    p16 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r14 = "{";
      peg$currPos += 1;
    } else {
      r14 = peg$FAILED;
    }
    if (r14 === peg$FAILED) {
      r14 = void 0;
    } else {
      r14 = peg$FAILED;
      peg$currPos = p16;
      peg$currPos = p13;
      r11 = peg$FAILED;
      break seq_4;
    }
    // free p16
    r11 = true;
    } // seq_4
    if (r11!== peg$FAILED) {
      r11 = void 0;
      peg$currPos = p12;
    } else {
      peg$currPos = p10;
      r8 = peg$FAILED;
      break seq_3;
    }
    // free r14,p13
    // free p12
    r11 = peg$discardtplarg(true);
    if (r11 === peg$FAILED) {
      peg$currPos = p10;
      r8 = peg$FAILED;
      break seq_3;
    }
    r8 = true;
    } // seq_3
    if (r8!== peg$FAILED) {
      r8 = void 0;
      peg$currPos = p9;
    } else {
      r5 = peg$FAILED;
      break seq_2;
    }
    // free r11,p10
    // free p9
    choice_3: {
    r11 = peg$parsetemplate(silence);
    if (r11!== peg$FAILED) {
      break choice_3;
    }
    r11 = peg$parsebroken_template(silence);
    } // choice_3
    // a <- r11
    r8 = r11;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c90(r5,r11);
      break choice_2;
    }
    // free r8,p7
    p7 = peg$currPos;
    seq_5: {
    p9 = peg$currPos;
    p10 = peg$currPos;
    seq_6: {
    p12 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r15 = "{";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c91);}
      r15 = peg$FAILED;
      r14 = peg$FAILED;
      break seq_6;
    }
    p13 = peg$currPos;
    seq_7: {
    p16 = peg$currPos;
    r18 = input.substr(peg$currPos,3);
    if (r18 === "{{{") {
      peg$currPos += 3;
      r17 = true;
      while (r18 !== peg$FAILED) {
        r18 = input.substr(peg$currPos,3);
        if (r18 === "{{{") {
          peg$currPos += 3;
        } else {
          r18 = peg$FAILED;
        }
      }
    } else {
      r18 = peg$FAILED;
      r17 = peg$FAILED;
    }
    if (r17 === peg$FAILED) {
      r15 = peg$FAILED;
      break seq_7;
    }
    // free r18
    p19 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r17 = "{";
      peg$currPos += 1;
    } else {
      r17 = peg$FAILED;
    }
    if (r17 === peg$FAILED) {
      r17 = void 0;
    } else {
      r17 = peg$FAILED;
      peg$currPos = p19;
      peg$currPos = p16;
      r15 = peg$FAILED;
      break seq_7;
    }
    // free p19
    r15 = true;
    } // seq_7
    if (r15!== peg$FAILED) {
      r15 = void 0;
      peg$currPos = p13;
    } else {
      peg$currPos = p12;
      r14 = peg$FAILED;
      break seq_6;
    }
    // free r17,p16
    // free p13
    r14 = true;
    } // seq_6
    if (r14 === peg$FAILED) {
      r14 = null;
    }
    // free r15,p12
    // a <- r14
    r14 = input.substring(p10,peg$currPos);
    // free p10
    r8 = r14;
    if (r8 === peg$FAILED) {
      r5 = peg$FAILED;
      break seq_5;
    }
    r15 = peg$parsetplarg(silence);
    // b <- r15
    r8 = r15;
    if (r8 === peg$FAILED) {
      peg$currPos = p9;
      r5 = peg$FAILED;
      break seq_5;
    }
    r5 = true;
    } // seq_5
    if (r5!== peg$FAILED) {
      peg$savedPos = p7;
      r5 = peg$c92(r5,r14,r15);
      break choice_2;
    }
    // free r8,p9
    p9 = peg$currPos;
    seq_8: {
    p10 = peg$currPos;
    p12 = peg$currPos;
    seq_9: {
    p13 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r18 = "{";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c91);}
      r18 = peg$FAILED;
      r17 = peg$FAILED;
      break seq_9;
    }
    p16 = peg$currPos;
    seq_10: {
    p19 = peg$currPos;
    r20 = input.substr(peg$currPos,2);
    if (r20 === "{{") {
      peg$currPos += 2;
    } else {
      r20 = peg$FAILED;
      r18 = peg$FAILED;
      break seq_10;
    }
    p21 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r20 = "{";
      peg$currPos += 1;
    } else {
      r20 = peg$FAILED;
    }
    if (r20 === peg$FAILED) {
      r20 = void 0;
    } else {
      r20 = peg$FAILED;
      peg$currPos = p21;
      peg$currPos = p19;
      r18 = peg$FAILED;
      break seq_10;
    }
    // free p21
    r18 = true;
    } // seq_10
    if (r18!== peg$FAILED) {
      r18 = void 0;
      peg$currPos = p16;
    } else {
      peg$currPos = p13;
      r17 = peg$FAILED;
      break seq_9;
    }
    // free r20,p19
    // free p16
    r17 = true;
    } // seq_9
    if (r17 === peg$FAILED) {
      r17 = null;
    }
    // free r18,p13
    // a <- r17
    r17 = input.substring(p12,peg$currPos);
    // free p12
    r8 = r17;
    if (r8 === peg$FAILED) {
      r5 = peg$FAILED;
      break seq_8;
    }
    r18 = peg$parsetemplate(silence);
    // b <- r18
    r8 = r18;
    if (r8 === peg$FAILED) {
      peg$currPos = p10;
      r5 = peg$FAILED;
      break seq_8;
    }
    r5 = true;
    } // seq_8
    if (r5!== peg$FAILED) {
      peg$savedPos = p9;
      r5 = peg$c92(r5,r17,r18);
      break choice_2;
    }
    // free r8,p10
    p10 = peg$currPos;
    r8 = peg$parsebroken_template(silence);
    // a <- r8
    r5 = r8;
    if (r5!== peg$FAILED) {
      peg$savedPos = p10;
      r5 = peg$c90(r5,r8);
    }
    } // choice_2
    // r <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c93(r5);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c94();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseraw_htmlentity(silence) {
    var r1,p2,r3,p4,p5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*100).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      r6 = "&";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c95);}
      r6 = peg$FAILED;
      r3 = peg$FAILED;
      break seq_1;
    }
    r7 = input.charAt(peg$currPos);
    if (/^[#0-9a-zA-Z]/.test(r7)) {
      peg$currPos++;
      r6 = true;
      while (r7 !== peg$FAILED) {
        r7 = input.charAt(peg$currPos);
        if (/^[#0-9a-zA-Z]/.test(r7)) {
          peg$currPos++;
        } else {
          r7 = peg$FAILED;
          if (!silence) {peg$fail(peg$c96);}
        }
      }
    } else {
      r7 = peg$FAILED;
      if (!silence) {peg$fail(peg$c96);}
      r6 = peg$FAILED;
    }
    if (r6 === peg$FAILED) {
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    // free r7
    if (input.charCodeAt(peg$currPos) === 59) {
      r6 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c97);}
      r6 = peg$FAILED;
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    // m <- r3
    if (r3!== peg$FAILED) {
      r3 = input.substring(p4,peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free r6,p5
    // free p4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c98(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseoptionalSpaceToken(silence) {
    var r1,p2,r3,p4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*104).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    r5 = peg$discardspace(silence);
    while (r5 !== peg$FAILED) {
      r5 = peg$discardspace(silence);
    }
    // free r5
    r3 = true;
    // s <- r3
    if (r3!== peg$FAILED) {
      r3 = input.substring(p4,peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c63(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_attribute_name(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,p11,r12,p13,r14,p15,r16,p17,r18,p19,r20,p21,r22,p23,r24;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*77).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = input.charAt(peg$currPos);
    if (/^["'=]/.test(r5)) {
      peg$currPos++;
    } else {
      r5 = peg$FAILED;
      if (!silence) {peg$fail(peg$c99);}
      r5 = null;
    }
    // q <- r5
    r5 = input.substring(p6,peg$currPos);
    // free p6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    choice_1: {
    p6 = peg$currPos;
    r9 = input.charAt(peg$currPos);
    if (/^[^ \t\r\n\0\/=><&{}\-!|[]/.test(r9)) {
      peg$currPos++;
      r8 = true;
      while (r9 !== peg$FAILED) {
        r9 = input.charAt(peg$currPos);
        if (/^[^ \t\r\n\0\/=><&{}\-!|[]/.test(r9)) {
          peg$currPos++;
        } else {
          r9 = peg$FAILED;
          if (!silence) {peg$fail(peg$c100);}
        }
      }
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c100);}
      r8 = peg$FAILED;
    }
    if (r8!== peg$FAILED) {
      r8 = input.substring(p6,peg$currPos);
      break choice_1;
    } else {
      r8 = peg$FAILED;
    }
    // free r9
    // free p6
    p6 = peg$currPos;
    seq_2: {
    p10 = peg$currPos;
    p11 = peg$currPos;
    r9 = peg$discardinline_breaks(true);
    if (r9 === peg$FAILED) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p11;
      r8 = peg$FAILED;
      break seq_2;
    }
    // free p11
    choice_2: {
    p11 = peg$currPos;
    r12 = peg$discardwikilink(silence);
    if (r12!== peg$FAILED) {
      r12 = input.substring(p11,peg$currPos);
      break choice_2;
    } else {
      r12 = peg$FAILED;
    }
    // free p11
    r12 = peg$parsedirective(silence);
    if (r12!== peg$FAILED) {
      break choice_2;
    }
    p11 = peg$currPos;
    seq_3: {
    p13 = peg$currPos;
    p15 = peg$currPos;
    r14 = peg$discardxmlish_tag(true);
    if (r14!== peg$FAILED) {
      r14 = void 0;
      peg$currPos = p15;
    } else {
      r12 = peg$FAILED;
      break seq_3;
    }
    // free p15
    r16 = peg$parseinlineline(silence);
    // ill <- r16
    r14 = r16;
    if (r14 === peg$FAILED) {
      peg$currPos = p13;
      r12 = peg$FAILED;
      break seq_3;
    }
    r12 = true;
    } // seq_3
    if (r12!== peg$FAILED) {
      peg$savedPos = p11;
      r12 = peg$c101(r5,r7,r12,r16);
      break choice_2;
    }
    // free r14,p13
    p13 = peg$currPos;
    seq_4: {
    p15 = peg$currPos;
    p17 = peg$currPos;
    choice_3: {
    r14 = peg$discardspace_or_newline(true);
    if (r14!== peg$FAILED) {
      break choice_3;
    }
    r14 = input.charAt(peg$currPos);
    if (/^[\0\/=>]/.test(r14)) {
      peg$currPos++;
    } else {
      r14 = peg$FAILED;
    }
    } // choice_3
    if (r14 === peg$FAILED) {
      r14 = void 0;
    } else {
      r14 = peg$FAILED;
      peg$currPos = p17;
      r12 = peg$FAILED;
      break seq_4;
    }
    // free p17
    // c <- r18
    if (peg$currPos < input.length) {
      r18 = input.charAt(peg$currPos++);
    } else {
      r18 = peg$FAILED;
      if (!silence) {peg$fail(peg$c39);}
    }
    r14 = r18;
    if (r14 === peg$FAILED) {
      peg$currPos = p15;
      r12 = peg$FAILED;
      break seq_4;
    }
    r12 = true;
    } // seq_4
    if (r12!== peg$FAILED) {
      peg$savedPos = p13;
      r12 = peg$c102(r5,r7,r12,r18);
    }
    // free r14,p15
    } // choice_2
    // t <- r12
    r9 = r12;
    if (r9 === peg$FAILED) {
      peg$currPos = p10;
      r8 = peg$FAILED;
      break seq_2;
    }
    r8 = true;
    } // seq_2
    if (r8!== peg$FAILED) {
      peg$savedPos = p6;
      r8 = peg$c103(r5,r7,r12);
    }
    // free r9,p10
    } // choice_1
    while (r8 !== peg$FAILED) {
      r7.push(r8);
      choice_4: {
      p10 = peg$currPos;
      r9 = input.charAt(peg$currPos);
      if (/^[^ \t\r\n\0\/=><&{}\-!|[]/.test(r9)) {
        peg$currPos++;
        r8 = true;
        while (r9 !== peg$FAILED) {
          r9 = input.charAt(peg$currPos);
          if (/^[^ \t\r\n\0\/=><&{}\-!|[]/.test(r9)) {
            peg$currPos++;
          } else {
            r9 = peg$FAILED;
            if (!silence) {peg$fail(peg$c100);}
          }
        }
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c100);}
        r8 = peg$FAILED;
      }
      if (r8!== peg$FAILED) {
        r8 = input.substring(p10,peg$currPos);
        break choice_4;
      } else {
        r8 = peg$FAILED;
      }
      // free r9
      // free p10
      p10 = peg$currPos;
      seq_5: {
      p15 = peg$currPos;
      p17 = peg$currPos;
      r9 = peg$discardinline_breaks(true);
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p17;
        r8 = peg$FAILED;
        break seq_5;
      }
      // free p17
      choice_5: {
      p17 = peg$currPos;
      r14 = peg$discardwikilink(silence);
      if (r14!== peg$FAILED) {
        r14 = input.substring(p17,peg$currPos);
        break choice_5;
      } else {
        r14 = peg$FAILED;
      }
      // free p17
      r14 = peg$parsedirective(silence);
      if (r14!== peg$FAILED) {
        break choice_5;
      }
      p17 = peg$currPos;
      seq_6: {
      p19 = peg$currPos;
      p21 = peg$currPos;
      r20 = peg$discardxmlish_tag(true);
      if (r20!== peg$FAILED) {
        r20 = void 0;
        peg$currPos = p21;
      } else {
        r14 = peg$FAILED;
        break seq_6;
      }
      // free p21
      r22 = peg$parseinlineline(silence);
      // ill <- r22
      r20 = r22;
      if (r20 === peg$FAILED) {
        peg$currPos = p19;
        r14 = peg$FAILED;
        break seq_6;
      }
      r14 = true;
      } // seq_6
      if (r14!== peg$FAILED) {
        peg$savedPos = p17;
        r14 = peg$c101(r5,r7,r14,r22);
        break choice_5;
      }
      // free r20,p19
      p19 = peg$currPos;
      seq_7: {
      p21 = peg$currPos;
      p23 = peg$currPos;
      choice_6: {
      r20 = peg$discardspace_or_newline(true);
      if (r20!== peg$FAILED) {
        break choice_6;
      }
      r20 = input.charAt(peg$currPos);
      if (/^[\0\/=>]/.test(r20)) {
        peg$currPos++;
      } else {
        r20 = peg$FAILED;
      }
      } // choice_6
      if (r20 === peg$FAILED) {
        r20 = void 0;
      } else {
        r20 = peg$FAILED;
        peg$currPos = p23;
        r14 = peg$FAILED;
        break seq_7;
      }
      // free p23
      // c <- r24
      if (peg$currPos < input.length) {
        r24 = input.charAt(peg$currPos++);
      } else {
        r24 = peg$FAILED;
        if (!silence) {peg$fail(peg$c39);}
      }
      r20 = r24;
      if (r20 === peg$FAILED) {
        peg$currPos = p21;
        r14 = peg$FAILED;
        break seq_7;
      }
      r14 = true;
      } // seq_7
      if (r14!== peg$FAILED) {
        peg$savedPos = p19;
        r14 = peg$c102(r5,r7,r14,r24);
      }
      // free r20,p21
      } // choice_5
      // t <- r14
      r9 = r14;
      if (r9 === peg$FAILED) {
        peg$currPos = p15;
        r8 = peg$FAILED;
        break seq_5;
      }
      r8 = true;
      } // seq_5
      if (r8!== peg$FAILED) {
        peg$savedPos = p10;
        r8 = peg$c103(r5,r7,r14);
      }
      // free r9,p15
      } // choice_4
    }
    // r <- r7
    // free r8
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c104(r5,r7);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c105(r5,r7);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_att_value(silence) {
    var r1,p2,p3,r4,r5,p6,p7,r8,r9,r10,p11,r12,r13,r14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*79).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    r9 = peg$discardspace(silence);
    while (r9 !== peg$FAILED) {
      r9 = peg$discardspace(silence);
    }
    // free r9
    r8 = true;
    if (r8 === peg$FAILED) {
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 39) {
      r8 = "'";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c106);}
      r8 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    // s <- r5
    if (r5!== peg$FAILED) {
      r5 = input.substring(p6,peg$currPos);
    } else {
      r5 = peg$FAILED;
    }
    // free r8,p7
    // free p6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parsetable_attribute_preprocessor_text_single(silence);
    if (r8 === peg$FAILED) {
      r8 = null;
    }
    // t <- r8
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    choice_2: {
    if (input.charCodeAt(peg$currPos) === 39) {
      r9 = "'";
      peg$currPos += 1;
      break choice_2;
    } else {
      if (!silence) {peg$fail(peg$c106);}
      r9 = peg$FAILED;
    }
    p7 = peg$currPos;
    choice_3: {
    r9 = input.substr(peg$currPos,2);
    if (r9 === "!!") {
      peg$currPos += 2;
      break choice_3;
    } else {
      r9 = peg$FAILED;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[|\r\n]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
    }
    } // choice_3
    if (r9!== peg$FAILED) {
      r9 = void 0;
      peg$currPos = p7;
    }
    // free p7
    } // choice_2
    // q <- r9
    if (r9!== peg$FAILED) {
      r9 = input.substring(p6,peg$currPos);
    } else {
      r9 = peg$FAILED;
    }
    // free p6
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c107(r5,r8,r9);
      break choice_1;
    }
    // free r4,p3
    p3 = peg$currPos;
    seq_3: {
    p6 = peg$currPos;
    p7 = peg$currPos;
    seq_4: {
    p11 = peg$currPos;
    r13 = peg$discardspace(silence);
    while (r13 !== peg$FAILED) {
      r13 = peg$discardspace(silence);
    }
    // free r13
    r12 = true;
    if (r12 === peg$FAILED) {
      r10 = peg$FAILED;
      break seq_4;
    }
    if (input.charCodeAt(peg$currPos) === 34) {
      r12 = "\"";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c108);}
      r12 = peg$FAILED;
      peg$currPos = p11;
      r10 = peg$FAILED;
      break seq_4;
    }
    r10 = true;
    } // seq_4
    // s <- r10
    if (r10!== peg$FAILED) {
      r10 = input.substring(p7,peg$currPos);
    } else {
      r10 = peg$FAILED;
    }
    // free r12,p11
    // free p7
    r4 = r10;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_3;
    }
    r12 = peg$parsetable_attribute_preprocessor_text_double(silence);
    if (r12 === peg$FAILED) {
      r12 = null;
    }
    // t <- r12
    r4 = r12;
    if (r4 === peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_3;
    }
    p7 = peg$currPos;
    choice_4: {
    if (input.charCodeAt(peg$currPos) === 34) {
      r13 = "\"";
      peg$currPos += 1;
      break choice_4;
    } else {
      if (!silence) {peg$fail(peg$c108);}
      r13 = peg$FAILED;
    }
    p11 = peg$currPos;
    choice_5: {
    r13 = input.substr(peg$currPos,2);
    if (r13 === "!!") {
      peg$currPos += 2;
      break choice_5;
    } else {
      r13 = peg$FAILED;
    }
    r13 = input.charAt(peg$currPos);
    if (/^[|\r\n]/.test(r13)) {
      peg$currPos++;
    } else {
      r13 = peg$FAILED;
    }
    } // choice_5
    if (r13!== peg$FAILED) {
      r13 = void 0;
      peg$currPos = p11;
    }
    // free p11
    } // choice_4
    // q <- r13
    if (r13!== peg$FAILED) {
      r13 = input.substring(p7,peg$currPos);
    } else {
      r13 = peg$FAILED;
    }
    // free p7
    r4 = r13;
    if (r4 === peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_3;
    }
    r1 = true;
    } // seq_3
    if (r1!== peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$c107(r10,r12,r13);
      break choice_1;
    }
    // free r4,p6
    p6 = peg$currPos;
    seq_5: {
    p7 = peg$currPos;
    p11 = peg$currPos;
    r15 = peg$discardspace(silence);
    while (r15 !== peg$FAILED) {
      r15 = peg$discardspace(silence);
    }
    // free r15
    r14 = true;
    // s <- r14
    if (r14!== peg$FAILED) {
      r14 = input.substring(p11,peg$currPos);
    } else {
      r14 = peg$FAILED;
    }
    // free p11
    r4 = r14;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_5;
    }
    r15 = peg$parsetable_attribute_preprocessor_text(silence);
    // t <- r15
    r4 = r15;
    if (r4 === peg$FAILED) {
      peg$currPos = p7;
      r1 = peg$FAILED;
      break seq_5;
    }
    p11 = peg$currPos;
    choice_6: {
    r4 = peg$discardspace_or_newline(true);
    if (r4!== peg$FAILED) {
      break choice_6;
    }
    r4 = peg$discardeof(true);
    if (r4!== peg$FAILED) {
      break choice_6;
    }
    r4 = input.substr(peg$currPos,2);
    if (r4 === "!!") {
      peg$currPos += 2;
      break choice_6;
    } else {
      r4 = peg$FAILED;
    }
    if (input.charCodeAt(peg$currPos) === 124) {
      r4 = "|";
      peg$currPos += 1;
    } else {
      r4 = peg$FAILED;
    }
    } // choice_6
    if (r4!== peg$FAILED) {
      r4 = void 0;
      peg$currPos = p11;
    } else {
      peg$currPos = p7;
      r1 = peg$FAILED;
      break seq_5;
    }
    // free p11
    r1 = true;
    } // seq_5
    if (r1!== peg$FAILED) {
      peg$savedPos = p6;
      r1 = peg$c109(r14,r15);
    }
    // free r4,p7
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardspace_or_newline_or_solidus(silence) {
    var r1,p2,p3,r4,r5,p6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*69).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$discardspace_or_newline(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    // s <- r5
    if (input.charCodeAt(peg$currPos) === 47) {
      r5 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r5 = peg$FAILED;
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 62) {
      r4 = ">";
      peg$currPos += 1;
    } else {
      r4 = peg$FAILED;
    }
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p6;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c86(r5);
    }
    // free r4,p3
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsegeneric_attribute_name(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,p11,r12,p13,r14,p15,r16,p17,r18,p19,r20;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*75).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = input.charAt(peg$currPos);
    if (/^["'=]/.test(r5)) {
      peg$currPos++;
    } else {
      r5 = peg$FAILED;
      if (!silence) {peg$fail(peg$c99);}
      r5 = null;
    }
    // q <- r5
    r5 = input.substring(p6,peg$currPos);
    // free p6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    choice_1: {
    p6 = peg$currPos;
    r9 = input.charAt(peg$currPos);
    if (/^[^ \t\r\n\0\/=><&{}\-!|]/.test(r9)) {
      peg$currPos++;
      r8 = true;
      while (r9 !== peg$FAILED) {
        r9 = input.charAt(peg$currPos);
        if (/^[^ \t\r\n\0\/=><&{}\-!|]/.test(r9)) {
          peg$currPos++;
        } else {
          r9 = peg$FAILED;
          if (!silence) {peg$fail(peg$c111);}
        }
      }
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c111);}
      r8 = peg$FAILED;
    }
    if (r8!== peg$FAILED) {
      r8 = input.substring(p6,peg$currPos);
      break choice_1;
    } else {
      r8 = peg$FAILED;
    }
    // free r9
    // free p6
    p6 = peg$currPos;
    seq_2: {
    p10 = peg$currPos;
    p11 = peg$currPos;
    r9 = peg$discardinline_breaks(true);
    if (r9 === peg$FAILED) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p11;
      r8 = peg$FAILED;
      break seq_2;
    }
    // free p11
    choice_2: {
    r12 = peg$parsedirective(silence);
    if (r12!== peg$FAILED) {
      break choice_2;
    }
    r12 = peg$parseless_than(silence);
    if (r12!== peg$FAILED) {
      break choice_2;
    }
    p11 = peg$currPos;
    seq_3: {
    p13 = peg$currPos;
    p15 = peg$currPos;
    choice_3: {
    r14 = peg$discardspace_or_newline(true);
    if (r14!== peg$FAILED) {
      break choice_3;
    }
    r14 = input.charAt(peg$currPos);
    if (/^[\0\/=><]/.test(r14)) {
      peg$currPos++;
    } else {
      r14 = peg$FAILED;
    }
    } // choice_3
    if (r14 === peg$FAILED) {
      r14 = void 0;
    } else {
      r14 = peg$FAILED;
      peg$currPos = p15;
      r12 = peg$FAILED;
      break seq_3;
    }
    // free p15
    // c <- r16
    if (peg$currPos < input.length) {
      r16 = input.charAt(peg$currPos++);
    } else {
      r16 = peg$FAILED;
      if (!silence) {peg$fail(peg$c39);}
    }
    r14 = r16;
    if (r14 === peg$FAILED) {
      peg$currPos = p13;
      r12 = peg$FAILED;
      break seq_3;
    }
    r12 = true;
    } // seq_3
    if (r12!== peg$FAILED) {
      peg$savedPos = p11;
      r12 = peg$c102(r5,r7,r12,r16);
    }
    // free r14,p13
    } // choice_2
    // t <- r12
    r9 = r12;
    if (r9 === peg$FAILED) {
      peg$currPos = p10;
      r8 = peg$FAILED;
      break seq_2;
    }
    r8 = true;
    } // seq_2
    if (r8!== peg$FAILED) {
      peg$savedPos = p6;
      r8 = peg$c103(r5,r7,r12);
    }
    // free r9,p10
    } // choice_1
    while (r8 !== peg$FAILED) {
      r7.push(r8);
      choice_4: {
      p10 = peg$currPos;
      r9 = input.charAt(peg$currPos);
      if (/^[^ \t\r\n\0\/=><&{}\-!|]/.test(r9)) {
        peg$currPos++;
        r8 = true;
        while (r9 !== peg$FAILED) {
          r9 = input.charAt(peg$currPos);
          if (/^[^ \t\r\n\0\/=><&{}\-!|]/.test(r9)) {
            peg$currPos++;
          } else {
            r9 = peg$FAILED;
            if (!silence) {peg$fail(peg$c111);}
          }
        }
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c111);}
        r8 = peg$FAILED;
      }
      if (r8!== peg$FAILED) {
        r8 = input.substring(p10,peg$currPos);
        break choice_4;
      } else {
        r8 = peg$FAILED;
      }
      // free r9
      // free p10
      p10 = peg$currPos;
      seq_4: {
      p13 = peg$currPos;
      p15 = peg$currPos;
      r9 = peg$discardinline_breaks(true);
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p15;
        r8 = peg$FAILED;
        break seq_4;
      }
      // free p15
      choice_5: {
      r14 = peg$parsedirective(silence);
      if (r14!== peg$FAILED) {
        break choice_5;
      }
      r14 = peg$parseless_than(silence);
      if (r14!== peg$FAILED) {
        break choice_5;
      }
      p15 = peg$currPos;
      seq_5: {
      p17 = peg$currPos;
      p19 = peg$currPos;
      choice_6: {
      r18 = peg$discardspace_or_newline(true);
      if (r18!== peg$FAILED) {
        break choice_6;
      }
      r18 = input.charAt(peg$currPos);
      if (/^[\0\/=><]/.test(r18)) {
        peg$currPos++;
      } else {
        r18 = peg$FAILED;
      }
      } // choice_6
      if (r18 === peg$FAILED) {
        r18 = void 0;
      } else {
        r18 = peg$FAILED;
        peg$currPos = p19;
        r14 = peg$FAILED;
        break seq_5;
      }
      // free p19
      // c <- r20
      if (peg$currPos < input.length) {
        r20 = input.charAt(peg$currPos++);
      } else {
        r20 = peg$FAILED;
        if (!silence) {peg$fail(peg$c39);}
      }
      r18 = r20;
      if (r18 === peg$FAILED) {
        peg$currPos = p17;
        r14 = peg$FAILED;
        break seq_5;
      }
      r14 = true;
      } // seq_5
      if (r14!== peg$FAILED) {
        peg$savedPos = p15;
        r14 = peg$c102(r5,r7,r14,r20);
      }
      // free r18,p17
      } // choice_5
      // t <- r14
      r9 = r14;
      if (r9 === peg$FAILED) {
        peg$currPos = p13;
        r8 = peg$FAILED;
        break seq_4;
      }
      r8 = true;
      } // seq_4
      if (r8!== peg$FAILED) {
        peg$savedPos = p10;
        r8 = peg$c103(r5,r7,r14);
      }
      // free r9,p13
      } // choice_4
    }
    // r <- r7
    // free r8
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c104(r5,r7);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c105(r5,r7);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardspace_or_newline(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*105).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \t\n\r\f]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c112);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsegeneric_att_value(silence) {
    var r1,p2,p3,r4,r5,p6,p7,r8,r9,p10,r11,r12,r13,p14,r15,r16,r17;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*78).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    r9 = peg$discardspace_or_newline(silence);
    while (r9 !== peg$FAILED) {
      r9 = peg$discardspace_or_newline(silence);
    }
    // free r9
    r8 = true;
    if (r8 === peg$FAILED) {
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 39) {
      r8 = "'";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c106);}
      r8 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    // s <- r5
    if (r5!== peg$FAILED) {
      r5 = input.substring(p6,peg$currPos);
    } else {
      r5 = peg$FAILED;
    }
    // free r8,p7
    // free p6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parseattribute_preprocessor_text_single(silence);
    if (r8 === peg$FAILED) {
      r8 = null;
    }
    // t <- r8
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    choice_2: {
    if (input.charCodeAt(peg$currPos) === 39) {
      r9 = "'";
      peg$currPos += 1;
      break choice_2;
    } else {
      if (!silence) {peg$fail(peg$c106);}
      r9 = peg$FAILED;
    }
    p7 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r11 = "/";
      peg$currPos += 1;
    } else {
      r11 = peg$FAILED;
      r11 = null;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r11 = ">";
      peg$currPos += 1;
    } else {
      r11 = peg$FAILED;
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    r9 = true;
    } // seq_3
    if (r9!== peg$FAILED) {
      r9 = void 0;
      peg$currPos = p7;
    }
    // free r11,p10
    // free p7
    } // choice_2
    // q <- r9
    if (r9!== peg$FAILED) {
      r9 = input.substring(p6,peg$currPos);
    } else {
      r9 = peg$FAILED;
    }
    // free p6
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c107(r5,r8,r9);
      break choice_1;
    }
    // free r4,p3
    p3 = peg$currPos;
    seq_4: {
    p6 = peg$currPos;
    p7 = peg$currPos;
    seq_5: {
    p10 = peg$currPos;
    r13 = peg$discardspace_or_newline(silence);
    while (r13 !== peg$FAILED) {
      r13 = peg$discardspace_or_newline(silence);
    }
    // free r13
    r12 = true;
    if (r12 === peg$FAILED) {
      r11 = peg$FAILED;
      break seq_5;
    }
    if (input.charCodeAt(peg$currPos) === 34) {
      r12 = "\"";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c108);}
      r12 = peg$FAILED;
      peg$currPos = p10;
      r11 = peg$FAILED;
      break seq_5;
    }
    r11 = true;
    } // seq_5
    // s <- r11
    if (r11!== peg$FAILED) {
      r11 = input.substring(p7,peg$currPos);
    } else {
      r11 = peg$FAILED;
    }
    // free r12,p10
    // free p7
    r4 = r11;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_4;
    }
    r12 = peg$parseattribute_preprocessor_text_double(silence);
    if (r12 === peg$FAILED) {
      r12 = null;
    }
    // t <- r12
    r4 = r12;
    if (r4 === peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_4;
    }
    p7 = peg$currPos;
    choice_3: {
    if (input.charCodeAt(peg$currPos) === 34) {
      r13 = "\"";
      peg$currPos += 1;
      break choice_3;
    } else {
      if (!silence) {peg$fail(peg$c108);}
      r13 = peg$FAILED;
    }
    p10 = peg$currPos;
    seq_6: {
    p14 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r15 = "/";
      peg$currPos += 1;
    } else {
      r15 = peg$FAILED;
      r15 = null;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r15 = ">";
      peg$currPos += 1;
    } else {
      r15 = peg$FAILED;
      peg$currPos = p14;
      r13 = peg$FAILED;
      break seq_6;
    }
    r13 = true;
    } // seq_6
    if (r13!== peg$FAILED) {
      r13 = void 0;
      peg$currPos = p10;
    }
    // free r15,p14
    // free p10
    } // choice_3
    // q <- r13
    if (r13!== peg$FAILED) {
      r13 = input.substring(p7,peg$currPos);
    } else {
      r13 = peg$FAILED;
    }
    // free p7
    r4 = r13;
    if (r4 === peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_4;
    }
    r1 = true;
    } // seq_4
    if (r1!== peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$c107(r11,r12,r13);
      break choice_1;
    }
    // free r4,p6
    p6 = peg$currPos;
    seq_7: {
    p7 = peg$currPos;
    p10 = peg$currPos;
    r16 = peg$discardspace_or_newline(silence);
    while (r16 !== peg$FAILED) {
      r16 = peg$discardspace_or_newline(silence);
    }
    // free r16
    r15 = true;
    // s <- r15
    if (r15!== peg$FAILED) {
      r15 = input.substring(p10,peg$currPos);
    } else {
      r15 = peg$FAILED;
    }
    // free p10
    r4 = r15;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_7;
    }
    r16 = peg$parseattribute_preprocessor_text(silence);
    // t <- r16
    r4 = r16;
    if (r4 === peg$FAILED) {
      peg$currPos = p7;
      r1 = peg$FAILED;
      break seq_7;
    }
    p10 = peg$currPos;
    choice_4: {
    r4 = peg$discardspace_or_newline(true);
    if (r4!== peg$FAILED) {
      break choice_4;
    }
    r4 = peg$discardeof(true);
    if (r4!== peg$FAILED) {
      break choice_4;
    }
    seq_8: {
    p14 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r17 = "/";
      peg$currPos += 1;
    } else {
      r17 = peg$FAILED;
      r17 = null;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r17 = ">";
      peg$currPos += 1;
    } else {
      r17 = peg$FAILED;
      peg$currPos = p14;
      r4 = peg$FAILED;
      break seq_8;
    }
    r4 = true;
    } // seq_8
    // free r17,p14
    } // choice_4
    if (r4!== peg$FAILED) {
      r4 = void 0;
      peg$currPos = p10;
    } else {
      peg$currPos = p7;
      r1 = peg$FAILED;
      break seq_7;
    }
    // free p10
    r1 = true;
    } // seq_7
    if (r1!== peg$FAILED) {
      peg$savedPos = p6;
      r1 = peg$c109(r15,r16);
    }
    // free r4,p7
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsedirective(silence) {
    var r1,p2,p3,r4,p5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*124).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$parsecomment(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseextension_tag(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsetplarg_or_template(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "-{") {
      peg$currPos += 2;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r6 = peg$parselang_variant_or_tpl(silence);
    // v <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c113(r6);
      break choice_1;
    }
    // free r4,p3
    p3 = peg$currPos;
    seq_2: {
    p5 = peg$currPos;
    p7 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      r4 = "&";
      peg$currPos += 1;
      r4 = void 0;
      peg$currPos = p7;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p7
    r8 = peg$parsehtmlentity(silence);
    // e <- r8
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = true;
    } // seq_2
    if (r1!== peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$c114(r8);
      break choice_1;
    }
    // free r4,p5
    r1 = peg$parseinclude_limits(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardeolf(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*122).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$discardnewline(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardeof(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseurltext(silence) {
    var r1,r2,p3,r4,p5,p6,r7,p8,r9,p10,p11,r12,p13,r14,p15,r16,p17,p18,r19;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*99).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p3 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[^\-'<~[{\n\/A-Za-z_|!:;\]} &=]/.test(r4)) {
      peg$currPos++;
      r2 = true;
      while (r4 !== peg$FAILED) {
        r4 = input.charAt(peg$currPos);
        if (/^[^\-'<~[{\n\/A-Za-z_|!:;\]} &=]/.test(r4)) {
          peg$currPos++;
        } else {
          r4 = peg$FAILED;
          if (!silence) {peg$fail(peg$c115);}
        }
      }
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c115);}
      r2 = peg$FAILED;
    }
    if (r2!== peg$FAILED) {
      r2 = input.substring(p3,peg$currPos);
      break choice_1;
    } else {
      r2 = peg$FAILED;
    }
    // free r4
    // free p3
    p3 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    p6 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[\/A-Za-z]/.test(r4)) {
      peg$currPos++;
      r4 = void 0;
      peg$currPos = p6;
    } else {
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r7 = peg$parseautolink(silence);
    // al <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p5;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      peg$savedPos = p3;
      r2 = peg$c116(r7);
      break choice_1;
    }
    // free r4,p5
    p5 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    p8 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      r4 = "&";
      peg$currPos += 1;
      r4 = void 0;
      peg$currPos = p8;
    } else {
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_2;
    }
    // free p8
    r9 = peg$parsehtmlentity(silence);
    // he <- r9
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p6;
      r2 = peg$FAILED;
      break seq_2;
    }
    r2 = true;
    } // seq_2
    if (r2!== peg$FAILED) {
      peg$savedPos = p5;
      r2 = peg$c117(r9);
      break choice_1;
    }
    // free r4,p6
    p6 = peg$currPos;
    seq_3: {
    p8 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 32) {
      r4 = " ";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c118);}
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_3;
    }
    p10 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 58) {
      r4 = ":";
      peg$currPos += 1;
      r4 = void 0;
      peg$currPos = p10;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p8;
      r2 = peg$FAILED;
      break seq_3;
    }
    // free p10
    r2 = true;
    } // seq_3
    if (r2!== peg$FAILED) {
      peg$savedPos = p6;
      r2 = peg$c119();
      break choice_1;
    }
    // free r4,p8
    p8 = peg$currPos;
    seq_4: {
    p10 = peg$currPos;
    p11 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "__") {
      peg$currPos += 2;
      r4 = void 0;
      peg$currPos = p11;
    } else {
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_4;
    }
    // free p11
    r12 = peg$parsebehavior_switch(silence);
    // bs <- r12
    r4 = r12;
    if (r4 === peg$FAILED) {
      peg$currPos = p10;
      r2 = peg$FAILED;
      break seq_4;
    }
    r2 = true;
    } // seq_4
    if (r2!== peg$FAILED) {
      peg$savedPos = p8;
      r2 = peg$c120(r12);
      break choice_1;
    }
    // free r4,p10
    r2 = peg$parsetext_char(silence);
    } // choice_1
    if (r2!== peg$FAILED) {
      r1 = [];
      while (r2 !== peg$FAILED) {
        r1.push(r2);
        choice_2: {
        p10 = peg$currPos;
        r4 = input.charAt(peg$currPos);
        if (/^[^\-'<~[{\n\/A-Za-z_|!:;\]} &=]/.test(r4)) {
          peg$currPos++;
          r2 = true;
          while (r4 !== peg$FAILED) {
            r4 = input.charAt(peg$currPos);
            if (/^[^\-'<~[{\n\/A-Za-z_|!:;\]} &=]/.test(r4)) {
              peg$currPos++;
            } else {
              r4 = peg$FAILED;
              if (!silence) {peg$fail(peg$c115);}
            }
          }
        } else {
          r4 = peg$FAILED;
          if (!silence) {peg$fail(peg$c115);}
          r2 = peg$FAILED;
        }
        if (r2!== peg$FAILED) {
          r2 = input.substring(p10,peg$currPos);
          break choice_2;
        } else {
          r2 = peg$FAILED;
        }
        // free r4
        // free p10
        p10 = peg$currPos;
        seq_5: {
        p11 = peg$currPos;
        p13 = peg$currPos;
        r4 = input.charAt(peg$currPos);
        if (/^[\/A-Za-z]/.test(r4)) {
          peg$currPos++;
          r4 = void 0;
          peg$currPos = p13;
        } else {
          r4 = peg$FAILED;
          r2 = peg$FAILED;
          break seq_5;
        }
        // free p13
        r14 = peg$parseautolink(silence);
        // al <- r14
        r4 = r14;
        if (r4 === peg$FAILED) {
          peg$currPos = p11;
          r2 = peg$FAILED;
          break seq_5;
        }
        r2 = true;
        } // seq_5
        if (r2!== peg$FAILED) {
          peg$savedPos = p10;
          r2 = peg$c116(r14);
          break choice_2;
        }
        // free r4,p11
        p11 = peg$currPos;
        seq_6: {
        p13 = peg$currPos;
        p15 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
          r4 = "&";
          peg$currPos += 1;
          r4 = void 0;
          peg$currPos = p15;
        } else {
          r4 = peg$FAILED;
          r2 = peg$FAILED;
          break seq_6;
        }
        // free p15
        r16 = peg$parsehtmlentity(silence);
        // he <- r16
        r4 = r16;
        if (r4 === peg$FAILED) {
          peg$currPos = p13;
          r2 = peg$FAILED;
          break seq_6;
        }
        r2 = true;
        } // seq_6
        if (r2!== peg$FAILED) {
          peg$savedPos = p11;
          r2 = peg$c117(r16);
          break choice_2;
        }
        // free r4,p13
        p13 = peg$currPos;
        seq_7: {
        p15 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 32) {
          r4 = " ";
          peg$currPos += 1;
        } else {
          if (!silence) {peg$fail(peg$c118);}
          r4 = peg$FAILED;
          r2 = peg$FAILED;
          break seq_7;
        }
        p17 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 58) {
          r4 = ":";
          peg$currPos += 1;
          r4 = void 0;
          peg$currPos = p17;
        } else {
          r4 = peg$FAILED;
          peg$currPos = p15;
          r2 = peg$FAILED;
          break seq_7;
        }
        // free p17
        r2 = true;
        } // seq_7
        if (r2!== peg$FAILED) {
          peg$savedPos = p13;
          r2 = peg$c119();
          break choice_2;
        }
        // free r4,p15
        p15 = peg$currPos;
        seq_8: {
        p17 = peg$currPos;
        p18 = peg$currPos;
        r4 = input.substr(peg$currPos,2);
        if (r4 === "__") {
          peg$currPos += 2;
          r4 = void 0;
          peg$currPos = p18;
        } else {
          r4 = peg$FAILED;
          r2 = peg$FAILED;
          break seq_8;
        }
        // free p18
        r19 = peg$parsebehavior_switch(silence);
        // bs <- r19
        r4 = r19;
        if (r4 === peg$FAILED) {
          peg$currPos = p17;
          r2 = peg$FAILED;
          break seq_8;
        }
        r2 = true;
        } // seq_8
        if (r2!== peg$FAILED) {
          peg$savedPos = p15;
          r2 = peg$c120(r19);
          break choice_2;
        }
        // free r4,p17
        r2 = peg$parsetext_char(silence);
        } // choice_2
      }
    } else {
      r1 = peg$FAILED;
    }
    // free r2
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseinline_element(silence) {
    var r1,p2,p3,r4,p5,r6,p7,r8,p9,r10,r11,p12,p13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*17).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    choice_2: {
    r6 = peg$parsexmlish_tag(silence);
    if (r6!== peg$FAILED) {
      break choice_2;
    }
    r6 = peg$parsecomment(silence);
    } // choice_2
    // r <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c32(r6);
      break choice_1;
    }
    // free r4,p3
    p3 = peg$currPos;
    seq_2: {
    p5 = peg$currPos;
    p7 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r4 = "{";
      peg$currPos += 1;
      r4 = void 0;
      peg$currPos = p7;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p7
    r8 = peg$parsetplarg_or_template(silence);
    // r <- r8
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = true;
    } // seq_2
    if (r1!== peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$c32(r8);
      break choice_1;
    }
    // free r4,p5
    p5 = peg$currPos;
    seq_3: {
    p7 = peg$currPos;
    p9 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "-{") {
      peg$currPos += 2;
      r4 = void 0;
      peg$currPos = p9;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_3;
    }
    // free p9
    r10 = peg$parselang_variant_or_tpl(silence);
    // r <- r10
    r4 = r10;
    if (r4 === peg$FAILED) {
      peg$currPos = p7;
      r1 = peg$FAILED;
      break seq_3;
    }
    r1 = true;
    } // seq_3
    if (r1!== peg$FAILED) {
      peg$savedPos = p5;
      r1 = peg$c32(r10);
      break choice_1;
    }
    // free r4,p7
    p7 = peg$currPos;
    seq_4: {
    p9 = peg$currPos;
    r11 = input.substr(peg$currPos,2);
    if (r11 === "[[") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c121);}
      r11 = peg$FAILED;
      r4 = peg$FAILED;
      break seq_4;
    }
    p12 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r11 = "[";
      peg$currPos += 1;
      r11 = void 0;
      peg$currPos = p12;
    } else {
      r11 = peg$FAILED;
      peg$currPos = p9;
      r4 = peg$FAILED;
      break seq_4;
    }
    // free p12
    r4 = true;
    } // seq_4
    if (r4!== peg$FAILED) {
      r1 = true;
      while (r4 !== peg$FAILED) {
        seq_5: {
        p9 = peg$currPos;
        r11 = input.substr(peg$currPos,2);
        if (r11 === "[[") {
          peg$currPos += 2;
        } else {
          if (!silence) {peg$fail(peg$c121);}
          r11 = peg$FAILED;
          r4 = peg$FAILED;
          break seq_5;
        }
        p12 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          r11 = "[";
          peg$currPos += 1;
          r11 = void 0;
          peg$currPos = p12;
        } else {
          r11 = peg$FAILED;
          peg$currPos = p9;
          r4 = peg$FAILED;
          break seq_5;
        }
        // free p12
        r4 = true;
        } // seq_5
        // free r11,p9
      }
    } else {
      r1 = peg$FAILED;
    }
    // free r11,p9
    if (r1!== peg$FAILED) {
      r1 = input.substring(p7,peg$currPos);
      break choice_1;
    } else {
      r1 = peg$FAILED;
    }
    // free r4
    // free p7
    p7 = peg$currPos;
    seq_6: {
    p9 = peg$currPos;
    p12 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r4 = "[";
      peg$currPos += 1;
      r4 = void 0;
      peg$currPos = p12;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_6;
    }
    // free p12
    choice_3: {
    r11 = peg$parsewikilink(silence);
    if (r11!== peg$FAILED) {
      break choice_3;
    }
    r11 = peg$parseextlink(silence);
    } // choice_3
    // r <- r11
    r4 = r11;
    if (r4 === peg$FAILED) {
      peg$currPos = p9;
      r1 = peg$FAILED;
      break seq_6;
    }
    r1 = true;
    } // seq_6
    if (r1!== peg$FAILED) {
      peg$savedPos = p7;
      r1 = peg$c32(r11);
      break choice_1;
    }
    // free r4,p9
    p9 = peg$currPos;
    seq_7: {
    p12 = peg$currPos;
    p13 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      r4 = "'";
      peg$currPos += 1;
      r4 = void 0;
      peg$currPos = p13;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_7;
    }
    // free p13
    r14 = peg$parsequote(silence);
    // r <- r14
    r4 = r14;
    if (r4 === peg$FAILED) {
      peg$currPos = p12;
      r1 = peg$FAILED;
      break seq_7;
    }
    r1 = true;
    } // seq_7
    if (r1!== peg$FAILED) {
      peg$savedPos = p9;
      r1 = peg$c32(r14);
    }
    // free r4,p12
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardsof(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*118).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    peg$savedPos = peg$currPos;
    r1 = peg$c122();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseredirect(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*1).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parseredirect_word(silence);
    // rw <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r8 = peg$discardspace_or_newline(silence);
    while (r8 !== peg$FAILED) {
      r8 = peg$discardspace_or_newline(silence);
    }
    // free r8
    r6 = true;
    // sp <- r6
    if (r6!== peg$FAILED) {
      r6 = input.substring(p7,peg$currPos);
    } else {
      r6 = peg$FAILED;
    }
    // free p7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    seq_2: {
    p9 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 58) {
      r10 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c48);}
      r10 = peg$FAILED;
      r8 = peg$FAILED;
      break seq_2;
    }
    r11 = peg$discardspace_or_newline(silence);
    while (r11 !== peg$FAILED) {
      r11 = peg$discardspace_or_newline(silence);
    }
    // free r11
    r10 = true;
    if (r10 === peg$FAILED) {
      peg$currPos = p9;
      r8 = peg$FAILED;
      break seq_2;
    }
    r8 = true;
    } // seq_2
    if (r8 === peg$FAILED) {
      r8 = null;
    }
    // free r10,p9
    // c <- r8
    r8 = input.substring(p7,peg$currPos);
    // free p7
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r10 = peg$parsewikilink(silence);
    // wl <- r10
    r4 = r10;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c123(r5,r6,r8,r10);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c124(r5,r6,r8,r10);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsecomment_or_includes(silence) {
    var r1,r2,p3,p4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*111).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = [];
    choice_1: {
    r2 = peg$parsecomment(silence);
    if (r2!== peg$FAILED) {
      break choice_1;
    }
    choice_2: {
    p3 = peg$currPos;
    seq_1: {
    p4 = peg$currPos;
    peg$savedPos = peg$currPos;
    r5 = peg$c125();
    if (r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parseinclude_limits(silence);
    // i <- r6
    r5 = r6;
    if (r5 === peg$FAILED) {
      peg$currPos = p4;
      r2 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r5 = peg$c126(r6);
    if (r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      peg$savedPos = p3;
      r2 = peg$c127(r6);
      break choice_2;
    }
    // free r5,p4
    peg$savedPos = peg$currPos;
    r2 = peg$c128();
    if (r2) {
      r2 = void 0;
    } else {
      r2 = peg$FAILED;
    }
    } // choice_2
    } // choice_1
    while (r2 !== peg$FAILED) {
      r1.push(r2);
      choice_3: {
      r2 = peg$parsecomment(silence);
      if (r2!== peg$FAILED) {
        break choice_3;
      }
      choice_4: {
      p4 = peg$currPos;
      seq_2: {
      p7 = peg$currPos;
      peg$savedPos = peg$currPos;
      r5 = peg$c125();
      if (r5) {
        r5 = void 0;
      } else {
        r5 = peg$FAILED;
        r2 = peg$FAILED;
        break seq_2;
      }
      r8 = peg$parseinclude_limits(silence);
      // i <- r8
      r5 = r8;
      if (r5 === peg$FAILED) {
        peg$currPos = p7;
        r2 = peg$FAILED;
        break seq_2;
      }
      peg$savedPos = peg$currPos;
      r5 = peg$c126(r8);
      if (r5) {
        r5 = void 0;
      } else {
        r5 = peg$FAILED;
        peg$currPos = p7;
        r2 = peg$FAILED;
        break seq_2;
      }
      r2 = true;
      } // seq_2
      if (r2!== peg$FAILED) {
        peg$savedPos = p4;
        r2 = peg$c127(r8);
        break choice_4;
      }
      // free r5,p7
      peg$savedPos = peg$currPos;
      r2 = peg$c128();
      if (r2) {
        r2 = void 0;
      } else {
        r2 = peg$FAILED;
      }
      } // choice_4
      } // choice_3
    }
    // free r2
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseblock_line(silence) {
    var r1,p2,p3,r4,r5,r6,p7,p8,r9,p10,r11,r12,r13,p14,p15,r16,r17,r18,p19,r20,r21;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*12).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$parseheading(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parselist_item(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsehr(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parseoptionalSpaceToken(silence);
    // st <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    p10 = peg$currPos;
    r9 = input.charAt(peg$currPos);
    if (/^[ <{}|!]/.test(r9)) {
      peg$currPos++;
      r9 = void 0;
      peg$currPos = p10;
    } else {
      r9 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free p10
    r11 = peg$parsetable_line(silence);
    // tl <- r11
    r9 = r11;
    if (r9 === peg$FAILED) {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c129(r5,r6,r11);
      break choice_2;
    }
    // free r9,p8
    p8 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    p14 = peg$currPos;
    seq_4: {
    p15 = peg$currPos;
    r17 = peg$parseblock_tag(silence);
    // bt <- r17
    r16 = r17;
    if (r16 === peg$FAILED) {
      r13 = peg$FAILED;
      break seq_4;
    }
    r18 = peg$parseoptionalSpaceToken(silence);
    // stl <- r18
    r16 = r18;
    if (r16 === peg$FAILED) {
      peg$currPos = p15;
      r13 = peg$FAILED;
      break seq_4;
    }
    r13 = true;
    } // seq_4
    if (r13!== peg$FAILED) {
      peg$savedPos = p14;
      r13 = peg$c130(r5,r6,r12,r17,r18);
      r12 = [];
      while (r13 !== peg$FAILED) {
        r12.push(r13);
        p15 = peg$currPos;
        seq_5: {
        p19 = peg$currPos;
        r20 = peg$parseblock_tag(silence);
        // bt <- r20
        r16 = r20;
        if (r16 === peg$FAILED) {
          r13 = peg$FAILED;
          break seq_5;
        }
        r21 = peg$parseoptionalSpaceToken(silence);
        // stl <- r21
        r16 = r21;
        if (r16 === peg$FAILED) {
          peg$currPos = p19;
          r13 = peg$FAILED;
          break seq_5;
        }
        r13 = true;
        } // seq_5
        if (r13!== peg$FAILED) {
          peg$savedPos = p15;
          r13 = peg$c130(r5,r6,r12,r20,r21);
        }
        // free r16,p19
      }
    } else {
      r12 = peg$FAILED;
    }
    // free r16,p15
    // bts <- r12
    // free r13
    r9 = r12;
    if (r9 === peg$FAILED) {
      r6 = peg$FAILED;
      break seq_3;
    }
    p19 = peg$currPos;
    r9 = peg$discardeolf(true);
    if (r9!== peg$FAILED) {
      r9 = void 0;
      peg$currPos = p19;
    } else {
      peg$currPos = p10;
      r6 = peg$FAILED;
      break seq_3;
    }
    // free p19
    r6 = true;
    } // seq_3
    if (r6!== peg$FAILED) {
      peg$savedPos = p8;
      r6 = peg$c131(r5,r6,r12);
    }
    // free r9,p10
    } // choice_2
    // r <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c132(r5,r6);
    }
    // free r4,p3
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseblock_lines(silence) {
    var r1,p2,p3,r4,r5,r6,p7,p8,r9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*10).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parsesol(silence);
    // s <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    r10 = peg$parseoptionalSpaceToken(silence);
    // os <- r10
    r9 = r10;
    if (r9 === peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    r11 = peg$parsesol(silence);
    // so <- r11
    r9 = r11;
    if (r9 === peg$FAILED) {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c133(r5,r6,r10,r11);
    } else {
      r6 = null;
    }
    // free r9,p8
    // s2 <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$parseblock_line(silence);
    // bl <- r9
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c134(r5,r6,r9);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseblock_tag(silence) {
    var r1,p2,p3,r4,r5,r6,p7,p8,r9,r10,r11,r12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*71).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c135();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c136);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r5 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r5 = peg$FAILED;
      r5 = null;
    }
    // end <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    r10 = peg$parsetag_name(silence);
    // tn <- r10
    r9 = r10;
    if (r9 === peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    peg$savedPos = peg$currPos;
    r9 = peg$c137(r5,r6,r10);
    if (r9) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    // name <- r6
    if (r6!== peg$FAILED) {
      r6 = input.substring(p7,peg$currPos);
    } else {
      r6 = peg$FAILED;
    }
    // free r9,p8
    // free p7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$parsegeneric_newline_attributes(silence);
    // attribs <- r9
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r11 = peg$discardspace_or_newline_or_solidus(silence);
    while (r11 !== peg$FAILED) {
      r11 = peg$discardspace_or_newline_or_solidus(silence);
    }
    // free r11
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r11 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r11 = peg$FAILED;
      r11 = null;
    }
    // selfclose <- r11
    r4 = r11;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r4 = ">";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c138);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c139(r5,r6,r9,r11);
      break choice_1;
    }
    // free r4,p3
    seq_3: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c136);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_3;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r12 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r12 = peg$FAILED;
      r12 = null;
    }
    r13 = peg$parsetag_name(silence);
    if (r13 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_3;
    }
    peg$savedPos = peg$currPos;
    r14 = peg$c140();
    if (r14) {
      r14 = void 0;
    } else {
      r14 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_3;
    }
    r1 = [r4,r12,r13,r14];
    } // seq_3
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    // free r4,r12,r13,r14,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c141();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseparagraph(silence) {
    var r1,p2,p3,r4,r5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*13).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parsesol(silence);
    // s1 <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parsesol(silence);
    // s2 <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parseinlineline(silence);
    // c <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c142(r5,r6,r7);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsesol(silence) {
    var p1,r2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*112).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    seq_1: {
    p1 = peg$currPos;
    choice_1: {
    r3 = peg$parseempty_line_with_comments(silence);
    if (r3!== peg$FAILED) {
      break choice_1;
    }
    r3 = peg$parsesol_prefix(silence);
    } // choice_1
    if (r3 === peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    r4 = peg$parsecomment_or_includes(silence);
    if (r4 === peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = [r3,r4];
    } // seq_1
    // free r2,r3,r4,p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$discardtplarg(silence) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*37).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = '';
    // stopLen <- r5
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c143(r5);
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r7 = peg$parsetplarg_preproc(silence);
    if (r7!== peg$FAILED) {
      break choice_1;
    }
    peg$savedPos = peg$currPos;
    r7 = peg$c144(r5,r7);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
    }
    } // choice_1
    // t <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c145(r5,r7);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetemplate(silence) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*34).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = '';
    // stopLen <- r5
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c143(r5);
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r7 = peg$parsetemplate_preproc(silence);
    if (r7!== peg$FAILED) {
      break choice_1;
    }
    peg$savedPos = peg$currPos;
    r7 = peg$c144(r5,r7);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
    }
    } // choice_1
    // t <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c145(r5,r7);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsebroken_template(silence) {
    var r1,p2,p3,r4,p5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*35).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "{{") {
      peg$currPos += 2;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    peg$savedPos = peg$currPos;
    r4 = peg$c146();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = input.substr(peg$currPos,2);
    // t <- r6
    if (r6 === "{{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c147);}
      r6 = peg$FAILED;
    }
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c56(r6);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetplarg(silence) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*37).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = '';
    // stopLen <- r5
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c143(r5);
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r7 = peg$parsetplarg_preproc(silence);
    if (r7!== peg$FAILED) {
      break choice_1;
    }
    peg$savedPos = peg$currPos;
    r7 = peg$c144(r5,r7);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
    }
    } // choice_1
    // t <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c145(r5,r7);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardwikilink(silence) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*58).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = '';
    // stopLen <- r5
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c148(r5);
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    r7 = peg$parsewikilink_preproc(silence);
    if (r7!== peg$FAILED) {
      break choice_2;
    }
    peg$savedPos = peg$currPos;
    r7 = peg$c149(r5,r7);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
    }
    } // choice_2
    // w <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c150(r5,r7);
      break choice_1;
    }
    // free r4,p3
    r1 = peg$discardbroken_wikilink(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardxmlish_tag(silence) {
    var r1,p2,p3,r4,r5,r6,p7,p8,r9,r10,r11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*70).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c135();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c136);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r5 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r5 = peg$FAILED;
      r5 = null;
    }
    // end <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    r10 = peg$parsetag_name(silence);
    // tn <- r10
    r9 = r10;
    if (r9 === peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    peg$savedPos = peg$currPos;
    r9 = peg$c151(r5,r6,r10);
    if (r9) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    // name <- r6
    if (r6!== peg$FAILED) {
      r6 = input.substring(p7,peg$currPos);
    } else {
      r6 = peg$FAILED;
    }
    // free r9,p8
    // free p7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$parsegeneric_newline_attributes(silence);
    // attribs <- r9
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r11 = peg$discardspace_or_newline_or_solidus(silence);
    while (r11 !== peg$FAILED) {
      r11 = peg$discardspace_or_newline_or_solidus(silence);
    }
    // free r11
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r11 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r11 = peg$FAILED;
      r11 = null;
    }
    // selfclose <- r11
    r4 = r11;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r12 = peg$discardspace(silence);
    while (r12 !== peg$FAILED) {
      r12 = peg$discardspace(silence);
    }
    // free r12
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r4 = ">";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c138);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c152(r5,r6,r9,r11);
      break choice_1;
    }
    // free r4,p3
    seq_3: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c136);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_3;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r4 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r4 = peg$FAILED;
      r4 = null;
    }
    r4 = peg$discardtag_name(silence);
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_3;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c140();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_3;
    }
    r1 = true;
    } // seq_3
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c141();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_attribute_preprocessor_text_single(silence) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,p10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*131).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    r3 = [];
    choice_1: {
    p5 = peg$currPos;
    r6 = input.charAt(peg$currPos);
    if (/^[^{}&<\-!['\r\n|]/.test(r6)) {
      peg$currPos++;
      r4 = true;
      while (r6 !== peg$FAILED) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-!['\r\n|]/.test(r6)) {
          peg$currPos++;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c153);}
        }
      }
    } else {
      r6 = peg$FAILED;
      if (!silence) {peg$fail(peg$c153);}
      r4 = peg$FAILED;
    }
    if (r4!== peg$FAILED) {
      r4 = input.substring(p5,peg$currPos);
      break choice_1;
    } else {
      r4 = peg$FAILED;
    }
    // free r6
    // free p5
    p5 = peg$currPos;
    seq_1: {
    p7 = peg$currPos;
    p8 = peg$currPos;
    r6 = peg$discardinline_breaks(true);
    if (r6 === peg$FAILED) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p8;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p8
    choice_2: {
    r9 = peg$parsedirective(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[{}&<\-![]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c154);}
    }
    } // choice_2
    // s <- r9
    r6 = r9;
    if (r6 === peg$FAILED) {
      peg$currPos = p7;
      r4 = peg$FAILED;
      break seq_1;
    }
    r4 = true;
    } // seq_1
    if (r4!== peg$FAILED) {
      peg$savedPos = p5;
      r4 = peg$c73(r3,r9);
    }
    // free r6,p7
    } // choice_1
    while (r4 !== peg$FAILED) {
      r3.push(r4);
      choice_3: {
      p7 = peg$currPos;
      r6 = input.charAt(peg$currPos);
      if (/^[^{}&<\-!['\r\n|]/.test(r6)) {
        peg$currPos++;
        r4 = true;
        while (r6 !== peg$FAILED) {
          r6 = input.charAt(peg$currPos);
          if (/^[^{}&<\-!['\r\n|]/.test(r6)) {
            peg$currPos++;
          } else {
            r6 = peg$FAILED;
            if (!silence) {peg$fail(peg$c153);}
          }
        }
      } else {
        r6 = peg$FAILED;
        if (!silence) {peg$fail(peg$c153);}
        r4 = peg$FAILED;
      }
      if (r4!== peg$FAILED) {
        r4 = input.substring(p7,peg$currPos);
        break choice_3;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p7
      p7 = peg$currPos;
      seq_2: {
      p8 = peg$currPos;
      p10 = peg$currPos;
      r6 = peg$discardinline_breaks(true);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p10;
        r4 = peg$FAILED;
        break seq_2;
      }
      // free p10
      choice_4: {
      r11 = peg$parsedirective(silence);
      if (r11!== peg$FAILED) {
        break choice_4;
      }
      r11 = input.charAt(peg$currPos);
      if (/^[{}&<\-![]/.test(r11)) {
        peg$currPos++;
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c154);}
      }
      } // choice_4
      // s <- r11
      r6 = r11;
      if (r6 === peg$FAILED) {
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_2;
      }
      r4 = true;
      } // seq_2
      if (r4!== peg$FAILED) {
        peg$savedPos = p7;
        r4 = peg$c73(r3,r11);
      }
      // free r6,p8
      } // choice_3
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c155(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_attribute_preprocessor_text_double(silence) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,p10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*132).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    r3 = [];
    choice_1: {
    p5 = peg$currPos;
    r6 = input.charAt(peg$currPos);
    if (/^[^{}&<\-!["\r\n|]/.test(r6)) {
      peg$currPos++;
      r4 = true;
      while (r6 !== peg$FAILED) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-!["\r\n|]/.test(r6)) {
          peg$currPos++;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c156);}
        }
      }
    } else {
      r6 = peg$FAILED;
      if (!silence) {peg$fail(peg$c156);}
      r4 = peg$FAILED;
    }
    if (r4!== peg$FAILED) {
      r4 = input.substring(p5,peg$currPos);
      break choice_1;
    } else {
      r4 = peg$FAILED;
    }
    // free r6
    // free p5
    p5 = peg$currPos;
    seq_1: {
    p7 = peg$currPos;
    p8 = peg$currPos;
    r6 = peg$discardinline_breaks(true);
    if (r6 === peg$FAILED) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p8;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p8
    choice_2: {
    r9 = peg$parsedirective(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[{}&<\-![]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c154);}
    }
    } // choice_2
    // s <- r9
    r6 = r9;
    if (r6 === peg$FAILED) {
      peg$currPos = p7;
      r4 = peg$FAILED;
      break seq_1;
    }
    r4 = true;
    } // seq_1
    if (r4!== peg$FAILED) {
      peg$savedPos = p5;
      r4 = peg$c73(r3,r9);
    }
    // free r6,p7
    } // choice_1
    while (r4 !== peg$FAILED) {
      r3.push(r4);
      choice_3: {
      p7 = peg$currPos;
      r6 = input.charAt(peg$currPos);
      if (/^[^{}&<\-!["\r\n|]/.test(r6)) {
        peg$currPos++;
        r4 = true;
        while (r6 !== peg$FAILED) {
          r6 = input.charAt(peg$currPos);
          if (/^[^{}&<\-!["\r\n|]/.test(r6)) {
            peg$currPos++;
          } else {
            r6 = peg$FAILED;
            if (!silence) {peg$fail(peg$c156);}
          }
        }
      } else {
        r6 = peg$FAILED;
        if (!silence) {peg$fail(peg$c156);}
        r4 = peg$FAILED;
      }
      if (r4!== peg$FAILED) {
        r4 = input.substring(p7,peg$currPos);
        break choice_3;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p7
      p7 = peg$currPos;
      seq_2: {
      p8 = peg$currPos;
      p10 = peg$currPos;
      r6 = peg$discardinline_breaks(true);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p10;
        r4 = peg$FAILED;
        break seq_2;
      }
      // free p10
      choice_4: {
      r11 = peg$parsedirective(silence);
      if (r11!== peg$FAILED) {
        break choice_4;
      }
      r11 = input.charAt(peg$currPos);
      if (/^[{}&<\-![]/.test(r11)) {
        peg$currPos++;
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c154);}
      }
      } // choice_4
      // s <- r11
      r6 = r11;
      if (r6 === peg$FAILED) {
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_2;
      }
      r4 = true;
      } // seq_2
      if (r4!== peg$FAILED) {
        peg$savedPos = p7;
        r4 = peg$c73(r3,r11);
      }
      // free r6,p8
      } // choice_3
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c155(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_attribute_preprocessor_text(silence) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,p10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*130).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    choice_1: {
    p5 = peg$currPos;
    r6 = input.charAt(peg$currPos);
    if (/^[^{}&<\-![ \t\n\r\f|]/.test(r6)) {
      peg$currPos++;
      r4 = true;
      while (r6 !== peg$FAILED) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-![ \t\n\r\f|]/.test(r6)) {
          peg$currPos++;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c157);}
        }
      }
    } else {
      r6 = peg$FAILED;
      if (!silence) {peg$fail(peg$c157);}
      r4 = peg$FAILED;
    }
    if (r4!== peg$FAILED) {
      r4 = input.substring(p5,peg$currPos);
      break choice_1;
    } else {
      r4 = peg$FAILED;
    }
    // free r6
    // free p5
    p5 = peg$currPos;
    seq_1: {
    p7 = peg$currPos;
    p8 = peg$currPos;
    r6 = peg$discardinline_breaks(true);
    if (r6 === peg$FAILED) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p8;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p8
    choice_2: {
    r9 = peg$parsedirective(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[{}&<\-![]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c154);}
    }
    } // choice_2
    // s <- r9
    r6 = r9;
    if (r6 === peg$FAILED) {
      peg$currPos = p7;
      r4 = peg$FAILED;
      break seq_1;
    }
    r4 = true;
    } // seq_1
    if (r4!== peg$FAILED) {
      peg$savedPos = p5;
      r4 = peg$c73(r3,r9);
    }
    // free r6,p7
    } // choice_1
    if (r4!== peg$FAILED) {
      r3 = [];
      while (r4 !== peg$FAILED) {
        r3.push(r4);
        choice_3: {
        p7 = peg$currPos;
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-![ \t\n\r\f|]/.test(r6)) {
          peg$currPos++;
          r4 = true;
          while (r6 !== peg$FAILED) {
            r6 = input.charAt(peg$currPos);
            if (/^[^{}&<\-![ \t\n\r\f|]/.test(r6)) {
              peg$currPos++;
            } else {
              r6 = peg$FAILED;
              if (!silence) {peg$fail(peg$c157);}
            }
          }
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c157);}
          r4 = peg$FAILED;
        }
        if (r4!== peg$FAILED) {
          r4 = input.substring(p7,peg$currPos);
          break choice_3;
        } else {
          r4 = peg$FAILED;
        }
        // free r6
        // free p7
        p7 = peg$currPos;
        seq_2: {
        p8 = peg$currPos;
        p10 = peg$currPos;
        r6 = peg$discardinline_breaks(true);
        if (r6 === peg$FAILED) {
          r6 = void 0;
        } else {
          r6 = peg$FAILED;
          peg$currPos = p10;
          r4 = peg$FAILED;
          break seq_2;
        }
        // free p10
        choice_4: {
        r11 = peg$parsedirective(silence);
        if (r11!== peg$FAILED) {
          break choice_4;
        }
        r11 = input.charAt(peg$currPos);
        if (/^[{}&<\-![]/.test(r11)) {
          peg$currPos++;
        } else {
          r11 = peg$FAILED;
          if (!silence) {peg$fail(peg$c154);}
        }
        } // choice_4
        // s <- r11
        r6 = r11;
        if (r6 === peg$FAILED) {
          peg$currPos = p8;
          r4 = peg$FAILED;
          break seq_2;
        }
        r4 = true;
        } // seq_2
        if (r4!== peg$FAILED) {
          peg$savedPos = p7;
          r4 = peg$c73(r3,r11);
        }
        // free r6,p8
        } // choice_3
      }
    } else {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c155(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseless_than(silence) {
    var p1,r2,p3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*74).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c158();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c136);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      r2 = input.substring(p1,peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r4,p3
    // free p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$parseattribute_preprocessor_text_single(silence) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,p10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*128).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    r3 = [];
    choice_1: {
    p5 = peg$currPos;
    r6 = input.charAt(peg$currPos);
    if (/^[^{}&<\-|\/'>]/.test(r6)) {
      peg$currPos++;
      r4 = true;
      while (r6 !== peg$FAILED) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-|\/'>]/.test(r6)) {
          peg$currPos++;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c159);}
        }
      }
    } else {
      r6 = peg$FAILED;
      if (!silence) {peg$fail(peg$c159);}
      r4 = peg$FAILED;
    }
    if (r4!== peg$FAILED) {
      r4 = input.substring(p5,peg$currPos);
      break choice_1;
    } else {
      r4 = peg$FAILED;
    }
    // free r6
    // free p5
    p5 = peg$currPos;
    seq_1: {
    p7 = peg$currPos;
    p8 = peg$currPos;
    r6 = peg$discardinline_breaks(true);
    if (r6 === peg$FAILED) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p8;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p8
    p8 = peg$currPos;
    r6 = input.substr(peg$currPos,2);
    if (r6 === "/>") {
      peg$currPos += 2;
    } else {
      r6 = peg$FAILED;
    }
    if (r6 === peg$FAILED) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p8;
      peg$currPos = p7;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p8
    choice_2: {
    r9 = peg$parsedirective(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = peg$parseless_than(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[{}&\-|\/]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c160);}
    }
    } // choice_2
    // s <- r9
    r6 = r9;
    if (r6 === peg$FAILED) {
      peg$currPos = p7;
      r4 = peg$FAILED;
      break seq_1;
    }
    r4 = true;
    } // seq_1
    if (r4!== peg$FAILED) {
      peg$savedPos = p5;
      r4 = peg$c73(r3,r9);
    }
    // free r6,p7
    } // choice_1
    while (r4 !== peg$FAILED) {
      r3.push(r4);
      choice_3: {
      p7 = peg$currPos;
      r6 = input.charAt(peg$currPos);
      if (/^[^{}&<\-|\/'>]/.test(r6)) {
        peg$currPos++;
        r4 = true;
        while (r6 !== peg$FAILED) {
          r6 = input.charAt(peg$currPos);
          if (/^[^{}&<\-|\/'>]/.test(r6)) {
            peg$currPos++;
          } else {
            r6 = peg$FAILED;
            if (!silence) {peg$fail(peg$c159);}
          }
        }
      } else {
        r6 = peg$FAILED;
        if (!silence) {peg$fail(peg$c159);}
        r4 = peg$FAILED;
      }
      if (r4!== peg$FAILED) {
        r4 = input.substring(p7,peg$currPos);
        break choice_3;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p7
      p7 = peg$currPos;
      seq_2: {
      p8 = peg$currPos;
      p10 = peg$currPos;
      r6 = peg$discardinline_breaks(true);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p10;
        r4 = peg$FAILED;
        break seq_2;
      }
      // free p10
      p10 = peg$currPos;
      r6 = input.substr(peg$currPos,2);
      if (r6 === "/>") {
        peg$currPos += 2;
      } else {
        r6 = peg$FAILED;
      }
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p10;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_2;
      }
      // free p10
      choice_4: {
      r11 = peg$parsedirective(silence);
      if (r11!== peg$FAILED) {
        break choice_4;
      }
      r11 = peg$parseless_than(silence);
      if (r11!== peg$FAILED) {
        break choice_4;
      }
      r11 = input.charAt(peg$currPos);
      if (/^[{}&\-|\/]/.test(r11)) {
        peg$currPos++;
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c160);}
      }
      } // choice_4
      // s <- r11
      r6 = r11;
      if (r6 === peg$FAILED) {
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_2;
      }
      r4 = true;
      } // seq_2
      if (r4!== peg$FAILED) {
        peg$savedPos = p7;
        r4 = peg$c73(r3,r11);
      }
      // free r6,p8
      } // choice_3
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c155(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseattribute_preprocessor_text_double(silence) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,p10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*129).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    r3 = [];
    choice_1: {
    p5 = peg$currPos;
    r6 = input.charAt(peg$currPos);
    if (/^[^{}&<\-|\/">]/.test(r6)) {
      peg$currPos++;
      r4 = true;
      while (r6 !== peg$FAILED) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-|\/">]/.test(r6)) {
          peg$currPos++;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c161);}
        }
      }
    } else {
      r6 = peg$FAILED;
      if (!silence) {peg$fail(peg$c161);}
      r4 = peg$FAILED;
    }
    if (r4!== peg$FAILED) {
      r4 = input.substring(p5,peg$currPos);
      break choice_1;
    } else {
      r4 = peg$FAILED;
    }
    // free r6
    // free p5
    p5 = peg$currPos;
    seq_1: {
    p7 = peg$currPos;
    p8 = peg$currPos;
    r6 = peg$discardinline_breaks(true);
    if (r6 === peg$FAILED) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p8;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p8
    p8 = peg$currPos;
    r6 = input.substr(peg$currPos,2);
    if (r6 === "/>") {
      peg$currPos += 2;
    } else {
      r6 = peg$FAILED;
    }
    if (r6 === peg$FAILED) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p8;
      peg$currPos = p7;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p8
    choice_2: {
    r9 = peg$parsedirective(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = peg$parseless_than(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[{}&\-|\/]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c160);}
    }
    } // choice_2
    // s <- r9
    r6 = r9;
    if (r6 === peg$FAILED) {
      peg$currPos = p7;
      r4 = peg$FAILED;
      break seq_1;
    }
    r4 = true;
    } // seq_1
    if (r4!== peg$FAILED) {
      peg$savedPos = p5;
      r4 = peg$c73(r3,r9);
    }
    // free r6,p7
    } // choice_1
    while (r4 !== peg$FAILED) {
      r3.push(r4);
      choice_3: {
      p7 = peg$currPos;
      r6 = input.charAt(peg$currPos);
      if (/^[^{}&<\-|\/">]/.test(r6)) {
        peg$currPos++;
        r4 = true;
        while (r6 !== peg$FAILED) {
          r6 = input.charAt(peg$currPos);
          if (/^[^{}&<\-|\/">]/.test(r6)) {
            peg$currPos++;
          } else {
            r6 = peg$FAILED;
            if (!silence) {peg$fail(peg$c161);}
          }
        }
      } else {
        r6 = peg$FAILED;
        if (!silence) {peg$fail(peg$c161);}
        r4 = peg$FAILED;
      }
      if (r4!== peg$FAILED) {
        r4 = input.substring(p7,peg$currPos);
        break choice_3;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p7
      p7 = peg$currPos;
      seq_2: {
      p8 = peg$currPos;
      p10 = peg$currPos;
      r6 = peg$discardinline_breaks(true);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p10;
        r4 = peg$FAILED;
        break seq_2;
      }
      // free p10
      p10 = peg$currPos;
      r6 = input.substr(peg$currPos,2);
      if (r6 === "/>") {
        peg$currPos += 2;
      } else {
        r6 = peg$FAILED;
      }
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p10;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_2;
      }
      // free p10
      choice_4: {
      r11 = peg$parsedirective(silence);
      if (r11!== peg$FAILED) {
        break choice_4;
      }
      r11 = peg$parseless_than(silence);
      if (r11!== peg$FAILED) {
        break choice_4;
      }
      r11 = input.charAt(peg$currPos);
      if (/^[{}&\-|\/]/.test(r11)) {
        peg$currPos++;
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c160);}
      }
      } // choice_4
      // s <- r11
      r6 = r11;
      if (r6 === peg$FAILED) {
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_2;
      }
      r4 = true;
      } // seq_2
      if (r4!== peg$FAILED) {
        peg$savedPos = p7;
        r4 = peg$c73(r3,r11);
      }
      // free r6,p8
      } // choice_3
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c155(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseattribute_preprocessor_text(silence) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,p10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*127).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    choice_1: {
    p5 = peg$currPos;
    r6 = input.charAt(peg$currPos);
    if (/^[^{}&<\-|\/ \t\n\r\f>]/.test(r6)) {
      peg$currPos++;
      r4 = true;
      while (r6 !== peg$FAILED) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-|\/ \t\n\r\f>]/.test(r6)) {
          peg$currPos++;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c162);}
        }
      }
    } else {
      r6 = peg$FAILED;
      if (!silence) {peg$fail(peg$c162);}
      r4 = peg$FAILED;
    }
    if (r4!== peg$FAILED) {
      r4 = input.substring(p5,peg$currPos);
      break choice_1;
    } else {
      r4 = peg$FAILED;
    }
    // free r6
    // free p5
    p5 = peg$currPos;
    seq_1: {
    p7 = peg$currPos;
    p8 = peg$currPos;
    r6 = peg$discardinline_breaks(true);
    if (r6 === peg$FAILED) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p8;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p8
    p8 = peg$currPos;
    r6 = input.substr(peg$currPos,2);
    if (r6 === "/>") {
      peg$currPos += 2;
    } else {
      r6 = peg$FAILED;
    }
    if (r6 === peg$FAILED) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p8;
      peg$currPos = p7;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p8
    choice_2: {
    r9 = peg$parsedirective(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = peg$parseless_than(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[{}&\-|\/]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c160);}
    }
    } // choice_2
    // s <- r9
    r6 = r9;
    if (r6 === peg$FAILED) {
      peg$currPos = p7;
      r4 = peg$FAILED;
      break seq_1;
    }
    r4 = true;
    } // seq_1
    if (r4!== peg$FAILED) {
      peg$savedPos = p5;
      r4 = peg$c73(r3,r9);
    }
    // free r6,p7
    } // choice_1
    if (r4!== peg$FAILED) {
      r3 = [];
      while (r4 !== peg$FAILED) {
        r3.push(r4);
        choice_3: {
        p7 = peg$currPos;
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-|\/ \t\n\r\f>]/.test(r6)) {
          peg$currPos++;
          r4 = true;
          while (r6 !== peg$FAILED) {
            r6 = input.charAt(peg$currPos);
            if (/^[^{}&<\-|\/ \t\n\r\f>]/.test(r6)) {
              peg$currPos++;
            } else {
              r6 = peg$FAILED;
              if (!silence) {peg$fail(peg$c162);}
            }
          }
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c162);}
          r4 = peg$FAILED;
        }
        if (r4!== peg$FAILED) {
          r4 = input.substring(p7,peg$currPos);
          break choice_3;
        } else {
          r4 = peg$FAILED;
        }
        // free r6
        // free p7
        p7 = peg$currPos;
        seq_2: {
        p8 = peg$currPos;
        p10 = peg$currPos;
        r6 = peg$discardinline_breaks(true);
        if (r6 === peg$FAILED) {
          r6 = void 0;
        } else {
          r6 = peg$FAILED;
          peg$currPos = p10;
          r4 = peg$FAILED;
          break seq_2;
        }
        // free p10
        p10 = peg$currPos;
        r6 = input.substr(peg$currPos,2);
        if (r6 === "/>") {
          peg$currPos += 2;
        } else {
          r6 = peg$FAILED;
        }
        if (r6 === peg$FAILED) {
          r6 = void 0;
        } else {
          r6 = peg$FAILED;
          peg$currPos = p10;
          peg$currPos = p8;
          r4 = peg$FAILED;
          break seq_2;
        }
        // free p10
        choice_4: {
        r11 = peg$parsedirective(silence);
        if (r11!== peg$FAILED) {
          break choice_4;
        }
        r11 = peg$parseless_than(silence);
        if (r11!== peg$FAILED) {
          break choice_4;
        }
        r11 = input.charAt(peg$currPos);
        if (/^[{}&\-|\/]/.test(r11)) {
          peg$currPos++;
        } else {
          r11 = peg$FAILED;
          if (!silence) {peg$fail(peg$c160);}
        }
        } // choice_4
        // s <- r11
        r6 = r11;
        if (r6 === peg$FAILED) {
          peg$currPos = p8;
          r4 = peg$FAILED;
          break seq_2;
        }
        r4 = true;
        } // seq_2
        if (r4!== peg$FAILED) {
          peg$savedPos = p7;
          r4 = peg$c73(r3,r11);
        }
        // free r6,p8
        } // choice_3
      }
    } else {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c155(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseextension_tag(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*63).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c163();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsexmlish_tag(silence);
    // extToken <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c164(r5);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c165(r5);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_or_tpl(silence) {
    var r1,p2,p3,r4,p5,p6,r7,p8,p9,r10,r11,p12,r13,r14,p15,r16,r17,p18;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*43).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    r7 = input.substr(peg$currPos,2);
    if (r7 === "-{") {
      peg$currPos += 2;
    } else {
      r7 = peg$FAILED;
      r4 = peg$FAILED;
      break seq_2;
    }
    p8 = peg$currPos;
    seq_3: {
    p9 = peg$currPos;
    r11 = input.substr(peg$currPos,3);
    if (r11 === "{{{") {
      peg$currPos += 3;
      r10 = true;
      while (r11 !== peg$FAILED) {
        r11 = input.substr(peg$currPos,3);
        if (r11 === "{{{") {
          peg$currPos += 3;
        } else {
          r11 = peg$FAILED;
        }
      }
    } else {
      r11 = peg$FAILED;
      r10 = peg$FAILED;
    }
    if (r10 === peg$FAILED) {
      r7 = peg$FAILED;
      break seq_3;
    }
    // free r11
    p12 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r10 = "{";
      peg$currPos += 1;
    } else {
      r10 = peg$FAILED;
    }
    if (r10 === peg$FAILED) {
      r10 = void 0;
    } else {
      r10 = peg$FAILED;
      peg$currPos = p12;
      peg$currPos = p9;
      r7 = peg$FAILED;
      break seq_3;
    }
    // free p12
    r7 = true;
    } // seq_3
    if (r7!== peg$FAILED) {
      r7 = void 0;
      peg$currPos = p8;
    } else {
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    // free r10,p9
    // free p8
    r7 = peg$discardtplarg(true);
    if (r7 === peg$FAILED) {
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    r4 = true;
    } // seq_2
    if (r4!== peg$FAILED) {
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r7,p6
    // free p5
    r7 = peg$parselang_variant(silence);
    // a <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c166(r7);
      break choice_1;
    }
    // free r4,p3
    p3 = peg$currPos;
    seq_4: {
    p5 = peg$currPos;
    p6 = peg$currPos;
    seq_5: {
    p8 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      r11 = "-";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c167);}
      r11 = peg$FAILED;
      r10 = peg$FAILED;
      break seq_5;
    }
    p9 = peg$currPos;
    seq_6: {
    p12 = peg$currPos;
    r14 = input.substr(peg$currPos,3);
    if (r14 === "{{{") {
      peg$currPos += 3;
      r13 = true;
      while (r14 !== peg$FAILED) {
        r14 = input.substr(peg$currPos,3);
        if (r14 === "{{{") {
          peg$currPos += 3;
        } else {
          r14 = peg$FAILED;
        }
      }
    } else {
      r14 = peg$FAILED;
      r13 = peg$FAILED;
    }
    if (r13 === peg$FAILED) {
      r11 = peg$FAILED;
      break seq_6;
    }
    // free r14
    p15 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r13 = "{";
      peg$currPos += 1;
    } else {
      r13 = peg$FAILED;
    }
    if (r13 === peg$FAILED) {
      r13 = void 0;
    } else {
      r13 = peg$FAILED;
      peg$currPos = p15;
      peg$currPos = p12;
      r11 = peg$FAILED;
      break seq_6;
    }
    // free p15
    r11 = true;
    } // seq_6
    if (r11!== peg$FAILED) {
      r11 = void 0;
      peg$currPos = p9;
    } else {
      peg$currPos = p8;
      r10 = peg$FAILED;
      break seq_5;
    }
    // free r13,p12
    // free p9
    r10 = true;
    } // seq_5
    // a <- r10
    if (r10!== peg$FAILED) {
      r10 = input.substring(p6,peg$currPos);
    } else {
      r10 = peg$FAILED;
    }
    // free r11,p8
    // free p6
    r4 = r10;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_4;
    }
    r11 = peg$parsetplarg(silence);
    // b <- r11
    r4 = r11;
    if (r4 === peg$FAILED) {
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_4;
    }
    r1 = true;
    } // seq_4
    if (r1!== peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$c168(r10,r11);
      break choice_1;
    }
    // free r4,p5
    p5 = peg$currPos;
    seq_7: {
    p6 = peg$currPos;
    p8 = peg$currPos;
    seq_8: {
    p9 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      r14 = "-";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c167);}
      r14 = peg$FAILED;
      r13 = peg$FAILED;
      break seq_8;
    }
    p12 = peg$currPos;
    seq_9: {
    p15 = peg$currPos;
    r16 = input.substr(peg$currPos,2);
    if (r16 === "{{") {
      peg$currPos += 2;
    } else {
      r16 = peg$FAILED;
      r14 = peg$FAILED;
      break seq_9;
    }
    r17 = input.substr(peg$currPos,3);
    if (r17 === "{{{") {
      peg$currPos += 3;
    } else {
      r17 = peg$FAILED;
    }
    while (r17 !== peg$FAILED) {
      r17 = input.substr(peg$currPos,3);
      if (r17 === "{{{") {
        peg$currPos += 3;
      } else {
        r17 = peg$FAILED;
      }
    }
    // free r17
    r16 = true;
    if (r16 === peg$FAILED) {
      peg$currPos = p15;
      r14 = peg$FAILED;
      break seq_9;
    }
    p18 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r16 = "{";
      peg$currPos += 1;
    } else {
      r16 = peg$FAILED;
    }
    if (r16 === peg$FAILED) {
      r16 = void 0;
    } else {
      r16 = peg$FAILED;
      peg$currPos = p18;
      peg$currPos = p15;
      r14 = peg$FAILED;
      break seq_9;
    }
    // free p18
    r14 = true;
    } // seq_9
    if (r14!== peg$FAILED) {
      r14 = void 0;
      peg$currPos = p12;
    } else {
      peg$currPos = p9;
      r13 = peg$FAILED;
      break seq_8;
    }
    // free r16,p15
    // free p12
    r13 = true;
    } // seq_8
    // a <- r13
    if (r13!== peg$FAILED) {
      r13 = input.substring(p8,peg$currPos);
    } else {
      r13 = peg$FAILED;
    }
    // free r14,p9
    // free p8
    r4 = r13;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_7;
    }
    r14 = peg$parsetemplate(silence);
    // b <- r14
    r4 = r14;
    if (r4 === peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_7;
    }
    r1 = true;
    } // seq_7
    if (r1!== peg$FAILED) {
      peg$savedPos = p5;
      r1 = peg$c168(r13,r14);
      break choice_1;
    }
    // free r4,p6
    p6 = peg$currPos;
    seq_10: {
    p8 = peg$currPos;
    p9 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "-{") {
      peg$currPos += 2;
      r4 = void 0;
      peg$currPos = p9;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_10;
    }
    // free p9
    r16 = peg$parselang_variant(silence);
    // a <- r16
    r4 = r16;
    if (r4 === peg$FAILED) {
      peg$currPos = p8;
      r1 = peg$FAILED;
      break seq_10;
    }
    r1 = true;
    } // seq_10
    if (r1!== peg$FAILED) {
      peg$savedPos = p6;
      r1 = peg$c166(r16);
    }
    // free r4,p8
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseinclude_limits(silence) {
    var r1,p2,p3,r4,p5,p6,r7,r8,p9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*117).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r7 = "<";
      peg$currPos += 1;
    } else {
      r7 = peg$FAILED;
      r4 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r7 = "/";
      peg$currPos += 1;
    } else {
      r7 = peg$FAILED;
      r7 = null;
    }
    p9 = peg$currPos;
    r10 = input.charAt(peg$currPos);
    if (/^[oyinclude]/i.test(r10)) {
      peg$currPos++;
      r8 = true;
      while (r10 !== peg$FAILED) {
        r10 = input.charAt(peg$currPos);
        if (/^[oyinclude]/i.test(r10)) {
          peg$currPos++;
        } else {
          r10 = peg$FAILED;
        }
      }
    } else {
      r10 = peg$FAILED;
      r8 = peg$FAILED;
    }
    // n <- r8
    if (r8!== peg$FAILED) {
      r8 = input.substring(p9,peg$currPos);
    } else {
      r8 = peg$FAILED;
    }
    // free r10
    // free p9
    r7 = r8;
    if (r7 === peg$FAILED) {
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    peg$savedPos = peg$currPos;
    r7 = peg$c169(r8);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    r4 = true;
    } // seq_2
    if (r4!== peg$FAILED) {
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r7,p6
    // free p5
    r7 = peg$parsexmlish_tag(silence);
    // il <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c170(r7);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c171(r7);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseautolink(silence) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*22).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c26();
    if (!r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c172();
    if (!r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    p6 = peg$currPos;
    r7 = peg$parseautourl(silence);
    // target <- r7
    r5 = r7;
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c173(r5,r7);
      break choice_1;
    }
    r5 = peg$parseautoref(silence);
    if (r5!== peg$FAILED) {
      break choice_1;
    }
    r5 = peg$parseisbn(silence);
    } // choice_1
    // r <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c32(r5);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsebehavior_switch(silence) {
    var r1,p2,r3,p4,p5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*20).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    r6 = input.substr(peg$currPos,2);
    if (r6 === "__") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c174);}
      r6 = peg$FAILED;
      r3 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$discardbehavior_text(silence);
    if (r6 === peg$FAILED) {
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r6 = input.substr(peg$currPos,2);
    if (r6 === "__") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c174);}
      r6 = peg$FAILED;
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    // bs <- r3
    if (r3!== peg$FAILED) {
      r3 = input.substring(p4,peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free r6,p5
    // free p4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c175(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetext_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*98).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[^\-'<~[{\n\r:;\]}|!=]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c176);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsexmlish_tag(silence) {
    var r1,p2,p3,r4,r5,r6,p7,p8,r9,r10,r11,r12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*70).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c135();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c136);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r5 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r5 = peg$FAILED;
      r5 = null;
    }
    // end <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    r10 = peg$parsetag_name(silence);
    // tn <- r10
    r9 = r10;
    if (r9 === peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    peg$savedPos = peg$currPos;
    r9 = peg$c151(r5,r6,r10);
    if (r9) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    // name <- r6
    if (r6!== peg$FAILED) {
      r6 = input.substring(p7,peg$currPos);
    } else {
      r6 = peg$FAILED;
    }
    // free r9,p8
    // free p7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$parsegeneric_newline_attributes(silence);
    // attribs <- r9
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r11 = peg$discardspace_or_newline_or_solidus(silence);
    while (r11 !== peg$FAILED) {
      r11 = peg$discardspace_or_newline_or_solidus(silence);
    }
    // free r11
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r11 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r11 = peg$FAILED;
      r11 = null;
    }
    // selfclose <- r11
    r4 = r11;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r12 = peg$discardspace(silence);
    while (r12 !== peg$FAILED) {
      r12 = peg$discardspace(silence);
    }
    // free r12
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r4 = ">";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c138);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c152(r5,r6,r9,r11);
      break choice_1;
    }
    // free r4,p3
    seq_3: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c136);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_3;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r12 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r12 = peg$FAILED;
      r12 = null;
    }
    r13 = peg$parsetag_name(silence);
    if (r13 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_3;
    }
    peg$savedPos = peg$currPos;
    r14 = peg$c140();
    if (r14) {
      r14 = void 0;
    } else {
      r14 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_3;
    }
    r1 = [r4,r12,r13,r14];
    } // seq_3
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    // free r4,r12,r13,r14,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c141();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsewikilink(silence) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*58).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = '';
    // stopLen <- r5
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c148(r5);
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    r7 = peg$parsewikilink_preproc(silence);
    if (r7!== peg$FAILED) {
      break choice_2;
    }
    peg$savedPos = peg$currPos;
    r7 = peg$c149(r5,r7);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
    }
    } // choice_2
    // w <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c150(r5,r7);
      break choice_1;
    }
    // free r4,p3
    r1 = peg$parsebroken_wikilink(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsequote(silence) {
    var r1,p2,r3,p4,p5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*62).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    r6 = input.substr(peg$currPos,2);
    if (r6 === "''") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c177);}
      r6 = peg$FAILED;
      r3 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 39) {
      r7 = "'";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c106);}
      r7 = peg$FAILED;
    }
    while (r7 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 39) {
        r7 = "'";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c106);}
        r7 = peg$FAILED;
      }
    }
    // free r7
    r6 = true;
    if (r6 === peg$FAILED) {
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    // quotes <- r3
    if (r3!== peg$FAILED) {
      r3 = input.substring(p4,peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free r6,p5
    // free p4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c178(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseredirect_word(silence) {
    var p1,r2,p3,r4,r5,p6,r7,p8,r9,p10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*4).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = input.charAt(peg$currPos);
    if (/^[ \t\n\r\0\x0B]/.test(r5)) {
      peg$currPos++;
    } else {
      r5 = peg$FAILED;
      if (!silence) {peg$fail(peg$c179);}
    }
    while (r5 !== peg$FAILED) {
      r5 = input.charAt(peg$currPos);
      if (/^[ \t\n\r\0\x0B]/.test(r5)) {
        peg$currPos++;
      } else {
        r5 = peg$FAILED;
        if (!silence) {peg$fail(peg$c179);}
      }
    }
    // free r5
    r4 = true;
    if (r4 === peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    p10 = peg$currPos;
    r9 = peg$discardspace_or_newline(true);
    if (r9 === peg$FAILED) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p10;
      r7 = peg$FAILED;
      break seq_2;
    }
    // free p10
    p10 = peg$currPos;
    r9 = input.charAt(peg$currPos);
    if (/^[:[]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
    }
    if (r9 === peg$FAILED) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p10;
      peg$currPos = p8;
      r7 = peg$FAILED;
      break seq_2;
    }
    // free p10
    if (peg$currPos < input.length) {
      r9 = input.charAt(peg$currPos++);
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c39);}
      peg$currPos = p8;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = true;
    } // seq_2
    if (r7!== peg$FAILED) {
      r5 = true;
      while (r7 !== peg$FAILED) {
        seq_3: {
        p8 = peg$currPos;
        p10 = peg$currPos;
        r9 = peg$discardspace_or_newline(true);
        if (r9 === peg$FAILED) {
          r9 = void 0;
        } else {
          r9 = peg$FAILED;
          peg$currPos = p10;
          r7 = peg$FAILED;
          break seq_3;
        }
        // free p10
        p10 = peg$currPos;
        r9 = input.charAt(peg$currPos);
        if (/^[:[]/.test(r9)) {
          peg$currPos++;
        } else {
          r9 = peg$FAILED;
        }
        if (r9 === peg$FAILED) {
          r9 = void 0;
        } else {
          r9 = peg$FAILED;
          peg$currPos = p10;
          peg$currPos = p8;
          r7 = peg$FAILED;
          break seq_3;
        }
        // free p10
        if (peg$currPos < input.length) {
          r9 = input.charAt(peg$currPos++);
        } else {
          r9 = peg$FAILED;
          if (!silence) {peg$fail(peg$c39);}
          peg$currPos = p8;
          r7 = peg$FAILED;
          break seq_3;
        }
        r7 = true;
        } // seq_3
        // free r9,p8
      }
    } else {
      r5 = peg$FAILED;
    }
    // free r9,p8
    // rw <- r5
    if (r5!== peg$FAILED) {
      r5 = input.substring(p6,peg$currPos);
    } else {
      r5 = peg$FAILED;
    }
    // free r7
    // free p6
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c180(r5);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      r2 = input.substring(p1,peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r4,p3
    // free p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$parseheading(silence) {
    var r1,p2,p3,r4,p5,r6,p7,r8,r9,p10,r11,r12,p13,r14,r15,p16,r17;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*18).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      r4 = "=";
      peg$currPos += 1;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    choice_1: {
    p5 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    peg$savedPos = peg$currPos;
    r8 = peg$c181(r6);
    if (r8) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_2;
    }
    p10 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      r11 = "=";
      peg$currPos += 1;
      r9 = true;
      while (r11 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          r11 = "=";
          peg$currPos += 1;
        } else {
          if (!silence) {peg$fail(peg$c60);}
          r11 = peg$FAILED;
        }
      }
    } else {
      if (!silence) {peg$fail(peg$c60);}
      r11 = peg$FAILED;
      r9 = peg$FAILED;
    }
    // s <- r9
    if (r9!== peg$FAILED) {
      r9 = input.substring(p10,peg$currPos);
    } else {
      r9 = peg$FAILED;
    }
    // free r11
    // free p10
    r8 = r9;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    seq_3: {
    p10 = peg$currPos;
    p13 = peg$currPos;
    r14 = peg$parseinlineline(silence);
    if (r14 === peg$FAILED) {
      r14 = null;
    }
    // ill <- r14
    r12 = r14;
    if (r12!== peg$FAILED) {
      peg$savedPos = p13;
      r12 = peg$c182(r6,r9,r11,r14);
    } else {
      r11 = peg$FAILED;
      break seq_3;
    }
    p16 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      r17 = "=";
      peg$currPos += 1;
      r15 = true;
      while (r17 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          r17 = "=";
          peg$currPos += 1;
        } else {
          if (!silence) {peg$fail(peg$c60);}
          r17 = peg$FAILED;
        }
      }
    } else {
      if (!silence) {peg$fail(peg$c60);}
      r17 = peg$FAILED;
      r15 = peg$FAILED;
    }
    if (r15!== peg$FAILED) {
      r15 = input.substring(p16,peg$currPos);
    } else {
      r15 = peg$FAILED;
      peg$currPos = p10;
      r11 = peg$FAILED;
      break seq_3;
    }
    // free r17
    // free p16
    r11 = [r12,r15];
    } // seq_3
    if (r11 === peg$FAILED) {
      r11 = null;
    }
    // free r12,r15,p10
    // ce <- r11
    r8 = r11;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    peg$savedPos = peg$currPos;
    r8 = peg$c183(r6,r9,r11);
    if (r8) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    p10 = peg$currPos;
    r15 = '';
    // endTPos <- r15
    if (r15!== peg$FAILED) {
      peg$savedPos = p10;
      r15 = peg$c184(r6,r9,r11,r15);
    }
    r8 = r15;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r12 = [];
    choice_2: {
    r17 = peg$parsespaces(silence);
    if (r17!== peg$FAILED) {
      break choice_2;
    }
    r17 = peg$parsecomment(silence);
    } // choice_2
    while (r17 !== peg$FAILED) {
      r12.push(r17);
      choice_3: {
      r17 = peg$parsespaces(silence);
      if (r17!== peg$FAILED) {
        break choice_3;
      }
      r17 = peg$parsecomment(silence);
      } // choice_3
    }
    // spc <- r12
    // free r17
    r8 = r12;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    p16 = peg$currPos;
    r8 = peg$discardeolf(true);
    if (r8!== peg$FAILED) {
      r8 = void 0;
      peg$currPos = p16;
    } else {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free p16
    r6 = true;
    } // seq_2
    if (r6!== peg$FAILED) {
      peg$savedPos = p5;
      r6 = peg$c185(r6,r9,r11,r15,r12);
      break choice_1;
    }
    // free r8,p7
    peg$savedPos = peg$currPos;
    r6 = peg$c186(r6);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
    }
    } // choice_1
    // r <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c32(r6);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselist_item(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*80).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$parsedtdd(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsehacky_dl_uses(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseli(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsehr(silence) {
    var r1,p2,p3,r4,r5,r6,p7,p8,r9,p10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*11).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "----") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c187);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = [];
    if (input.charCodeAt(peg$currPos) === 45) {
      r6 = "-";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c167);}
      r6 = peg$FAILED;
    }
    while (r6 !== peg$FAILED) {
      r5.push(r6);
      if (input.charCodeAt(peg$currPos) === 45) {
        r6 = "-";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c167);}
        r6 = peg$FAILED;
      }
    }
    // d <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    p10 = peg$currPos;
    r9 = peg$discardsol(true);
    if (r9!== peg$FAILED) {
      r9 = void 0;
      peg$currPos = p10;
    } else {
      r6 = peg$FAILED;
      break seq_2;
    }
    // free p10
    r9 = '';
    if (r9 === peg$FAILED) {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c188(r5,r6);
      break choice_1;
    }
    // free r9,p8
    p8 = peg$currPos;
    r6 = '';
    if (r6!== peg$FAILED) {
      peg$savedPos = p8;
      r6 = peg$c189(r5,r6);
    }
    } // choice_1
    // lineContent <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c190(r5,r6);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_line(silence) {
    var r1,p2,p3,r4,p5,r6,p7,r8,r9,p10,r11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*86).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    choice_1: {
    p5 = peg$currPos;
    r4 = peg$discardinline_breaks(true);
    if (r4 === peg$FAILED) {
      r4 = void 0;
      break choice_1;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
    }
    // free p5
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,5);
    if (r4 === "{{!}}") {
      peg$currPos += 5;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
    }
    // free p5
    } // choice_1
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    p5 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    peg$savedPos = peg$currPos;
    r8 = peg$c191(r6);
    if (r8) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_2;
    }
    choice_3: {
    seq_3: {
    p10 = peg$currPos;
    r11 = peg$parsetable_start_tag(silence);
    if (r11 === peg$FAILED) {
      r9 = peg$FAILED;
      break seq_3;
    }
    r12 = peg$parseoptionalNewlines(silence);
    if (r12 === peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    r9 = [r11,r12];
    } // seq_3
    if (r9!== peg$FAILED) {
      break choice_3;
    }
    // free r11,r12,p10
    seq_4: {
    p10 = peg$currPos;
    r12 = peg$parsetable_content_line(silence);
    if (r12 === peg$FAILED) {
      r9 = peg$FAILED;
      break seq_4;
    }
    r11 = peg$parseoptionalNewlines(silence);
    if (r11 === peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_4;
    }
    r9 = [r12,r11];
    } // seq_4
    if (r9!== peg$FAILED) {
      break choice_3;
    }
    // free r12,r11,p10
    r9 = peg$parsetable_end_tag(silence);
    } // choice_3
    // tl <- r9
    r8 = r9;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    if (r6!== peg$FAILED) {
      peg$savedPos = p5;
      r6 = peg$c192(r6,r9);
      break choice_2;
    }
    // free r8,p7
    peg$savedPos = peg$currPos;
    r6 = peg$c193(r6);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
    }
    } // choice_2
    // r <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c32(r6);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetag_name(silence) {
    var p1,r2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*68).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[A-Za-z]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c46);}
      r2 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$discardtag_name_chars(silence);
    while (r5 !== peg$FAILED) {
      r5 = peg$discardtag_name_chars(silence);
    }
    // free r5
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      r2 = input.substring(p1,peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r4,p3
    // free p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$parseempty_line_with_comments(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,p10,r11,r12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*114).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parsesol_prefix(silence);
    // sp <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r6 = '';
    // p <- r6
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c194(r5,r6);
    }
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p10 = peg$currPos;
    r11 = [];
    r12 = peg$parsespace(silence);
    while (r12 !== peg$FAILED) {
      r11.push(r12);
      r12 = peg$parsespace(silence);
    }
    // free r12
    r12 = peg$parsecomment(silence);
    if (r12 === peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_2;
    }
    r13 = [];
    choice_1: {
    r14 = peg$parsespace(silence);
    if (r14!== peg$FAILED) {
      break choice_1;
    }
    r14 = peg$parsecomment(silence);
    } // choice_1
    while (r14 !== peg$FAILED) {
      r13.push(r14);
      choice_2: {
      r14 = peg$parsespace(silence);
      if (r14!== peg$FAILED) {
        break choice_2;
      }
      r14 = peg$parsecomment(silence);
      } // choice_2
    }
    // free r14
    r14 = peg$parsenewline(silence);
    if (r14 === peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_2;
    }
    r9 = [r11,r12,r13,r14];
    } // seq_2
    if (r9!== peg$FAILED) {
      r8 = [];
      while (r9 !== peg$FAILED) {
        r8.push(r9);
        seq_3: {
        p10 = peg$currPos;
        r14 = [];
        r13 = peg$parsespace(silence);
        while (r13 !== peg$FAILED) {
          r14.push(r13);
          r13 = peg$parsespace(silence);
        }
        // free r13
        r13 = peg$parsecomment(silence);
        if (r13 === peg$FAILED) {
          peg$currPos = p10;
          r9 = peg$FAILED;
          break seq_3;
        }
        r12 = [];
        choice_3: {
        r11 = peg$parsespace(silence);
        if (r11!== peg$FAILED) {
          break choice_3;
        }
        r11 = peg$parsecomment(silence);
        } // choice_3
        while (r11 !== peg$FAILED) {
          r12.push(r11);
          choice_4: {
          r11 = peg$parsespace(silence);
          if (r11!== peg$FAILED) {
            break choice_4;
          }
          r11 = peg$parsecomment(silence);
          } // choice_4
        }
        // free r11
        r11 = peg$parsenewline(silence);
        if (r11 === peg$FAILED) {
          peg$currPos = p10;
          r9 = peg$FAILED;
          break seq_3;
        }
        r9 = [r14,r13,r12,r11];
        } // seq_3
        // free r14,r13,r12,r11,p10
      }
    } else {
      r8 = peg$FAILED;
    }
    // free r11,r12,r13,r14,p10
    // c <- r8
    // free r9
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c195(r5,r6,r8);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsesol_prefix(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*113).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$parsenewlineToken(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    peg$savedPos = peg$currPos;
    r1 = peg$c196();
    if (r1) {
      r1 = void 0;
      peg$savedPos = p2;
      r1 = peg$c197();
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetplarg_preproc(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,p11,r12,r13,p14,p15,r16,r17,p18,r19,r20,p21,p22,p23,r24,r25,p26,r27,r28,p29,p30;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*38).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,3);
    if (r4 === "{{{") {
      peg$currPos += 3;
    } else {
      if (!silence) {peg$fail(peg$c198);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // p <- r5
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c199(r5);
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsetemplate_param_value(silence);
    if (r7 === peg$FAILED) {
      r7 = null;
    }
    // target <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = [];
    p10 = peg$currPos;
    seq_2: {
    p11 = peg$currPos;
    r13 = peg$discardnl_comment_space(silence);
    while (r13 !== peg$FAILED) {
      r13 = peg$discardnl_comment_space(silence);
    }
    // free r13
    r12 = true;
    if (r12 === peg$FAILED) {
      r9 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 124) {
      r12 = "|";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r12 = peg$FAILED;
      peg$currPos = p11;
      r9 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    p14 = peg$currPos;
    seq_3: {
    p15 = peg$currPos;
    p18 = peg$currPos;
    r17 = '';
    // p0 <- r17
    if (r17!== peg$FAILED) {
      peg$savedPos = p18;
      r17 = peg$c200(r5,r7,r8,r13,r17);
    }
    r16 = r17;
    if (r16 === peg$FAILED) {
      r13 = peg$FAILED;
      break seq_3;
    }
    r19 = [];
    r20 = peg$parsenl_comment_space(silence);
    while (r20 !== peg$FAILED) {
      r19.push(r20);
      r20 = peg$parsenl_comment_space(silence);
    }
    // v <- r19
    // free r20
    r16 = r19;
    if (r16 === peg$FAILED) {
      peg$currPos = p15;
      r13 = peg$FAILED;
      break seq_3;
    }
    p21 = peg$currPos;
    r20 = '';
    // p1 <- r20
    if (r20!== peg$FAILED) {
      peg$savedPos = p21;
      r20 = peg$c201(r5,r7,r8,r13,r17,r19,r20);
    }
    r16 = r20;
    if (r16 === peg$FAILED) {
      peg$currPos = p15;
      r13 = peg$FAILED;
      break seq_3;
    }
    p22 = peg$currPos;
    choice_2: {
    if (input.charCodeAt(peg$currPos) === 124) {
      r16 = "|";
      peg$currPos += 1;
      break choice_2;
    } else {
      r16 = peg$FAILED;
    }
    r16 = input.substr(peg$currPos,3);
    if (r16 === "}}}") {
      peg$currPos += 3;
    } else {
      r16 = peg$FAILED;
    }
    } // choice_2
    if (r16!== peg$FAILED) {
      r16 = void 0;
      peg$currPos = p22;
    } else {
      peg$currPos = p15;
      r13 = peg$FAILED;
      break seq_3;
    }
    // free p22
    r13 = true;
    } // seq_3
    if (r13!== peg$FAILED) {
      peg$savedPos = p14;
      r13 = peg$c202(r5,r7,r8,r13,r17,r19,r20);
      break choice_1;
    }
    // free r16,p15
    r13 = peg$parsetemplate_param_value(silence);
    } // choice_1
    // r <- r13
    r12 = r13;
    if (r12 === peg$FAILED) {
      peg$currPos = p11;
      r9 = peg$FAILED;
      break seq_2;
    }
    r9 = true;
    } // seq_2
    if (r9!== peg$FAILED) {
      peg$savedPos = p10;
      r9 = peg$c203(r5,r7,r8,r13);
    }
    // free r12,p11
    while (r9 !== peg$FAILED) {
      r8.push(r9);
      p11 = peg$currPos;
      seq_4: {
      p15 = peg$currPos;
      r16 = peg$discardnl_comment_space(silence);
      while (r16 !== peg$FAILED) {
        r16 = peg$discardnl_comment_space(silence);
      }
      // free r16
      r12 = true;
      if (r12 === peg$FAILED) {
        r9 = peg$FAILED;
        break seq_4;
      }
      if (input.charCodeAt(peg$currPos) === 124) {
        r12 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c42);}
        r12 = peg$FAILED;
        peg$currPos = p15;
        r9 = peg$FAILED;
        break seq_4;
      }
      choice_3: {
      p22 = peg$currPos;
      seq_5: {
      p23 = peg$currPos;
      p26 = peg$currPos;
      r25 = '';
      // p0 <- r25
      if (r25!== peg$FAILED) {
        peg$savedPos = p26;
        r25 = peg$c200(r5,r7,r8,r16,r25);
      }
      r24 = r25;
      if (r24 === peg$FAILED) {
        r16 = peg$FAILED;
        break seq_5;
      }
      r27 = [];
      r28 = peg$parsenl_comment_space(silence);
      while (r28 !== peg$FAILED) {
        r27.push(r28);
        r28 = peg$parsenl_comment_space(silence);
      }
      // v <- r27
      // free r28
      r24 = r27;
      if (r24 === peg$FAILED) {
        peg$currPos = p23;
        r16 = peg$FAILED;
        break seq_5;
      }
      p29 = peg$currPos;
      r28 = '';
      // p1 <- r28
      if (r28!== peg$FAILED) {
        peg$savedPos = p29;
        r28 = peg$c201(r5,r7,r8,r16,r25,r27,r28);
      }
      r24 = r28;
      if (r24 === peg$FAILED) {
        peg$currPos = p23;
        r16 = peg$FAILED;
        break seq_5;
      }
      p30 = peg$currPos;
      choice_4: {
      if (input.charCodeAt(peg$currPos) === 124) {
        r24 = "|";
        peg$currPos += 1;
        break choice_4;
      } else {
        r24 = peg$FAILED;
      }
      r24 = input.substr(peg$currPos,3);
      if (r24 === "}}}") {
        peg$currPos += 3;
      } else {
        r24 = peg$FAILED;
      }
      } // choice_4
      if (r24!== peg$FAILED) {
        r24 = void 0;
        peg$currPos = p30;
      } else {
        peg$currPos = p23;
        r16 = peg$FAILED;
        break seq_5;
      }
      // free p30
      r16 = true;
      } // seq_5
      if (r16!== peg$FAILED) {
        peg$savedPos = p22;
        r16 = peg$c202(r5,r7,r8,r16,r25,r27,r28);
        break choice_3;
      }
      // free r24,p23
      r16 = peg$parsetemplate_param_value(silence);
      } // choice_3
      // r <- r16
      r12 = r16;
      if (r12 === peg$FAILED) {
        peg$currPos = p15;
        r9 = peg$FAILED;
        break seq_4;
      }
      r9 = true;
      } // seq_4
      if (r9!== peg$FAILED) {
        peg$savedPos = p11;
        r9 = peg$c203(r5,r7,r8,r16);
      }
      // free r12,p15
    }
    // params <- r8
    // free r9
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$discardnl_comment_space(silence);
    while (r9 !== peg$FAILED) {
      r9 = peg$discardnl_comment_space(silence);
    }
    // free r9
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r4 = peg$discardinline_breaks(silence);
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r4 = input.substr(peg$currPos,3);
    if (r4 === "}}}") {
      peg$currPos += 3;
    } else {
      if (!silence) {peg$fail(peg$c204);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c205(r5,r7,r8);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetemplate_preproc(silence) {
    var r1,p2,p3,r4,r5,r6,r7,p8,p9,r10,r11,p12,p13,r14,r15,p16,r17,r18,p19,p20,p21,r22,r23,p24,r25,r26,p27,p28;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*36).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "{{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c147);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$discardnl_comment_space(silence);
    while (r5 !== peg$FAILED) {
      r5 = peg$discardnl_comment_space(silence);
    }
    // free r5
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsetemplate_param_value(silence);
    // target <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = [];
    p8 = peg$currPos;
    seq_2: {
    p9 = peg$currPos;
    r11 = peg$discardnl_comment_space(silence);
    while (r11 !== peg$FAILED) {
      r11 = peg$discardnl_comment_space(silence);
    }
    // free r11
    r10 = true;
    if (r10 === peg$FAILED) {
      r7 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 124) {
      r10 = "|";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r10 = peg$FAILED;
      peg$currPos = p9;
      r7 = peg$FAILED;
      break seq_2;
    }
    choice_2: {
    p12 = peg$currPos;
    seq_3: {
    p13 = peg$currPos;
    p16 = peg$currPos;
    r15 = '';
    // p0 <- r15
    if (r15!== peg$FAILED) {
      peg$savedPos = p16;
      r15 = peg$c206(r5,r6,r11,r15);
    }
    r14 = r15;
    if (r14 === peg$FAILED) {
      r11 = peg$FAILED;
      break seq_3;
    }
    r17 = [];
    r18 = peg$parsenl_comment_space(silence);
    while (r18 !== peg$FAILED) {
      r17.push(r18);
      r18 = peg$parsenl_comment_space(silence);
    }
    // v <- r17
    // free r18
    r14 = r17;
    if (r14 === peg$FAILED) {
      peg$currPos = p13;
      r11 = peg$FAILED;
      break seq_3;
    }
    p19 = peg$currPos;
    r18 = '';
    // p <- r18
    if (r18!== peg$FAILED) {
      peg$savedPos = p19;
      r18 = peg$c207(r5,r6,r11,r15,r17,r18);
    }
    r14 = r18;
    if (r14 === peg$FAILED) {
      peg$currPos = p13;
      r11 = peg$FAILED;
      break seq_3;
    }
    p20 = peg$currPos;
    choice_3: {
    if (input.charCodeAt(peg$currPos) === 124) {
      r14 = "|";
      peg$currPos += 1;
      break choice_3;
    } else {
      r14 = peg$FAILED;
    }
    r14 = input.substr(peg$currPos,2);
    if (r14 === "}}") {
      peg$currPos += 2;
    } else {
      r14 = peg$FAILED;
    }
    } // choice_3
    if (r14!== peg$FAILED) {
      r14 = void 0;
      peg$currPos = p20;
    } else {
      peg$currPos = p13;
      r11 = peg$FAILED;
      break seq_3;
    }
    // free p20
    r11 = true;
    } // seq_3
    if (r11!== peg$FAILED) {
      peg$savedPos = p12;
      r11 = peg$c208(r5,r6,r11,r15,r17,r18);
      break choice_2;
    }
    // free r14,p13
    r11 = peg$parsetemplate_param(silence);
    } // choice_2
    // r <- r11
    r10 = r11;
    if (r10 === peg$FAILED) {
      peg$currPos = p9;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = true;
    } // seq_2
    if (r7!== peg$FAILED) {
      peg$savedPos = p8;
      r7 = peg$c209(r5,r6,r11);
    }
    // free r10,p9
    while (r7 !== peg$FAILED) {
      r6.push(r7);
      p9 = peg$currPos;
      seq_4: {
      p13 = peg$currPos;
      r14 = peg$discardnl_comment_space(silence);
      while (r14 !== peg$FAILED) {
        r14 = peg$discardnl_comment_space(silence);
      }
      // free r14
      r10 = true;
      if (r10 === peg$FAILED) {
        r7 = peg$FAILED;
        break seq_4;
      }
      if (input.charCodeAt(peg$currPos) === 124) {
        r10 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c42);}
        r10 = peg$FAILED;
        peg$currPos = p13;
        r7 = peg$FAILED;
        break seq_4;
      }
      choice_4: {
      p20 = peg$currPos;
      seq_5: {
      p21 = peg$currPos;
      p24 = peg$currPos;
      r23 = '';
      // p0 <- r23
      if (r23!== peg$FAILED) {
        peg$savedPos = p24;
        r23 = peg$c206(r5,r6,r14,r23);
      }
      r22 = r23;
      if (r22 === peg$FAILED) {
        r14 = peg$FAILED;
        break seq_5;
      }
      r25 = [];
      r26 = peg$parsenl_comment_space(silence);
      while (r26 !== peg$FAILED) {
        r25.push(r26);
        r26 = peg$parsenl_comment_space(silence);
      }
      // v <- r25
      // free r26
      r22 = r25;
      if (r22 === peg$FAILED) {
        peg$currPos = p21;
        r14 = peg$FAILED;
        break seq_5;
      }
      p27 = peg$currPos;
      r26 = '';
      // p <- r26
      if (r26!== peg$FAILED) {
        peg$savedPos = p27;
        r26 = peg$c207(r5,r6,r14,r23,r25,r26);
      }
      r22 = r26;
      if (r22 === peg$FAILED) {
        peg$currPos = p21;
        r14 = peg$FAILED;
        break seq_5;
      }
      p28 = peg$currPos;
      choice_5: {
      if (input.charCodeAt(peg$currPos) === 124) {
        r22 = "|";
        peg$currPos += 1;
        break choice_5;
      } else {
        r22 = peg$FAILED;
      }
      r22 = input.substr(peg$currPos,2);
      if (r22 === "}}") {
        peg$currPos += 2;
      } else {
        r22 = peg$FAILED;
      }
      } // choice_5
      if (r22!== peg$FAILED) {
        r22 = void 0;
        peg$currPos = p28;
      } else {
        peg$currPos = p21;
        r14 = peg$FAILED;
        break seq_5;
      }
      // free p28
      r14 = true;
      } // seq_5
      if (r14!== peg$FAILED) {
        peg$savedPos = p20;
        r14 = peg$c208(r5,r6,r14,r23,r25,r26);
        break choice_4;
      }
      // free r22,p21
      r14 = peg$parsetemplate_param(silence);
      } // choice_4
      // r <- r14
      r10 = r14;
      if (r10 === peg$FAILED) {
        peg$currPos = p13;
        r7 = peg$FAILED;
        break seq_4;
      }
      r7 = true;
      } // seq_4
      if (r7!== peg$FAILED) {
        peg$savedPos = p9;
        r7 = peg$c209(r5,r6,r14);
      }
      // free r10,p13
    }
    // params <- r6
    // free r7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$discardnl_comment_space(silence);
    while (r7 !== peg$FAILED) {
      r7 = peg$discardnl_comment_space(silence);
    }
    // free r7
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r4 = peg$discardinline_breaks(silence);
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r4 = input.substr(peg$currPos,2);
    if (r4 === "}}") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c210);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c211(r5,r6);
      break choice_1;
    }
    // free r4,p3
    p3 = peg$currPos;
    seq_6: {
    p13 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "{{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c147);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_6;
    }
    r7 = peg$discardspace_or_newline(silence);
    while (r7 !== peg$FAILED) {
      r7 = peg$discardspace_or_newline(silence);
    }
    // free r7
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p13;
      r1 = peg$FAILED;
      break seq_6;
    }
    r4 = input.substr(peg$currPos,2);
    if (r4 === "}}") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c210);}
      r4 = peg$FAILED;
      peg$currPos = p13;
      r1 = peg$FAILED;
      break seq_6;
    }
    r1 = true;
    } // seq_6
    if (r1!== peg$FAILED) {
      r1 = input.substring(p3,peg$currPos);
    } else {
      r1 = peg$FAILED;
    }
    // free r4,p13
    // free p3
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsewikilink_preproc(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*60).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "[[") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c121);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsewikilink_preprocessor_text(silence);
    if (r5 === peg$FAILED) {
      r5 = null;
    }
    // target <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r6 = '';
    // tpos <- r6
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c212(r5,r6);
    }
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parsewikilink_content(silence);
    // lcs <- r8
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r4 = peg$discardinline_breaks(silence);
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r4 = input.substr(peg$currPos,2);
    if (r4 === "]]") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c213);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c214(r5,r6,r8);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardbroken_wikilink(silence) {
    var r1,p2,p3,r4,p5,r6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*59).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "[[") {
      peg$currPos += 2;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    peg$savedPos = peg$currPos;
    r4 = peg$c146();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r7 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c50);}
      r7 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    r8 = peg$parseextlink(silence);
    if (r8!== peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 91) {
      r8 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c50);}
      r8 = peg$FAILED;
    }
    } // choice_1
    if (r8 === peg$FAILED) {
      peg$currPos = p5;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = [r7,r8];
    } // seq_2
    // a <- r6
    // free r7,r8,p5
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c166(r6);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardtag_name(silence) {
    var p1,r2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*68).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[A-Za-z]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c46);}
      r2 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$discardtag_name_chars(silence);
    while (r5 !== peg$FAILED) {
      r5 = peg$discardtag_name_chars(silence);
    }
    // free r5
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      r2 = input.substring(p1,peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r4,p3
    // free p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$parselang_variant(silence) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*45).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = '';
    // stopLen <- r5
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c215(r5);
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    r7 = peg$parselang_variant_preproc(silence);
    if (r7!== peg$FAILED) {
      break choice_2;
    }
    peg$savedPos = peg$currPos;
    r7 = peg$c216(r5,r7);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
    }
    } // choice_2
    // lv <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c217(r5,r7);
      break choice_1;
    }
    // free r4,p3
    r1 = peg$parsebroken_lang_variant(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseautourl(silence) {
    var r1,p2,p3,r4,p5,r6,p7,r8,r9,r10,r11,r12,p13,p14,r15,p16,r17,p18,p19,p20,r21,r22,r23,p24,r25,p26,p27,p28,r29,r30,r31,p32,r33;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*29).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c218();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "//") {
      peg$currPos += 2;
    } else {
      r4 = peg$FAILED;
    }
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    p5 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    r9 = peg$parseurl_protocol(silence);
    // proto <- r9
    r8 = r9;
    if (r8 === peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    choice_2: {
    r10 = peg$parseurladdr(silence);
    if (r10!== peg$FAILED) {
      break choice_2;
    }
    r10 = '';
    } // choice_2
    // addr <- r10
    r8 = r10;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r11 = [];
    choice_3: {
    p13 = peg$currPos;
    seq_3: {
    p14 = peg$currPos;
    p16 = peg$currPos;
    r15 = peg$discardinline_breaks(true);
    if (r15 === peg$FAILED) {
      r15 = void 0;
    } else {
      r15 = peg$FAILED;
      peg$currPos = p16;
      r12 = peg$FAILED;
      break seq_3;
    }
    // free p16
    p16 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      r15 = "(";
      peg$currPos += 1;
    } else {
      r15 = peg$FAILED;
    }
    if (r15 === peg$FAILED) {
      r15 = void 0;
    } else {
      r15 = peg$FAILED;
      peg$currPos = p16;
      peg$currPos = p14;
      r12 = peg$FAILED;
      break seq_3;
    }
    // free p16
    r17 = peg$parseno_punctuation_char(silence);
    // c <- r17
    r15 = r17;
    if (r15 === peg$FAILED) {
      peg$currPos = p14;
      r12 = peg$FAILED;
      break seq_3;
    }
    r12 = true;
    } // seq_3
    if (r12!== peg$FAILED) {
      peg$savedPos = p13;
      r12 = peg$c219(r6,r9,r10,r11,r17);
      break choice_3;
    }
    // free r15,p14
    p14 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      r12 = "(";
      peg$currPos += 1;
      peg$savedPos = p14;
      r12 = peg$c221(r6,r9,r10,r11);
      break choice_3;
    } else {
      if (!silence) {peg$fail(peg$c220);}
      r12 = peg$FAILED;
    }
    r12 = input.charAt(peg$currPos);
    if (/^[.:,]/.test(r12)) {
      peg$currPos++;
      break choice_3;
    } else {
      r12 = peg$FAILED;
      if (!silence) {peg$fail(peg$c74);}
    }
    p16 = peg$currPos;
    seq_4: {
    p18 = peg$currPos;
    r15 = input.charAt(peg$currPos);
    if (/^[']/.test(r15)) {
      peg$currPos++;
    } else {
      r15 = peg$FAILED;
      if (!silence) {peg$fail(peg$c75);}
      r12 = peg$FAILED;
      break seq_4;
    }
    p19 = peg$currPos;
    r15 = input.charAt(peg$currPos);
    if (/^[']/.test(r15)) {
      peg$currPos++;
    } else {
      r15 = peg$FAILED;
    }
    if (r15 === peg$FAILED) {
      r15 = void 0;
    } else {
      r15 = peg$FAILED;
      peg$currPos = p19;
      peg$currPos = p18;
      r12 = peg$FAILED;
      break seq_4;
    }
    // free p19
    r12 = true;
    } // seq_4
    if (r12!== peg$FAILED) {
      r12 = input.substring(p16,peg$currPos);
      break choice_3;
    } else {
      r12 = peg$FAILED;
    }
    // free r15,p18
    // free p16
    r12 = peg$parsecomment(silence);
    if (r12!== peg$FAILED) {
      break choice_3;
    }
    r12 = peg$parsetplarg_or_template(silence);
    if (r12!== peg$FAILED) {
      break choice_3;
    }
    p16 = peg$currPos;
    seq_5: {
    p18 = peg$currPos;
    p19 = peg$currPos;
    seq_6: {
    p20 = peg$currPos;
    r22 = peg$parseraw_htmlentity(true);
    // rhe <- r22
    r21 = r22;
    if (r21 === peg$FAILED) {
      r15 = peg$FAILED;
      break seq_6;
    }
    peg$savedPos = peg$currPos;
    r21 = peg$c222(r6,r9,r10,r11,r22);
    if (r21) {
      r21 = void 0;
    } else {
      r21 = peg$FAILED;
      peg$currPos = p20;
      r15 = peg$FAILED;
      break seq_6;
    }
    r15 = true;
    } // seq_6
    // free r21,p20
    if (r15 === peg$FAILED) {
      r15 = void 0;
    } else {
      r15 = peg$FAILED;
      peg$currPos = p19;
      r12 = peg$FAILED;
      break seq_5;
    }
    // free p19
    choice_4: {
    p19 = peg$currPos;
    seq_7: {
    p20 = peg$currPos;
    p24 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      r23 = "&";
      peg$currPos += 1;
      r23 = void 0;
      peg$currPos = p24;
    } else {
      r23 = peg$FAILED;
      r21 = peg$FAILED;
      break seq_7;
    }
    // free p24
    r25 = peg$parsehtmlentity(silence);
    // he <- r25
    r23 = r25;
    if (r23 === peg$FAILED) {
      peg$currPos = p20;
      r21 = peg$FAILED;
      break seq_7;
    }
    r21 = true;
    } // seq_7
    if (r21!== peg$FAILED) {
      peg$savedPos = p19;
      r21 = peg$c223(r21,r9,r10,r11,r25);
      break choice_4;
    }
    // free r23,p20
    r21 = input.charAt(peg$currPos);
    if (/^[&%{]/.test(r21)) {
      peg$currPos++;
    } else {
      r21 = peg$FAILED;
      if (!silence) {peg$fail(peg$c224);}
    }
    } // choice_4
    // r <- r21
    r15 = r21;
    if (r15 === peg$FAILED) {
      peg$currPos = p18;
      r12 = peg$FAILED;
      break seq_5;
    }
    r12 = true;
    } // seq_5
    if (r12!== peg$FAILED) {
      peg$savedPos = p16;
      r12 = peg$c225(r21,r9,r10,r11);
    }
    // free r15,p18
    } // choice_3
    while (r12 !== peg$FAILED) {
      r11.push(r12);
      choice_5: {
      p18 = peg$currPos;
      seq_8: {
      p20 = peg$currPos;
      p24 = peg$currPos;
      r15 = peg$discardinline_breaks(true);
      if (r15 === peg$FAILED) {
        r15 = void 0;
      } else {
        r15 = peg$FAILED;
        peg$currPos = p24;
        r12 = peg$FAILED;
        break seq_8;
      }
      // free p24
      p24 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        r15 = "(";
        peg$currPos += 1;
      } else {
        r15 = peg$FAILED;
      }
      if (r15 === peg$FAILED) {
        r15 = void 0;
      } else {
        r15 = peg$FAILED;
        peg$currPos = p24;
        peg$currPos = p20;
        r12 = peg$FAILED;
        break seq_8;
      }
      // free p24
      r23 = peg$parseno_punctuation_char(silence);
      // c <- r23
      r15 = r23;
      if (r15 === peg$FAILED) {
        peg$currPos = p20;
        r12 = peg$FAILED;
        break seq_8;
      }
      r12 = true;
      } // seq_8
      if (r12!== peg$FAILED) {
        peg$savedPos = p18;
        r12 = peg$c219(r6,r9,r10,r11,r23);
        break choice_5;
      }
      // free r15,p20
      p20 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        r12 = "(";
        peg$currPos += 1;
        peg$savedPos = p20;
        r12 = peg$c221(r6,r9,r10,r11);
        break choice_5;
      } else {
        if (!silence) {peg$fail(peg$c220);}
        r12 = peg$FAILED;
      }
      r12 = input.charAt(peg$currPos);
      if (/^[.:,]/.test(r12)) {
        peg$currPos++;
        break choice_5;
      } else {
        r12 = peg$FAILED;
        if (!silence) {peg$fail(peg$c74);}
      }
      p24 = peg$currPos;
      seq_9: {
      p26 = peg$currPos;
      r15 = input.charAt(peg$currPos);
      if (/^[']/.test(r15)) {
        peg$currPos++;
      } else {
        r15 = peg$FAILED;
        if (!silence) {peg$fail(peg$c75);}
        r12 = peg$FAILED;
        break seq_9;
      }
      p27 = peg$currPos;
      r15 = input.charAt(peg$currPos);
      if (/^[']/.test(r15)) {
        peg$currPos++;
      } else {
        r15 = peg$FAILED;
      }
      if (r15 === peg$FAILED) {
        r15 = void 0;
      } else {
        r15 = peg$FAILED;
        peg$currPos = p27;
        peg$currPos = p26;
        r12 = peg$FAILED;
        break seq_9;
      }
      // free p27
      r12 = true;
      } // seq_9
      if (r12!== peg$FAILED) {
        r12 = input.substring(p24,peg$currPos);
        break choice_5;
      } else {
        r12 = peg$FAILED;
      }
      // free r15,p26
      // free p24
      r12 = peg$parsecomment(silence);
      if (r12!== peg$FAILED) {
        break choice_5;
      }
      r12 = peg$parsetplarg_or_template(silence);
      if (r12!== peg$FAILED) {
        break choice_5;
      }
      p24 = peg$currPos;
      seq_10: {
      p26 = peg$currPos;
      p27 = peg$currPos;
      seq_11: {
      p28 = peg$currPos;
      r30 = peg$parseraw_htmlentity(true);
      // rhe <- r30
      r29 = r30;
      if (r29 === peg$FAILED) {
        r15 = peg$FAILED;
        break seq_11;
      }
      peg$savedPos = peg$currPos;
      r29 = peg$c222(r6,r9,r10,r11,r30);
      if (r29) {
        r29 = void 0;
      } else {
        r29 = peg$FAILED;
        peg$currPos = p28;
        r15 = peg$FAILED;
        break seq_11;
      }
      r15 = true;
      } // seq_11
      // free r29,p28
      if (r15 === peg$FAILED) {
        r15 = void 0;
      } else {
        r15 = peg$FAILED;
        peg$currPos = p27;
        r12 = peg$FAILED;
        break seq_10;
      }
      // free p27
      choice_6: {
      p27 = peg$currPos;
      seq_12: {
      p28 = peg$currPos;
      p32 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        r31 = "&";
        peg$currPos += 1;
        r31 = void 0;
        peg$currPos = p32;
      } else {
        r31 = peg$FAILED;
        r29 = peg$FAILED;
        break seq_12;
      }
      // free p32
      r33 = peg$parsehtmlentity(silence);
      // he <- r33
      r31 = r33;
      if (r31 === peg$FAILED) {
        peg$currPos = p28;
        r29 = peg$FAILED;
        break seq_12;
      }
      r29 = true;
      } // seq_12
      if (r29!== peg$FAILED) {
        peg$savedPos = p27;
        r29 = peg$c223(r29,r9,r10,r11,r33);
        break choice_6;
      }
      // free r31,p28
      r29 = input.charAt(peg$currPos);
      if (/^[&%{]/.test(r29)) {
        peg$currPos++;
      } else {
        r29 = peg$FAILED;
        if (!silence) {peg$fail(peg$c224);}
      }
      } // choice_6
      // r <- r29
      r15 = r29;
      if (r15 === peg$FAILED) {
        peg$currPos = p26;
        r12 = peg$FAILED;
        break seq_10;
      }
      r12 = true;
      } // seq_10
      if (r12!== peg$FAILED) {
        peg$savedPos = p24;
        r12 = peg$c225(r29,r9,r10,r11);
      }
      // free r15,p26
      } // choice_5
    }
    // path <- r11
    // free r12
    r8 = r11;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    // r <- r6
    if (r6!== peg$FAILED) {
      peg$savedPos = p5;
      r6 = peg$c226(r6,r9,r10,r11);
    }
    // free r8,p7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c227(r6);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c228(r6);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c229();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseautoref(silence) {
    var r1,p2,p3,r4,r5,r6,r7,p8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*24).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    choice_1: {
    r5 = input.substr(peg$currPos,3);
    if (r5 === "RFC") {
      peg$currPos += 3;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c230);}
      r5 = peg$FAILED;
    }
    r5 = input.substr(peg$currPos,4);
    if (r5 === "PMID") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c231);}
      r5 = peg$FAILED;
    }
    } // choice_1
    // ref <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsespace_or_nbsp(silence);
    if (r7!== peg$FAILED) {
      r6 = [];
      while (r7 !== peg$FAILED) {
        r6.push(r7);
        r7 = peg$parsespace_or_nbsp(silence);
      }
    } else {
      r6 = peg$FAILED;
    }
    // sp <- r6
    // free r7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p8 = peg$currPos;
    r9 = input.charAt(peg$currPos);
    if (/^[0-9]/.test(r9)) {
      peg$currPos++;
      r7 = true;
      while (r9 !== peg$FAILED) {
        r9 = input.charAt(peg$currPos);
        if (/^[0-9]/.test(r9)) {
          peg$currPos++;
        } else {
          r9 = peg$FAILED;
          if (!silence) {peg$fail(peg$c232);}
        }
      }
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c232);}
      r7 = peg$FAILED;
    }
    // identifier <- r7
    if (r7!== peg$FAILED) {
      r7 = input.substring(p8,peg$currPos);
    } else {
      r7 = peg$FAILED;
    }
    // free r9
    // free p8
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r4 = peg$discardend_of_word(silence);
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c233(r5,r6,r7);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseisbn(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,r10,p11,p12,r13,r14,p15,r16,p17,r18;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*25).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "ISBN") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c234);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parsespace_or_nbsp(silence);
    if (r6!== peg$FAILED) {
      r5 = [];
      while (r6 !== peg$FAILED) {
        r5.push(r6);
        r6 = peg$parsespace_or_nbsp(silence);
      }
    } else {
      r5 = peg$FAILED;
    }
    // sp <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p7 = peg$currPos;
    r8 = input.charAt(peg$currPos);
    if (/^[0-9]/.test(r8)) {
      peg$currPos++;
    } else {
      r8 = peg$FAILED;
      if (!silence) {peg$fail(peg$c232);}
      r6 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    p11 = peg$currPos;
    seq_3: {
    p12 = peg$currPos;
    r14 = peg$parsespace_or_nbsp_or_dash(silence);
    // s <- r14
    r13 = r14;
    if (r13 === peg$FAILED) {
      r10 = peg$FAILED;
      break seq_3;
    }
    p15 = peg$currPos;
    r13 = input.charAt(peg$currPos);
    if (/^[0-9]/.test(r13)) {
      peg$currPos++;
      r13 = void 0;
      peg$currPos = p15;
    } else {
      r13 = peg$FAILED;
      peg$currPos = p12;
      r10 = peg$FAILED;
      break seq_3;
    }
    // free p15
    r10 = true;
    } // seq_3
    if (r10!== peg$FAILED) {
      peg$savedPos = p11;
      r10 = peg$c235(r5,r6,r14);
      break choice_1;
    }
    // free r13,p12
    r10 = input.charAt(peg$currPos);
    if (/^[0-9]/.test(r10)) {
      peg$currPos++;
    } else {
      r10 = peg$FAILED;
      if (!silence) {peg$fail(peg$c232);}
    }
    } // choice_1
    if (r10!== peg$FAILED) {
      r9 = [];
      while (r10 !== peg$FAILED) {
        r9.push(r10);
        choice_2: {
        p12 = peg$currPos;
        seq_4: {
        p15 = peg$currPos;
        r16 = peg$parsespace_or_nbsp_or_dash(silence);
        // s <- r16
        r13 = r16;
        if (r13 === peg$FAILED) {
          r10 = peg$FAILED;
          break seq_4;
        }
        p17 = peg$currPos;
        r13 = input.charAt(peg$currPos);
        if (/^[0-9]/.test(r13)) {
          peg$currPos++;
          r13 = void 0;
          peg$currPos = p17;
        } else {
          r13 = peg$FAILED;
          peg$currPos = p15;
          r10 = peg$FAILED;
          break seq_4;
        }
        // free p17
        r10 = true;
        } // seq_4
        if (r10!== peg$FAILED) {
          peg$savedPos = p12;
          r10 = peg$c235(r5,r6,r16);
          break choice_2;
        }
        // free r13,p15
        r10 = input.charAt(peg$currPos);
        if (/^[0-9]/.test(r10)) {
          peg$currPos++;
        } else {
          r10 = peg$FAILED;
          if (!silence) {peg$fail(peg$c232);}
        }
        } // choice_2
      }
    } else {
      r9 = peg$FAILED;
    }
    if (r9 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free r10
    choice_3: {
    seq_5: {
    p15 = peg$currPos;
    choice_4: {
    r13 = peg$parsespace_or_nbsp_or_dash(silence);
    if (r13!== peg$FAILED) {
      break choice_4;
    }
    r13 = '';
    } // choice_4
    if (r13 === peg$FAILED) {
      r10 = peg$FAILED;
      break seq_5;
    }
    r18 = input.charAt(peg$currPos);
    if (/^[xX]/.test(r18)) {
      peg$currPos++;
    } else {
      r18 = peg$FAILED;
      if (!silence) {peg$fail(peg$c236);}
      peg$currPos = p15;
      r10 = peg$FAILED;
      break seq_5;
    }
    r10 = [r13,r18];
    } // seq_5
    if (r10!== peg$FAILED) {
      break choice_3;
    }
    // free r13,r18,p15
    r10 = '';
    } // choice_3
    if (r10 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = [r8,r9,r10];
    } // seq_2
    // isbn <- r6
    // free r8,r9,r10,p7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r10 = peg$discardend_of_word(silence);
    // isbncode <- r10
    if (r10!== peg$FAILED) {
      peg$savedPos = p7;
      r10 = peg$c237(r5,r6,r10);
    }
    r4 = r10;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c238(r5,r6,r10);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c239(r5,r6,r10);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardbehavior_text(silence) {
    var p1,r2,r3,p4,r5,p6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*21).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p1 = peg$currPos;
    seq_1: {
    p4 = peg$currPos;
    p6 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    if (r5 === "__") {
      peg$currPos += 2;
    } else {
      r5 = peg$FAILED;
    }
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p6;
      r3 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r5 = input.charAt(peg$currPos);
    if (/^[^'"<~[{\n\r:;\]}|!=]/.test(r5)) {
      peg$currPos++;
    } else {
      r5 = peg$FAILED;
      if (!silence) {peg$fail(peg$c240);}
      peg$currPos = p4;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    if (r3!== peg$FAILED) {
      r2 = true;
      while (r3 !== peg$FAILED) {
        seq_2: {
        p4 = peg$currPos;
        p6 = peg$currPos;
        r5 = input.substr(peg$currPos,2);
        if (r5 === "__") {
          peg$currPos += 2;
        } else {
          r5 = peg$FAILED;
        }
        if (r5 === peg$FAILED) {
          r5 = void 0;
        } else {
          r5 = peg$FAILED;
          peg$currPos = p6;
          r3 = peg$FAILED;
          break seq_2;
        }
        // free p6
        r5 = input.charAt(peg$currPos);
        if (/^[^'"<~[{\n\r:;\]}|!=]/.test(r5)) {
          peg$currPos++;
        } else {
          r5 = peg$FAILED;
          if (!silence) {peg$fail(peg$c240);}
          peg$currPos = p4;
          r3 = peg$FAILED;
          break seq_2;
        }
        r3 = true;
        } // seq_2
        // free r5,p4
      }
    } else {
      r2 = peg$FAILED;
    }
    // free r5,p4
    if (r2!== peg$FAILED) {
      r2 = input.substring(p1,peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r3
    // free p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$parsebroken_wikilink(silence) {
    var r1,p2,p3,r4,p5,r6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*59).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "[[") {
      peg$currPos += 2;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    peg$savedPos = peg$currPos;
    r4 = peg$c146();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r7 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c50);}
      r7 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    r8 = peg$parseextlink(silence);
    if (r8!== peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 91) {
      r8 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c50);}
      r8 = peg$FAILED;
    }
    } // choice_1
    if (r8 === peg$FAILED) {
      peg$currPos = p5;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = [r7,r8];
    } // seq_2
    // a <- r6
    // free r7,r8,p5
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c166(r6);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsespaces(silence) {
    var p1,r2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*102).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p1 = peg$currPos;
    r3 = input.charAt(peg$currPos);
    if (/^[ \t]/.test(r3)) {
      peg$currPos++;
      r2 = true;
      while (r3 !== peg$FAILED) {
        r3 = input.charAt(peg$currPos);
        if (/^[ \t]/.test(r3)) {
          peg$currPos++;
        } else {
          r3 = peg$FAILED;
          if (!silence) {peg$fail(peg$c37);}
        }
      }
    } else {
      r3 = peg$FAILED;
      if (!silence) {peg$fail(peg$c37);}
      r2 = peg$FAILED;
    }
    if (r2!== peg$FAILED) {
      r2 = input.substring(p1,peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r3
    // free p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$parsedtdd(silence) {
    var r1,p2,p3,r4,r5,r6,p7,p8,r9,p10,p11,r12,p13,r14,p15,r16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*83).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = [];
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    p10 = peg$currPos;
    seq_3: {
    p11 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 59) {
      r12 = ";";
      peg$currPos += 1;
    } else {
      r12 = peg$FAILED;
      r9 = peg$FAILED;
      break seq_3;
    }
    p13 = peg$currPos;
    r12 = peg$discardlist_char(true);
    if (r12 === peg$FAILED) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      peg$currPos = p13;
      peg$currPos = p11;
      r9 = peg$FAILED;
      break seq_3;
    }
    // free p13
    r9 = true;
    } // seq_3
    // free r12,p11
    if (r9 === peg$FAILED) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p10;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free p10
    r12 = peg$parselist_char(silence);
    // lc <- r12
    r9 = r12;
    if (r9 === peg$FAILED) {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c241(r5,r12);
    }
    // free r9,p8
    while (r6 !== peg$FAILED) {
      r5.push(r6);
      p8 = peg$currPos;
      seq_4: {
      p10 = peg$currPos;
      p11 = peg$currPos;
      seq_5: {
      p13 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        r14 = ";";
        peg$currPos += 1;
      } else {
        r14 = peg$FAILED;
        r9 = peg$FAILED;
        break seq_5;
      }
      p15 = peg$currPos;
      r14 = peg$discardlist_char(true);
      if (r14 === peg$FAILED) {
        r14 = void 0;
      } else {
        r14 = peg$FAILED;
        peg$currPos = p15;
        peg$currPos = p13;
        r9 = peg$FAILED;
        break seq_5;
      }
      // free p15
      r9 = true;
      } // seq_5
      // free r14,p13
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p11;
        r6 = peg$FAILED;
        break seq_4;
      }
      // free p11
      r14 = peg$parselist_char(silence);
      // lc <- r14
      r9 = r14;
      if (r9 === peg$FAILED) {
        peg$currPos = p10;
        r6 = peg$FAILED;
        break seq_4;
      }
      r6 = true;
      } // seq_4
      if (r6!== peg$FAILED) {
        peg$savedPos = p8;
        r6 = peg$c241(r5,r14);
      }
      // free r9,p10
    }
    // bullets <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 59) {
      r4 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c97);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c242(r5);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parseinlineline(silence);
    if (r6 === peg$FAILED) {
      r6 = null;
    }
    // c <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p10 = peg$currPos;
    // cpos <- r9
    if (input.charCodeAt(peg$currPos) === 58) {
      r9 = ":";
      peg$currPos += 1;
      peg$savedPos = p10;
      r9 = peg$c243(r5,r6,r9);
    } else {
      if (!silence) {peg$fail(peg$c48);}
      r9 = peg$FAILED;
    }
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c244(r5,r6,r9);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r16 = peg$parseinlineline(silence);
    if (r16 === peg$FAILED) {
      r16 = null;
    }
    // d <- r16
    r4 = r16;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p11 = peg$currPos;
    r4 = peg$discardeolf(true);
    if (r4!== peg$FAILED) {
      r4 = void 0;
      peg$currPos = p11;
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p11
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c245(r5,r6,r9,r16);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c246();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsehacky_dl_uses(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,r10,p11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*82).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 58) {
      r6 = ":";
      peg$currPos += 1;
      r5 = [];
      while (r6 !== peg$FAILED) {
        r5.push(r6);
        if (input.charCodeAt(peg$currPos) === 58) {
          r6 = ":";
          peg$currPos += 1;
        } else {
          if (!silence) {peg$fail(peg$c48);}
          r6 = peg$FAILED;
        }
      }
    } else {
      if (!silence) {peg$fail(peg$c48);}
      r6 = peg$FAILED;
      r5 = peg$FAILED;
    }
    // bullets <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p7 = peg$currPos;
    r8 = peg$parsetable_line(silence);
    if (r8 === peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    r9 = [];
    seq_3: {
    p11 = peg$currPos;
    r12 = peg$parsesol(silence);
    if (r12 === peg$FAILED) {
      r10 = peg$FAILED;
      break seq_3;
    }
    r13 = peg$parsetable_line(silence);
    if (r13 === peg$FAILED) {
      peg$currPos = p11;
      r10 = peg$FAILED;
      break seq_3;
    }
    r10 = [r12,r13];
    } // seq_3
    // free r12,r13,p11
    while (r10 !== peg$FAILED) {
      r9.push(r10);
      seq_4: {
      p11 = peg$currPos;
      r13 = peg$parsesol(silence);
      if (r13 === peg$FAILED) {
        r10 = peg$FAILED;
        break seq_4;
      }
      r12 = peg$parsetable_line(silence);
      if (r12 === peg$FAILED) {
        peg$currPos = p11;
        r10 = peg$FAILED;
        break seq_4;
      }
      r10 = [r13,r12];
      } // seq_4
      // free r13,r12,p11
    }
    // free r10
    r6 = [r8,r9];
    } // seq_2
    // tbl <- r6
    // free r8,r9,p7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$parseinlineline(silence);
    if (r9 === peg$FAILED) {
      r9 = null;
    }
    // line <- r9
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r4 = peg$discardcomment_space_eolf(true);
    if (r4!== peg$FAILED) {
      r4 = void 0;
      peg$currPos = p7;
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c247(r5,r6,r9);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseli(silence) {
    var r1,p2,p3,r4,r5,r6,p7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*81).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r6 = peg$parselist_char(silence);
    if (r6!== peg$FAILED) {
      r5 = [];
      while (r6 !== peg$FAILED) {
        r5.push(r6);
        r6 = peg$parselist_char(silence);
      }
    } else {
      r5 = peg$FAILED;
    }
    // bullets <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parseinlineline(silence);
    if (r6 === peg$FAILED) {
      r6 = null;
    }
    // c <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    choice_1: {
    r4 = peg$discardeolf(true);
    if (r4!== peg$FAILED) {
      break choice_1;
    }
    r4 = peg$discardinline_breaks(true);
    } // choice_1
    if (r4!== peg$FAILED) {
      r4 = void 0;
      peg$currPos = p7;
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c248(r5,r6);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardsol(silence) {
    var p1,r2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*112).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    seq_1: {
    p1 = peg$currPos;
    choice_1: {
    r3 = peg$discardempty_line_with_comments(silence);
    if (r3!== peg$FAILED) {
      break choice_1;
    }
    r3 = peg$discardsol_prefix(silence);
    } // choice_1
    if (r3 === peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    r3 = peg$discardcomment_or_includes(silence);
    if (r3 === peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    // free r2,r3,p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$parseoptionalNewlines(silence) {
    var r1,p2,r3,p4,r5,p6,r7,p8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*110).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p6 = peg$currPos;
    r7 = input.charAt(peg$currPos);
    if (/^[\n\r\t ]/.test(r7)) {
      peg$currPos++;
    } else {
      r7 = peg$FAILED;
      if (!silence) {peg$fail(peg$c249);}
      r5 = peg$FAILED;
      break seq_1;
    }
    p8 = peg$currPos;
    r7 = input.charAt(peg$currPos);
    if (/^[\n\r]/.test(r7)) {
      peg$currPos++;
      r7 = void 0;
      peg$currPos = p8;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_1;
    }
    // free p8
    r5 = true;
    } // seq_1
    // free r7,p6
    while (r5 !== peg$FAILED) {
      seq_2: {
      p6 = peg$currPos;
      r7 = input.charAt(peg$currPos);
      if (/^[\n\r\t ]/.test(r7)) {
        peg$currPos++;
      } else {
        r7 = peg$FAILED;
        if (!silence) {peg$fail(peg$c249);}
        r5 = peg$FAILED;
        break seq_2;
      }
      p8 = peg$currPos;
      r7 = input.charAt(peg$currPos);
      if (/^[\n\r]/.test(r7)) {
        peg$currPos++;
        r7 = void 0;
        peg$currPos = p8;
      } else {
        r7 = peg$FAILED;
        peg$currPos = p6;
        r5 = peg$FAILED;
        break seq_2;
      }
      // free p8
      r5 = true;
      } // seq_2
      // free r7,p6
    }
    // free r5
    r3 = true;
    // spc <- r3
    if (r3!== peg$FAILED) {
      r3 = input.substring(p4,peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c250(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_content_line(silence) {
    var p1,r2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*87).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    seq_1: {
    p1 = peg$currPos;
    r3 = [];
    choice_1: {
    r4 = peg$parsespace(silence);
    if (r4!== peg$FAILED) {
      break choice_1;
    }
    r4 = peg$parsecomment(silence);
    } // choice_1
    while (r4 !== peg$FAILED) {
      r3.push(r4);
      choice_2: {
      r4 = peg$parsespace(silence);
      if (r4!== peg$FAILED) {
        break choice_2;
      }
      r4 = peg$parsecomment(silence);
      } // choice_2
    }
    // free r4
    choice_3: {
    r4 = peg$parsetable_heading_tags(silence);
    if (r4!== peg$FAILED) {
      break choice_3;
    }
    r4 = peg$parsetable_row_tag(silence);
    if (r4!== peg$FAILED) {
      break choice_3;
    }
    r4 = peg$parsetable_data_tags(silence);
    if (r4!== peg$FAILED) {
      break choice_3;
    }
    r4 = peg$parsetable_caption_tag(silence);
    } // choice_3
    if (r4 === peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = [r3,r4];
    } // seq_1
    // free r2,r3,r4,p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$parsetable_end_tag(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*96).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = [];
    choice_1: {
    r6 = peg$parsespace(silence);
    if (r6!== peg$FAILED) {
      break choice_1;
    }
    r6 = peg$parsecomment(silence);
    } // choice_1
    while (r6 !== peg$FAILED) {
      r5.push(r6);
      choice_2: {
      r6 = peg$parsespace(silence);
      if (r6!== peg$FAILED) {
        break choice_2;
      }
      r6 = peg$parsecomment(silence);
      } // choice_2
    }
    // sc <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r6 = '';
    // startPos <- r6
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c3(r5,r6);
    }
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parsepipe(silence);
    // p <- r8
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // b <- r9
    if (input.charCodeAt(peg$currPos) === 125) {
      r9 = "}";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c251);}
      r9 = peg$FAILED;
    }
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c252(r5,r6,r8,r9);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardtag_name_chars(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*67).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[^\t\n\x0B \/>\0]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c253);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsenewline(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*120).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 10) {
      r1 = "\n";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c87);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,2);
    if (r1 === "\r\n") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c88);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetemplate_param_value(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*41).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c254();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsetemplate_param_text(silence);
    // tpt <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c255(r5);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c256();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardnl_comment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*116).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$discardnewlineToken(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardcomment_space(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsenl_comment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*116).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$parsenewlineToken(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsecomment_space(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetemplate_param(silence) {
    var r1,p2,p3,r4,r5,r6,p7,p8,r9,r10,p11,r12,p13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*39).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parsetemplate_param_name(silence);
    // name <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    p11 = peg$currPos;
    r10 = '';
    // kEndPos <- r10
    if (r10!== peg$FAILED) {
      peg$savedPos = p11;
      r10 = peg$c257(r5,r6,r10);
    }
    r9 = r10;
    if (r9 === peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    r9 = peg$discardoptionalSpaceToken(silence);
    if (r9 === peg$FAILED) {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 61) {
      r9 = "=";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c60);}
      r9 = peg$FAILED;
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    p13 = peg$currPos;
    r12 = '';
    // vStartPos <- r12
    if (r12!== peg$FAILED) {
      peg$savedPos = p13;
      r12 = peg$c258(r5,r6,r10,r12);
    }
    r9 = r12;
    if (r9 === peg$FAILED) {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r9 = peg$discardoptionalSpaceToken(silence);
    if (r9 === peg$FAILED) {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r14 = peg$parsetemplate_param_value(silence);
    if (r14 === peg$FAILED) {
      r14 = null;
    }
    // tpv <- r14
    r9 = r14;
    if (r9 === peg$FAILED) {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c259(r5,r6,r10,r12,r14);
    } else {
      r6 = null;
    }
    // free r9,p8
    // val <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c260(r5,r6);
      break choice_1;
    }
    // free r4,p3
    p3 = peg$currPos;
    p8 = peg$currPos;
    r1 = input.charAt(peg$currPos);
    if (/^[|}]/.test(r1)) {
      peg$currPos++;
      r1 = void 0;
      peg$currPos = p8;
      peg$savedPos = p3;
      r1 = peg$c261();
    } else {
      r1 = peg$FAILED;
    }
    // free p8
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsewikilink_preprocessor_text(silence) {
    var r1,p2,r3,r4,r5,p6,r7,p8,p9,r10,p11,r12,p13,r14,r15,p16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*125).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    choice_1: {
    p6 = peg$currPos;
    r7 = input.charAt(peg$currPos);
    if (/^[^<[{\n\r\t|!\]}{ &\-]/.test(r7)) {
      peg$currPos++;
      r5 = true;
      while (r7 !== peg$FAILED) {
        r7 = input.charAt(peg$currPos);
        if (/^[^<[{\n\r\t|!\]}{ &\-]/.test(r7)) {
          peg$currPos++;
        } else {
          r7 = peg$FAILED;
          if (!silence) {peg$fail(peg$c262);}
        }
      }
    } else {
      r7 = peg$FAILED;
      if (!silence) {peg$fail(peg$c262);}
      r5 = peg$FAILED;
    }
    // t <- r5
    if (r5!== peg$FAILED) {
      r5 = input.substring(p6,peg$currPos);
    } else {
      r5 = peg$FAILED;
    }
    // free r7
    // free p6
    r4 = r5;
    if (r4!== peg$FAILED) {
      break choice_1;
    }
    p6 = peg$currPos;
    seq_1: {
    p8 = peg$currPos;
    p9 = peg$currPos;
    r7 = peg$discardinline_breaks(true);
    if (r7 === peg$FAILED) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p9;
      r4 = peg$FAILED;
      break seq_1;
    }
    // free p9
    choice_2: {
    r10 = peg$parsedirective(silence);
    if (r10!== peg$FAILED) {
      break choice_2;
    }
    p9 = peg$currPos;
    seq_2: {
    p11 = peg$currPos;
    p13 = peg$currPos;
    r12 = input.substr(peg$currPos,2);
    if (r12 === "]]") {
      peg$currPos += 2;
    } else {
      r12 = peg$FAILED;
    }
    if (r12 === peg$FAILED) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      peg$currPos = p13;
      r10 = peg$FAILED;
      break seq_2;
    }
    // free p13
    choice_3: {
    r12 = peg$discardtext_char(silence);
    if (r12!== peg$FAILED) {
      break choice_3;
    }
    r12 = input.charAt(peg$currPos);
    if (/^[!<\-}\]\n\r]/.test(r12)) {
      peg$currPos++;
    } else {
      r12 = peg$FAILED;
      if (!silence) {peg$fail(peg$c263);}
    }
    } // choice_3
    if (r12 === peg$FAILED) {
      peg$currPos = p11;
      r10 = peg$FAILED;
      break seq_2;
    }
    r10 = true;
    } // seq_2
    if (r10!== peg$FAILED) {
      r10 = input.substring(p9,peg$currPos);
    } else {
      r10 = peg$FAILED;
    }
    // free r12,p11
    // free p9
    } // choice_2
    // wr <- r10
    r7 = r10;
    if (r7 === peg$FAILED) {
      peg$currPos = p8;
      r4 = peg$FAILED;
      break seq_1;
    }
    r4 = true;
    } // seq_1
    if (r4!== peg$FAILED) {
      peg$savedPos = p6;
      r4 = peg$c264(r3,r5,r10);
    }
    // free r7,p8
    } // choice_1
    if (r4!== peg$FAILED) {
      r3 = [];
      while (r4 !== peg$FAILED) {
        r3.push(r4);
        choice_4: {
        p8 = peg$currPos;
        r12 = input.charAt(peg$currPos);
        if (/^[^<[{\n\r\t|!\]}{ &\-]/.test(r12)) {
          peg$currPos++;
          r7 = true;
          while (r12 !== peg$FAILED) {
            r12 = input.charAt(peg$currPos);
            if (/^[^<[{\n\r\t|!\]}{ &\-]/.test(r12)) {
              peg$currPos++;
            } else {
              r12 = peg$FAILED;
              if (!silence) {peg$fail(peg$c262);}
            }
          }
        } else {
          r12 = peg$FAILED;
          if (!silence) {peg$fail(peg$c262);}
          r7 = peg$FAILED;
        }
        // t <- r7
        if (r7!== peg$FAILED) {
          r7 = input.substring(p8,peg$currPos);
        } else {
          r7 = peg$FAILED;
        }
        // free r12
        // free p8
        r4 = r7;
        if (r4!== peg$FAILED) {
          break choice_4;
        }
        p8 = peg$currPos;
        seq_3: {
        p9 = peg$currPos;
        p11 = peg$currPos;
        r12 = peg$discardinline_breaks(true);
        if (r12 === peg$FAILED) {
          r12 = void 0;
        } else {
          r12 = peg$FAILED;
          peg$currPos = p11;
          r4 = peg$FAILED;
          break seq_3;
        }
        // free p11
        choice_5: {
        r14 = peg$parsedirective(silence);
        if (r14!== peg$FAILED) {
          break choice_5;
        }
        p11 = peg$currPos;
        seq_4: {
        p13 = peg$currPos;
        p16 = peg$currPos;
        r15 = input.substr(peg$currPos,2);
        if (r15 === "]]") {
          peg$currPos += 2;
        } else {
          r15 = peg$FAILED;
        }
        if (r15 === peg$FAILED) {
          r15 = void 0;
        } else {
          r15 = peg$FAILED;
          peg$currPos = p16;
          r14 = peg$FAILED;
          break seq_4;
        }
        // free p16
        choice_6: {
        r15 = peg$discardtext_char(silence);
        if (r15!== peg$FAILED) {
          break choice_6;
        }
        r15 = input.charAt(peg$currPos);
        if (/^[!<\-}\]\n\r]/.test(r15)) {
          peg$currPos++;
        } else {
          r15 = peg$FAILED;
          if (!silence) {peg$fail(peg$c263);}
        }
        } // choice_6
        if (r15 === peg$FAILED) {
          peg$currPos = p13;
          r14 = peg$FAILED;
          break seq_4;
        }
        r14 = true;
        } // seq_4
        if (r14!== peg$FAILED) {
          r14 = input.substring(p11,peg$currPos);
        } else {
          r14 = peg$FAILED;
        }
        // free r15,p13
        // free p11
        } // choice_5
        // wr <- r14
        r12 = r14;
        if (r12 === peg$FAILED) {
          peg$currPos = p9;
          r4 = peg$FAILED;
          break seq_3;
        }
        r4 = true;
        } // seq_3
        if (r4!== peg$FAILED) {
          peg$savedPos = p8;
          r4 = peg$c264(r3,r7,r14);
        }
        // free r12,p9
        } // choice_4
      }
    } else {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c265(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsewikilink_content(silence) {
    var r1,r2,p3,p4,r5,r6,p7,r8,p9,r10,p11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*57).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = [];
    p3 = peg$currPos;
    seq_1: {
    p4 = peg$currPos;
    r5 = peg$discardpipe(silence);
    if (r5 === peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r6 = '';
    // startPos <- r6
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c266(r6);
    }
    r5 = r6;
    if (r5 === peg$FAILED) {
      peg$currPos = p4;
      r2 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parselink_text(silence);
    if (r8 === peg$FAILED) {
      r8 = null;
    }
    // lt <- r8
    r5 = r8;
    if (r5 === peg$FAILED) {
      peg$currPos = p4;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      peg$savedPos = p3;
      r2 = peg$c267(r6,r8);
    }
    // free r5,p4
    while (r2 !== peg$FAILED) {
      r1.push(r2);
      p4 = peg$currPos;
      seq_2: {
      p9 = peg$currPos;
      r5 = peg$discardpipe(silence);
      if (r5 === peg$FAILED) {
        r2 = peg$FAILED;
        break seq_2;
      }
      p11 = peg$currPos;
      r10 = '';
      // startPos <- r10
      if (r10!== peg$FAILED) {
        peg$savedPos = p11;
        r10 = peg$c266(r10);
      }
      r5 = r10;
      if (r5 === peg$FAILED) {
        peg$currPos = p9;
        r2 = peg$FAILED;
        break seq_2;
      }
      r12 = peg$parselink_text(silence);
      if (r12 === peg$FAILED) {
        r12 = null;
      }
      // lt <- r12
      r5 = r12;
      if (r5 === peg$FAILED) {
        peg$currPos = p9;
        r2 = peg$FAILED;
        break seq_2;
      }
      r2 = true;
      } // seq_2
      if (r2!== peg$FAILED) {
        peg$savedPos = p4;
        r2 = peg$c267(r10,r12);
      }
      // free r5,p9
    }
    // free r2
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_preproc(silence) {
    var r1,p2,p3,r4,r5,p6,r7,p8,p9,r10,r11,p12,p13,r14,r15,p16,r17;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*46).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    // lv0 <- r5
    if (r5 === "-{") {
      peg$currPos += 2;
      peg$savedPos = p6;
      r5 = peg$c269(r5);
    } else {
      if (!silence) {peg$fail(peg$c268);}
      r5 = peg$FAILED;
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    p8 = peg$currPos;
    seq_2: {
    p9 = peg$currPos;
    peg$savedPos = peg$currPos;
    r10 = peg$c270(r5,r7);
    if (r10) {
      r10 = void 0;
    } else {
      r10 = peg$FAILED;
      r7 = peg$FAILED;
      break seq_2;
    }
    r11 = peg$parseopt_lang_variant_flags(silence);
    // ff <- r11
    r10 = r11;
    if (r10 === peg$FAILED) {
      peg$currPos = p9;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = true;
    } // seq_2
    if (r7!== peg$FAILED) {
      peg$savedPos = p8;
      r7 = peg$c271(r5,r7,r11);
      break choice_1;
    }
    // free r10,p9
    p9 = peg$currPos;
    seq_3: {
    p12 = peg$currPos;
    peg$savedPos = peg$currPos;
    r10 = peg$c272(r5,r7);
    if (r10) {
      r10 = void 0;
    } else {
      r10 = peg$FAILED;
      r7 = peg$FAILED;
      break seq_3;
    }
    r10 = '';
    if (r10 === peg$FAILED) {
      peg$currPos = p12;
      r7 = peg$FAILED;
      break seq_3;
    }
    r7 = true;
    } // seq_3
    if (r7!== peg$FAILED) {
      peg$savedPos = p9;
      r7 = peg$c273(r5,r7);
    }
    // free r10,p12
    } // choice_1
    // f <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    p12 = peg$currPos;
    seq_4: {
    p13 = peg$currPos;
    peg$savedPos = peg$currPos;
    r14 = peg$c274(r5,r7,r10);
    if (r14) {
      r14 = void 0;
    } else {
      r14 = peg$FAILED;
      r10 = peg$FAILED;
      break seq_4;
    }
    r15 = peg$parselang_variant_text(silence);
    // lv <- r15
    r14 = r15;
    if (r14 === peg$FAILED) {
      peg$currPos = p13;
      r10 = peg$FAILED;
      break seq_4;
    }
    r10 = true;
    } // seq_4
    if (r10!== peg$FAILED) {
      peg$savedPos = p12;
      r10 = peg$c275(r5,r7,r10,r15);
      break choice_2;
    }
    // free r14,p13
    p13 = peg$currPos;
    seq_5: {
    p16 = peg$currPos;
    peg$savedPos = peg$currPos;
    r14 = peg$c276(r5,r7,r10);
    if (r14) {
      r14 = void 0;
    } else {
      r14 = peg$FAILED;
      r10 = peg$FAILED;
      break seq_5;
    }
    r17 = peg$parselang_variant_option_list(silence);
    // lv <- r17
    r14 = r17;
    if (r14 === peg$FAILED) {
      peg$currPos = p16;
      r10 = peg$FAILED;
      break seq_5;
    }
    r10 = true;
    } // seq_5
    if (r10!== peg$FAILED) {
      peg$savedPos = p13;
      r10 = peg$c277(r5,r7,r10,r17);
    }
    // free r14,p16
    } // choice_2
    // ts <- r10
    r4 = r10;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r4 = peg$discardinline_breaks(silence);
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p16 = peg$currPos;
    r14 = input.substr(peg$currPos,2);
    // lv1 <- r14
    if (r14 === "}-") {
      peg$currPos += 2;
      peg$savedPos = p16;
      r14 = peg$c279(r5,r7,r10,r14);
    } else {
      if (!silence) {peg$fail(peg$c278);}
      r14 = peg$FAILED;
    }
    r4 = r14;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c280(r5,r7,r10,r14);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsebroken_lang_variant(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*44).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c146();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = input.substr(peg$currPos,2);
    // r <- r5
    if (r5 === "-{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c268);}
      r5 = peg$FAILED;
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c32(r5);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsespace_or_nbsp(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*108).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$parsespace(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseunispace(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parsehtmlentity(silence);
    // he <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c281(r5);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c117(r5);
    }
    // free r4,p3
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardend_of_word(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*106).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$discardeof(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    r1 = input.charAt(peg$currPos);
    if (/^[A-Za-z0-9_]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
    }
    if (r1 === peg$FAILED) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
      peg$currPos = p2;
    }
    // free p2
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsespace_or_nbsp_or_dash(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*109).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$parsespace_or_nbsp(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 45) {
      r1 = "-";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c167);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardlist_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*84).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[*#:;]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c282);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselist_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*84).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[*#:;]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c282);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardcomment_space_eolf(silence) {
    var p1,r2,r3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*123).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    seq_1: {
    p1 = peg$currPos;
    choice_1: {
    r5 = peg$discardspace(silence);
    if (r5!== peg$FAILED) {
      r4 = true;
      while (r5 !== peg$FAILED) {
        r5 = peg$discardspace(silence);
      }
    } else {
      r4 = peg$FAILED;
    }
    if (r4!== peg$FAILED) {
      break choice_1;
    }
    // free r5
    r4 = peg$discardcomment(silence);
    } // choice_1
    while (r4 !== peg$FAILED) {
      choice_2: {
      r5 = peg$discardspace(silence);
      if (r5!== peg$FAILED) {
        r4 = true;
        while (r5 !== peg$FAILED) {
          r5 = peg$discardspace(silence);
        }
      } else {
        r4 = peg$FAILED;
      }
      if (r4!== peg$FAILED) {
        break choice_2;
      }
      // free r5
      r4 = peg$discardcomment(silence);
      } // choice_2
    }
    // free r4
    r3 = true;
    if (r3 === peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    r3 = peg$discardeolf(silence);
    if (r3 === peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    // free r2,r3,p1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r2 };
    }
    return r2;
  }

  function peg$discardempty_line_with_comments(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,p10,r11,r12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*114).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parsesol_prefix(silence);
    // sp <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r6 = '';
    // p <- r6
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c194(r5,r6);
    }
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p10 = peg$currPos;
    r11 = [];
    r12 = peg$parsespace(silence);
    while (r12 !== peg$FAILED) {
      r11.push(r12);
      r12 = peg$parsespace(silence);
    }
    // free r12
    r12 = peg$parsecomment(silence);
    if (r12 === peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_2;
    }
    r13 = [];
    choice_1: {
    r14 = peg$parsespace(silence);
    if (r14!== peg$FAILED) {
      break choice_1;
    }
    r14 = peg$parsecomment(silence);
    } // choice_1
    while (r14 !== peg$FAILED) {
      r13.push(r14);
      choice_2: {
      r14 = peg$parsespace(silence);
      if (r14!== peg$FAILED) {
        break choice_2;
      }
      r14 = peg$parsecomment(silence);
      } // choice_2
    }
    // free r14
    r14 = peg$parsenewline(silence);
    if (r14 === peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_2;
    }
    r9 = [r11,r12,r13,r14];
    } // seq_2
    if (r9!== peg$FAILED) {
      r8 = [];
      while (r9 !== peg$FAILED) {
        r8.push(r9);
        seq_3: {
        p10 = peg$currPos;
        r14 = [];
        r13 = peg$parsespace(silence);
        while (r13 !== peg$FAILED) {
          r14.push(r13);
          r13 = peg$parsespace(silence);
        }
        // free r13
        r13 = peg$parsecomment(silence);
        if (r13 === peg$FAILED) {
          peg$currPos = p10;
          r9 = peg$FAILED;
          break seq_3;
        }
        r12 = [];
        choice_3: {
        r11 = peg$parsespace(silence);
        if (r11!== peg$FAILED) {
          break choice_3;
        }
        r11 = peg$parsecomment(silence);
        } // choice_3
        while (r11 !== peg$FAILED) {
          r12.push(r11);
          choice_4: {
          r11 = peg$parsespace(silence);
          if (r11!== peg$FAILED) {
            break choice_4;
          }
          r11 = peg$parsecomment(silence);
          } // choice_4
        }
        // free r11
        r11 = peg$parsenewline(silence);
        if (r11 === peg$FAILED) {
          peg$currPos = p10;
          r9 = peg$FAILED;
          break seq_3;
        }
        r9 = [r14,r13,r12,r11];
        } // seq_3
        // free r14,r13,r12,r11,p10
      }
    } else {
      r8 = peg$FAILED;
    }
    // free r11,r12,r13,r14,p10
    // c <- r8
    // free r9
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c195(r5,r6,r8);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardsol_prefix(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*113).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$discardnewlineToken(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    peg$savedPos = peg$currPos;
    r1 = peg$c196();
    if (r1) {
      r1 = void 0;
      peg$savedPos = p2;
      r1 = peg$c197();
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardcomment_or_includes(silence) {
    var r1,r2,p3,p4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*111).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r2 = peg$discardcomment(silence);
    if (r2!== peg$FAILED) {
      break choice_1;
    }
    choice_2: {
    p3 = peg$currPos;
    seq_1: {
    p4 = peg$currPos;
    peg$savedPos = peg$currPos;
    r5 = peg$c125();
    if (r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parseinclude_limits(silence);
    // i <- r6
    r5 = r6;
    if (r5 === peg$FAILED) {
      peg$currPos = p4;
      r2 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r5 = peg$c126(r6);
    if (r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      peg$savedPos = p3;
      r2 = peg$c127(r6);
      break choice_2;
    }
    // free r5,p4
    peg$savedPos = peg$currPos;
    r2 = peg$c128();
    if (r2) {
      r2 = void 0;
    } else {
      r2 = peg$FAILED;
    }
    } // choice_2
    } // choice_1
    while (r2 !== peg$FAILED) {
      choice_3: {
      r2 = peg$discardcomment(silence);
      if (r2!== peg$FAILED) {
        break choice_3;
      }
      choice_4: {
      p4 = peg$currPos;
      seq_2: {
      p7 = peg$currPos;
      peg$savedPos = peg$currPos;
      r5 = peg$c125();
      if (r5) {
        r5 = void 0;
      } else {
        r5 = peg$FAILED;
        r2 = peg$FAILED;
        break seq_2;
      }
      r8 = peg$parseinclude_limits(silence);
      // i <- r8
      r5 = r8;
      if (r5 === peg$FAILED) {
        peg$currPos = p7;
        r2 = peg$FAILED;
        break seq_2;
      }
      peg$savedPos = peg$currPos;
      r5 = peg$c126(r8);
      if (r5) {
        r5 = void 0;
      } else {
        r5 = peg$FAILED;
        peg$currPos = p7;
        r2 = peg$FAILED;
        break seq_2;
      }
      r2 = true;
      } // seq_2
      if (r2!== peg$FAILED) {
        peg$savedPos = p4;
        r2 = peg$c127(r8);
        break choice_4;
      }
      // free r5,p7
      peg$savedPos = peg$currPos;
      r2 = peg$c128();
      if (r2) {
        r2 = void 0;
      } else {
        r2 = peg$FAILED;
      }
      } // choice_4
      } // choice_3
    }
    // free r2
    r1 = true;
    // free r1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_heading_tags(silence) {
    var r1,p2,p3,r4,r5,r6,r7,p8,p9,r10,r11,r12,p13,r14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*94).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 33) {
      r4 = "!";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c283);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c284();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsetable_heading_tag(silence);
    // th <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = [];
    p8 = peg$currPos;
    seq_2: {
    p9 = peg$currPos;
    choice_2: {
    r11 = input.substr(peg$currPos,2);
    if (r11 === "!!") {
      peg$currPos += 2;
      break choice_2;
    } else {
      if (!silence) {peg$fail(peg$c285);}
      r11 = peg$FAILED;
    }
    r11 = peg$parsepipe_pipe(silence);
    } // choice_2
    // pp <- r11
    r10 = r11;
    if (r10 === peg$FAILED) {
      r7 = peg$FAILED;
      break seq_2;
    }
    r12 = peg$parsetable_heading_tag(silence);
    // tht <- r12
    r10 = r12;
    if (r10 === peg$FAILED) {
      peg$currPos = p9;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = true;
    } // seq_2
    if (r7!== peg$FAILED) {
      peg$savedPos = p8;
      r7 = peg$c286(r5,r6,r11,r12);
    }
    // free r10,p9
    while (r7 !== peg$FAILED) {
      r6.push(r7);
      p9 = peg$currPos;
      seq_3: {
      p13 = peg$currPos;
      choice_3: {
      r14 = input.substr(peg$currPos,2);
      if (r14 === "!!") {
        peg$currPos += 2;
        break choice_3;
      } else {
        if (!silence) {peg$fail(peg$c285);}
        r14 = peg$FAILED;
      }
      r14 = peg$parsepipe_pipe(silence);
      } // choice_3
      // pp <- r14
      r10 = r14;
      if (r10 === peg$FAILED) {
        r7 = peg$FAILED;
        break seq_3;
      }
      r15 = peg$parsetable_heading_tag(silence);
      // tht <- r15
      r10 = r15;
      if (r10 === peg$FAILED) {
        peg$currPos = p13;
        r7 = peg$FAILED;
        break seq_3;
      }
      r7 = true;
      } // seq_3
      if (r7!== peg$FAILED) {
        peg$savedPos = p9;
        r7 = peg$c286(r5,r6,r14,r15);
      }
      // free r10,p13
    }
    // ths <- r6
    // free r7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c287(r5,r6);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c288();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_row_tag(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*90).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c289();
    if (!r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsepipe(silence);
    // p <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      r8 = "-";
      peg$currPos += 1;
      r6 = true;
      while (r8 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          r8 = "-";
          peg$currPos += 1;
        } else {
          if (!silence) {peg$fail(peg$c167);}
          r8 = peg$FAILED;
        }
      }
    } else {
      if (!silence) {peg$fail(peg$c167);}
      r8 = peg$FAILED;
      r6 = peg$FAILED;
    }
    // dashes <- r6
    if (r6!== peg$FAILED) {
      r6 = input.substring(p7,peg$currPos);
    } else {
      r6 = peg$FAILED;
    }
    // free r8
    // free p7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c290(r5,r6);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r8 = peg$parsetable_attributes(silence);
    if (r8!== peg$FAILED) {
      break choice_1;
    }
    peg$savedPos = peg$currPos;
    r8 = peg$c291(r5,r6,r8);
    if (r8) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
    }
    } // choice_1
    // a <- r8
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r9 = '';
    // tagEndPos <- r9
    if (r9!== peg$FAILED) {
      peg$savedPos = p7;
      r9 = peg$c292(r5,r6,r8,r9);
    }
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c293(r5,r6,r8,r9);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_data_tags(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*92).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c289();
    if (!r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsepipe(silence);
    // p <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[+\-]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
    }
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p6;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r7 = peg$parsetable_data_tag(silence);
    // td <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r8 = '';
    // tagEndPos <- r8
    if (r8!== peg$FAILED) {
      peg$savedPos = p6;
      r8 = peg$c294(r5,r7,r8);
    }
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$parsetds(silence);
    // tds <- r9
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c295(r5,r7,r8,r9);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_caption_tag(silence) {
    var r1,p2,p3,r4,r5,r6,r7,p8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*89).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c289();
    if (!r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsepipe(silence);
    // p <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 43) {
      r4 = "+";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c296);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parserow_syntax_table_args(silence);
    if (r6 === peg$FAILED) {
      r6 = null;
    }
    // args <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p8 = peg$currPos;
    r7 = '';
    // tagEndPos <- r7
    if (r7!== peg$FAILED) {
      peg$savedPos = p8;
      r7 = peg$c297(r5,r6,r7);
    }
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = [];
    r10 = peg$parsenested_block_in_table(silence);
    while (r10 !== peg$FAILED) {
      r9.push(r10);
      r10 = peg$parsenested_block_in_table(silence);
    }
    // c <- r9
    // free r10
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c298(r5,r6,r7,r9);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetemplate_param_text(silence) {
    var r1,p2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*42).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c299();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    r6 = peg$parsenested_block(silence);
    if (r6!== peg$FAILED) {
      break choice_2;
    }
    r6 = peg$parsenewlineToken(silence);
    } // choice_2
    if (r6!== peg$FAILED) {
      r5 = [];
      while (r6 !== peg$FAILED) {
        r5.push(r6);
        choice_3: {
        r6 = peg$parsenested_block(silence);
        if (r6!== peg$FAILED) {
          break choice_3;
        }
        r6 = peg$parsenewlineToken(silence);
        } // choice_3
      }
    } else {
      r5 = peg$FAILED;
    }
    // il <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c300(r5);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c301();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardcomment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*115).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$discardcomment(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardspace(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsecomment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*115).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = peg$parsecomment(silence);
    if (r1!== peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsespace(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetemplate_param_name(silence) {
    var r1,p2,p3,r4,r5,p6,p7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*40).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c302();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    r5 = peg$parsetemplate_param_text(silence);
    if (r5!== peg$FAILED) {
      break choice_2;
    }
    p6 = peg$currPos;
    p7 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      r5 = "=";
      peg$currPos += 1;
      r5 = void 0;
      peg$currPos = p7;
      peg$savedPos = p6;
      r5 = peg$c303(r5);
    } else {
      r5 = peg$FAILED;
    }
    // free p7
    } // choice_2
    // tpt <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c304(r5);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c256();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardtext_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*98).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[^\-'<~[{\n\r:;\]}|!=]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c176);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselink_text(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,p10,p11,r12,r13,r14,r15,p16,p17,p18,r19,p20;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*61).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c305();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    seq_2: {
    p7 = peg$currPos;
    r8 = peg$parsesol(silence);
    if (r8 === peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    choice_3: {
    r9 = peg$parseheading(silence);
    if (r9!== peg$FAILED) {
      break choice_3;
    }
    r9 = peg$parsehr(silence);
    if (r9!== peg$FAILED) {
      break choice_3;
    }
    r9 = peg$parsefull_table_in_link_caption(silence);
    } // choice_3
    if (r9 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = [r8,r9];
    } // seq_2
    if (r6!== peg$FAILED) {
      break choice_2;
    }
    // free r8,r9,p7
    r6 = peg$parseurltext(silence);
    if (r6!== peg$FAILED) {
      break choice_2;
    }
    p7 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    p11 = peg$currPos;
    r9 = peg$discardinline_breaks(true);
    if (r9 === peg$FAILED) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p11;
      r6 = peg$FAILED;
      break seq_3;
    }
    // free p11
    choice_4: {
    r8 = peg$parseinline_element(silence);
    if (r8!== peg$FAILED) {
      break choice_4;
    }
    seq_4: {
    p11 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r12 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c50);}
      r12 = peg$FAILED;
      r8 = peg$FAILED;
      break seq_4;
    }
    r14 = peg$parsetext_char(silence);
    if (r14!== peg$FAILED) {
      r13 = [];
      while (r14 !== peg$FAILED) {
        r13.push(r14);
        r14 = peg$parsetext_char(silence);
      }
    } else {
      r13 = peg$FAILED;
    }
    if (r13 === peg$FAILED) {
      peg$currPos = p11;
      r8 = peg$FAILED;
      break seq_4;
    }
    // free r14
    if (input.charCodeAt(peg$currPos) === 93) {
      r14 = "]";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c52);}
      r14 = peg$FAILED;
      peg$currPos = p11;
      r8 = peg$FAILED;
      break seq_4;
    }
    p16 = peg$currPos;
    p17 = peg$currPos;
    choice_5: {
    p18 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 93) {
      r15 = "]";
      peg$currPos += 1;
    } else {
      r15 = peg$FAILED;
    }
    if (r15 === peg$FAILED) {
      r15 = void 0;
      break choice_5;
    } else {
      r15 = peg$FAILED;
      peg$currPos = p18;
    }
    // free p18
    r15 = input.substr(peg$currPos,2);
    if (r15 === "]]") {
      peg$currPos += 2;
    } else {
      r15 = peg$FAILED;
    }
    } // choice_5
    if (r15!== peg$FAILED) {
      r15 = void 0;
      peg$currPos = p17;
      r15 = input.substring(p16,peg$currPos);
    } else {
      r15 = peg$FAILED;
      peg$currPos = p11;
      r8 = peg$FAILED;
      break seq_4;
    }
    // free p17
    // free p16
    r8 = [r12,r13,r14,r15];
    } // seq_4
    if (r8!== peg$FAILED) {
      break choice_4;
    }
    // free r12,r13,r14,r15,p11
    if (peg$currPos < input.length) {
      r8 = input.charAt(peg$currPos++);
    } else {
      r8 = peg$FAILED;
      if (!silence) {peg$fail(peg$c39);}
    }
    } // choice_4
    // r <- r8
    r9 = r8;
    if (r9 === peg$FAILED) {
      peg$currPos = p10;
      r6 = peg$FAILED;
      break seq_3;
    }
    r6 = true;
    } // seq_3
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c80(r5,r8);
    }
    // free r9,p10
    } // choice_2
    if (r6!== peg$FAILED) {
      r5 = [];
      while (r6 !== peg$FAILED) {
        r5.push(r6);
        choice_6: {
        seq_5: {
        p10 = peg$currPos;
        r9 = peg$parsesol(silence);
        if (r9 === peg$FAILED) {
          r6 = peg$FAILED;
          break seq_5;
        }
        choice_7: {
        r15 = peg$parseheading(silence);
        if (r15!== peg$FAILED) {
          break choice_7;
        }
        r15 = peg$parsehr(silence);
        if (r15!== peg$FAILED) {
          break choice_7;
        }
        r15 = peg$parsefull_table_in_link_caption(silence);
        } // choice_7
        if (r15 === peg$FAILED) {
          peg$currPos = p10;
          r6 = peg$FAILED;
          break seq_5;
        }
        r6 = [r9,r15];
        } // seq_5
        if (r6!== peg$FAILED) {
          break choice_6;
        }
        // free r9,r15,p10
        r6 = peg$parseurltext(silence);
        if (r6!== peg$FAILED) {
          break choice_6;
        }
        p10 = peg$currPos;
        seq_6: {
        p11 = peg$currPos;
        p16 = peg$currPos;
        r15 = peg$discardinline_breaks(true);
        if (r15 === peg$FAILED) {
          r15 = void 0;
        } else {
          r15 = peg$FAILED;
          peg$currPos = p16;
          r6 = peg$FAILED;
          break seq_6;
        }
        // free p16
        choice_8: {
        r9 = peg$parseinline_element(silence);
        if (r9!== peg$FAILED) {
          break choice_8;
        }
        seq_7: {
        p16 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          r14 = "[";
          peg$currPos += 1;
        } else {
          if (!silence) {peg$fail(peg$c50);}
          r14 = peg$FAILED;
          r9 = peg$FAILED;
          break seq_7;
        }
        r12 = peg$parsetext_char(silence);
        if (r12!== peg$FAILED) {
          r13 = [];
          while (r12 !== peg$FAILED) {
            r13.push(r12);
            r12 = peg$parsetext_char(silence);
          }
        } else {
          r13 = peg$FAILED;
        }
        if (r13 === peg$FAILED) {
          peg$currPos = p16;
          r9 = peg$FAILED;
          break seq_7;
        }
        // free r12
        if (input.charCodeAt(peg$currPos) === 93) {
          r12 = "]";
          peg$currPos += 1;
        } else {
          if (!silence) {peg$fail(peg$c52);}
          r12 = peg$FAILED;
          peg$currPos = p16;
          r9 = peg$FAILED;
          break seq_7;
        }
        p17 = peg$currPos;
        p18 = peg$currPos;
        choice_9: {
        p20 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 93) {
          r19 = "]";
          peg$currPos += 1;
        } else {
          r19 = peg$FAILED;
        }
        if (r19 === peg$FAILED) {
          r19 = void 0;
          break choice_9;
        } else {
          r19 = peg$FAILED;
          peg$currPos = p20;
        }
        // free p20
        r19 = input.substr(peg$currPos,2);
        if (r19 === "]]") {
          peg$currPos += 2;
        } else {
          r19 = peg$FAILED;
        }
        } // choice_9
        if (r19!== peg$FAILED) {
          r19 = void 0;
          peg$currPos = p18;
          r19 = input.substring(p17,peg$currPos);
        } else {
          r19 = peg$FAILED;
          peg$currPos = p16;
          r9 = peg$FAILED;
          break seq_7;
        }
        // free p18
        // free p17
        r9 = [r14,r13,r12,r19];
        } // seq_7
        if (r9!== peg$FAILED) {
          break choice_8;
        }
        // free r14,r13,r12,r19,p16
        if (peg$currPos < input.length) {
          r9 = input.charAt(peg$currPos++);
        } else {
          r9 = peg$FAILED;
          if (!silence) {peg$fail(peg$c39);}
        }
        } // choice_8
        // r <- r9
        r15 = r9;
        if (r15 === peg$FAILED) {
          peg$currPos = p11;
          r6 = peg$FAILED;
          break seq_6;
        }
        r6 = true;
        } // seq_6
        if (r6!== peg$FAILED) {
          peg$savedPos = p10;
          r6 = peg$c80(r5,r9);
        }
        // free r15,p11
        } // choice_6
      }
    } else {
      r5 = peg$FAILED;
    }
    // c <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c306(r5);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c307();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseopt_lang_variant_flags(silence) {
    var r1,p2,r3,p4,p5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*47).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    r7 = peg$parselang_variant_flags(silence);
    // ff <- r7
    r6 = r7;
    if (r6 === peg$FAILED) {
      r3 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 124) {
      r6 = "|";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r6 = peg$FAILED;
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    if (r3!== peg$FAILED) {
      peg$savedPos = p4;
      r3 = peg$c308(r3,r7);
    } else {
      r3 = null;
    }
    // free r6,p5
    // f <- r3
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c309(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_text(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*54).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = '';
    // start <- r5
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c310(r5);
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    choice_1: {
    r8 = peg$parseinlineline(silence);
    if (r8!== peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 124) {
      r8 = "|";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r8 = peg$FAILED;
    }
    } // choice_1
    while (r8 !== peg$FAILED) {
      r7.push(r8);
      choice_2: {
      r8 = peg$parseinlineline(silence);
      if (r8!== peg$FAILED) {
        break choice_2;
      }
      if (input.charCodeAt(peg$currPos) === 124) {
        r8 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c42);}
        r8 = peg$FAILED;
      }
      } // choice_2
    }
    // tokens <- r7
    // free r8
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p9 = peg$currPos;
    r8 = '';
    // end <- r8
    if (r8!== peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$c311(r5,r7,r8);
    }
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c312(r5,r7,r8);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_option_list(silence) {
    var r1,p2,p3,r4,r5,r6,r7,p8,p9,r10,r11,p12,r13,r14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*51).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parselang_variant_option(silence);
    // o <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = [];
    p8 = peg$currPos;
    seq_2: {
    p9 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 59) {
      r10 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c97);}
      r10 = peg$FAILED;
      r7 = peg$FAILED;
      break seq_2;
    }
    r11 = peg$parselang_variant_option(silence);
    // oo <- r11
    r10 = r11;
    if (r10 === peg$FAILED) {
      peg$currPos = p9;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = true;
    } // seq_2
    if (r7!== peg$FAILED) {
      peg$savedPos = p8;
      r7 = peg$c313(r5,r6,r11);
    }
    // free r10,p9
    while (r7 !== peg$FAILED) {
      r6.push(r7);
      p9 = peg$currPos;
      seq_3: {
      p12 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        r10 = ";";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c97);}
        r10 = peg$FAILED;
        r7 = peg$FAILED;
        break seq_3;
      }
      r13 = peg$parselang_variant_option(silence);
      // oo <- r13
      r10 = r13;
      if (r10 === peg$FAILED) {
        peg$currPos = p12;
        r7 = peg$FAILED;
        break seq_3;
      }
      r7 = true;
      } // seq_3
      if (r7!== peg$FAILED) {
        peg$savedPos = p9;
        r7 = peg$c313(r5,r6,r13);
      }
      // free r10,p12
    }
    // rest <- r6
    // free r7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_4: {
    p12 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 59) {
      r10 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c97);}
      r10 = peg$FAILED;
      r7 = peg$FAILED;
      break seq_4;
    }
    r14 = [];
    r15 = peg$parsespace_or_newline(silence);
    while (r15 !== peg$FAILED) {
      r14.push(r15);
      r15 = peg$parsespace_or_newline(silence);
    }
    // free r15
    r7 = [r10,r14];
    } // seq_4
    if (r7 === peg$FAILED) {
      r7 = null;
    }
    // free r10,r14,p12
    // tr <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c314(r5,r6,r7);
      break choice_1;
    }
    // free r4,p3
    p3 = peg$currPos;
    r4 = peg$parselang_variant_text(silence);
    // lvtext <- r4
    r1 = r4;
    if (r1!== peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$c315(r4);
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parseunispace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*107).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c78);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardcomment(silence) {
    var r1,p2,p3,r4,r5,p6,r7,p8,r9,p10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*19).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "<!--") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c38);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    p10 = peg$currPos;
    r9 = input.substr(peg$currPos,3);
    if (r9 === "-->") {
      peg$currPos += 3;
    } else {
      r9 = peg$FAILED;
    }
    if (r9 === peg$FAILED) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      peg$currPos = p10;
      r7 = peg$FAILED;
      break seq_2;
    }
    // free p10
    if (peg$currPos < input.length) {
      r9 = input.charAt(peg$currPos++);
    } else {
      r9 = peg$FAILED;
      if (!silence) {peg$fail(peg$c39);}
      peg$currPos = p8;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = true;
    } // seq_2
    // free r9,p8
    while (r7 !== peg$FAILED) {
      seq_3: {
      p8 = peg$currPos;
      p10 = peg$currPos;
      r9 = input.substr(peg$currPos,3);
      if (r9 === "-->") {
        peg$currPos += 3;
      } else {
        r9 = peg$FAILED;
      }
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p10;
        r7 = peg$FAILED;
        break seq_3;
      }
      // free p10
      if (peg$currPos < input.length) {
        r9 = input.charAt(peg$currPos++);
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c39);}
        peg$currPos = p8;
        r7 = peg$FAILED;
        break seq_3;
      }
      r7 = true;
      } // seq_3
      // free r9,p8
    }
    // free r7
    r5 = true;
    // c <- r5
    if (r5!== peg$FAILED) {
      r5 = input.substring(p6,peg$currPos);
    } else {
      r5 = peg$FAILED;
    }
    // free p6
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r4 = input.substr(peg$currPos,3);
    if (r4 === "-->") {
      peg$currPos += 3;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c40);}
      r4 = peg$FAILED;
    }
    r4 = peg$discardeof(silence);
    } // choice_1
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c41(r5);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_heading_tag(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,p10,p11,r12,r13,p14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*95).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parserow_syntax_table_args(silence);
    if (r5 === peg$FAILED) {
      r5 = null;
    }
    // arg <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r6 = '';
    // tagEndPos <- r6
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c316(r5,r6);
    }
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = [];
    p10 = peg$currPos;
    seq_2: {
    p11 = peg$currPos;
    peg$savedPos = peg$currPos;
    r12 = peg$c317(r5,r6,r8);
    if (r12) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      r9 = peg$FAILED;
      break seq_2;
    }
    r13 = peg$parsenested_block_in_table(silence);
    // d <- r13
    r12 = r13;
    if (r12 === peg$FAILED) {
      peg$currPos = p11;
      r9 = peg$FAILED;
      break seq_2;
    }
    r9 = true;
    } // seq_2
    if (r9!== peg$FAILED) {
      peg$savedPos = p10;
      r9 = peg$c318(r5,r6,r8,r13);
    }
    // free r12,p11
    while (r9 !== peg$FAILED) {
      r8.push(r9);
      p11 = peg$currPos;
      seq_3: {
      p14 = peg$currPos;
      peg$savedPos = peg$currPos;
      r12 = peg$c317(r5,r6,r8);
      if (r12) {
        r12 = void 0;
      } else {
        r12 = peg$FAILED;
        r9 = peg$FAILED;
        break seq_3;
      }
      r15 = peg$parsenested_block_in_table(silence);
      // d <- r15
      r12 = r15;
      if (r12 === peg$FAILED) {
        peg$currPos = p14;
        r9 = peg$FAILED;
        break seq_3;
      }
      r9 = true;
      } // seq_3
      if (r9!== peg$FAILED) {
        peg$savedPos = p11;
        r9 = peg$c318(r5,r6,r8,r15);
      }
      // free r12,p14
    }
    // c <- r8
    // free r9
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c319(r5,r6,r8);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsepipe_pipe(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*134).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    r1 = input.substr(peg$currPos,2);
    if (r1 === "||") {
      peg$currPos += 2;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c320);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,10);
    if (r1 === "{{!}}{{!}}") {
      peg$currPos += 10;
    } else {
      if (!silence) {peg$fail(peg$c321);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetable_data_tag(silence) {
    var r1,p2,p3,r4,p5,r6,r7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*93).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 125) {
      r4 = "}";
      peg$currPos += 1;
    } else {
      r4 = peg$FAILED;
    }
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r6 = peg$parserow_syntax_table_args(silence);
    if (r6 === peg$FAILED) {
      r6 = null;
    }
    // arg <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    r7 = '';
    // tagEndPos <- r7
    if (r7!== peg$FAILED) {
      peg$savedPos = p5;
      r7 = peg$c316(r6,r7);
    }
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = [];
    r9 = peg$parsenested_block_in_table(silence);
    while (r9 !== peg$FAILED) {
      r8.push(r9);
      r9 = peg$parsenested_block_in_table(silence);
    }
    // td <- r8
    // free r9
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c322(r6,r7,r8);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsetds(silence) {
    var r1,r2,p3,p4,r5,r6,p7,p8,r9,r10,p11,r12,p13,r14,r15,p16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*91).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = [];
    p3 = peg$currPos;
    seq_1: {
    p4 = peg$currPos;
    choice_1: {
    r6 = peg$parsepipe_pipe(silence);
    if (r6!== peg$FAILED) {
      break choice_1;
    }
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    r10 = peg$parsepipe(silence);
    // p <- r10
    r9 = r10;
    if (r9 === peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    p11 = peg$currPos;
    r9 = peg$discardrow_syntax_table_args(true);
    if (r9!== peg$FAILED) {
      r9 = void 0;
      peg$currPos = p11;
    } else {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free p11
    r6 = true;
    } // seq_2
    if (r6!== peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$c323(r6,r10);
    }
    // free r9,p8
    } // choice_1
    // pp <- r6
    r5 = r6;
    if (r5 === peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$parsetable_data_tag(silence);
    // tdt <- r9
    r5 = r9;
    if (r5 === peg$FAILED) {
      peg$currPos = p4;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!== peg$FAILED) {
      peg$savedPos = p3;
      r2 = peg$c324(r6,r9);
    }
    // free r5,p4
    while (r2 !== peg$FAILED) {
      r1.push(r2);
      p4 = peg$currPos;
      seq_3: {
      p8 = peg$currPos;
      choice_2: {
      r12 = peg$parsepipe_pipe(silence);
      if (r12!== peg$FAILED) {
        break choice_2;
      }
      p11 = peg$currPos;
      seq_4: {
      p13 = peg$currPos;
      r15 = peg$parsepipe(silence);
      // p <- r15
      r14 = r15;
      if (r14 === peg$FAILED) {
        r12 = peg$FAILED;
        break seq_4;
      }
      p16 = peg$currPos;
      r14 = peg$discardrow_syntax_table_args(true);
      if (r14!== peg$FAILED) {
        r14 = void 0;
        peg$currPos = p16;
      } else {
        peg$currPos = p13;
        r12 = peg$FAILED;
        break seq_4;
      }
      // free p16
      r12 = true;
      } // seq_4
      if (r12!== peg$FAILED) {
        peg$savedPos = p11;
        r12 = peg$c323(r12,r15);
      }
      // free r14,p13
      } // choice_2
      // pp <- r12
      r5 = r12;
      if (r5 === peg$FAILED) {
        r2 = peg$FAILED;
        break seq_3;
      }
      r14 = peg$parsetable_data_tag(silence);
      // tdt <- r14
      r5 = r14;
      if (r5 === peg$FAILED) {
        peg$currPos = p8;
        r2 = peg$FAILED;
        break seq_3;
      }
      r2 = true;
      } // seq_3
      if (r2!== peg$FAILED) {
        peg$savedPos = p4;
        r2 = peg$c324(r12,r14);
      }
      // free r5,p8
    }
    // free r2
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsenested_block_in_table(silence) {
    var r1,p2,p3,r4,p5,p6,r7,p8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*9).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c325();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    r7 = peg$discardsol(true);
    if (r7 === peg$FAILED) {
      r4 = peg$FAILED;
      break seq_2;
    }
    seq_3: {
    p8 = peg$currPos;
    r10 = peg$discardspace(true);
    while (r10 !== peg$FAILED) {
      r10 = peg$discardspace(true);
    }
    // free r10
    r9 = true;
    if (r9 === peg$FAILED) {
      r7 = peg$FAILED;
      break seq_3;
    }
    r9 = peg$discardsol(true);
    if (r9 === peg$FAILED) {
      peg$currPos = p8;
      r7 = peg$FAILED;
      break seq_3;
    }
    r7 = true;
    } // seq_3
    if (r7 === peg$FAILED) {
      r7 = null;
    }
    // free r9,p8
    r9 = peg$discardspace(true);
    while (r9 !== peg$FAILED) {
      r9 = peg$discardspace(true);
    }
    // free r9
    r7 = true;
    if (r7 === peg$FAILED) {
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    choice_2: {
    r7 = peg$discardpipe(true);
    if (r7!== peg$FAILED) {
      break choice_2;
    }
    if (input.charCodeAt(peg$currPos) === 33) {
      r7 = "!";
      peg$currPos += 1;
    } else {
      r7 = peg$FAILED;
    }
    } // choice_2
    if (r7 === peg$FAILED) {
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    r4 = true;
    } // seq_2
    // free r7,p6
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r7 = peg$parsenested_block(silence);
    // b <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c326(r7);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c327();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsenested_block(silence) {
    var r1,p2,p3,r4,p5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*8).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = peg$discardinline_breaks(true);
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r6 = peg$parseblock(silence);
    // b <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c19(r6);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsefull_table_in_link_caption(silence) {
    var r1,p2,p3,r4,p5,r6,p7,r8,r9,p10,r11,r12,r13,r14,p15,r16,r17,p18,r19,r20,r21;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*85).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    choice_1: {
    p5 = peg$currPos;
    r4 = peg$discardinline_breaks(true);
    if (r4 === peg$FAILED) {
      r4 = void 0;
      break choice_1;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
    }
    // free p5
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,5);
    if (r4 === "{{!}}") {
      peg$currPos += 5;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
    }
    // free p5
    } // choice_1
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    p5 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    peg$savedPos = peg$currPos;
    r8 = peg$c328(r6);
    if (r8) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_2;
    }
    seq_3: {
    p10 = peg$currPos;
    r11 = peg$parsetable_start_tag(silence);
    if (r11 === peg$FAILED) {
      r9 = peg$FAILED;
      break seq_3;
    }
    r12 = peg$parseoptionalNewlines(silence);
    if (r12 === peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    seq_4: {
    p15 = peg$currPos;
    r16 = [];
    seq_5: {
    p18 = peg$currPos;
    r19 = peg$parsesol(silence);
    if (r19 === peg$FAILED) {
      r17 = peg$FAILED;
      break seq_5;
    }
    choice_3: {
    r20 = peg$parsetable_content_line(silence);
    if (r20!== peg$FAILED) {
      break choice_3;
    }
    r20 = peg$parsetplarg_or_template(silence);
    } // choice_3
    if (r20 === peg$FAILED) {
      peg$currPos = p18;
      r17 = peg$FAILED;
      break seq_5;
    }
    r21 = peg$parseoptionalNewlines(silence);
    if (r21 === peg$FAILED) {
      peg$currPos = p18;
      r17 = peg$FAILED;
      break seq_5;
    }
    r17 = [r19,r20,r21];
    } // seq_5
    // free r19,r20,r21,p18
    while (r17 !== peg$FAILED) {
      r16.push(r17);
      seq_6: {
      p18 = peg$currPos;
      r21 = peg$parsesol(silence);
      if (r21 === peg$FAILED) {
        r17 = peg$FAILED;
        break seq_6;
      }
      choice_4: {
      r20 = peg$parsetable_content_line(silence);
      if (r20!== peg$FAILED) {
        break choice_4;
      }
      r20 = peg$parsetplarg_or_template(silence);
      } // choice_4
      if (r20 === peg$FAILED) {
        peg$currPos = p18;
        r17 = peg$FAILED;
        break seq_6;
      }
      r19 = peg$parseoptionalNewlines(silence);
      if (r19 === peg$FAILED) {
        peg$currPos = p18;
        r17 = peg$FAILED;
        break seq_6;
      }
      r17 = [r21,r20,r19];
      } // seq_6
      // free r21,r20,r19,p18
    }
    // free r17
    r17 = peg$parsesol(silence);
    if (r17 === peg$FAILED) {
      peg$currPos = p15;
      r14 = peg$FAILED;
      break seq_4;
    }
    r19 = peg$parsetable_end_tag(silence);
    if (r19 === peg$FAILED) {
      peg$currPos = p15;
      r14 = peg$FAILED;
      break seq_4;
    }
    r14 = [r16,r17,r19];
    } // seq_4
    if (r14!== peg$FAILED) {
      r13 = [];
      while (r14 !== peg$FAILED) {
        r13.push(r14);
        seq_7: {
        p15 = peg$currPos;
        r19 = [];
        seq_8: {
        p18 = peg$currPos;
        r16 = peg$parsesol(silence);
        if (r16 === peg$FAILED) {
          r17 = peg$FAILED;
          break seq_8;
        }
        choice_5: {
        r20 = peg$parsetable_content_line(silence);
        if (r20!== peg$FAILED) {
          break choice_5;
        }
        r20 = peg$parsetplarg_or_template(silence);
        } // choice_5
        if (r20 === peg$FAILED) {
          peg$currPos = p18;
          r17 = peg$FAILED;
          break seq_8;
        }
        r21 = peg$parseoptionalNewlines(silence);
        if (r21 === peg$FAILED) {
          peg$currPos = p18;
          r17 = peg$FAILED;
          break seq_8;
        }
        r17 = [r16,r20,r21];
        } // seq_8
        // free r16,r20,r21,p18
        while (r17 !== peg$FAILED) {
          r19.push(r17);
          seq_9: {
          p18 = peg$currPos;
          r21 = peg$parsesol(silence);
          if (r21 === peg$FAILED) {
            r17 = peg$FAILED;
            break seq_9;
          }
          choice_6: {
          r20 = peg$parsetable_content_line(silence);
          if (r20!== peg$FAILED) {
            break choice_6;
          }
          r20 = peg$parsetplarg_or_template(silence);
          } // choice_6
          if (r20 === peg$FAILED) {
            peg$currPos = p18;
            r17 = peg$FAILED;
            break seq_9;
          }
          r16 = peg$parseoptionalNewlines(silence);
          if (r16 === peg$FAILED) {
            peg$currPos = p18;
            r17 = peg$FAILED;
            break seq_9;
          }
          r17 = [r21,r20,r16];
          } // seq_9
          // free r21,r20,r16,p18
        }
        // free r17
        r17 = peg$parsesol(silence);
        if (r17 === peg$FAILED) {
          peg$currPos = p15;
          r14 = peg$FAILED;
          break seq_7;
        }
        r16 = peg$parsetable_end_tag(silence);
        if (r16 === peg$FAILED) {
          peg$currPos = p15;
          r14 = peg$FAILED;
          break seq_7;
        }
        r14 = [r19,r17,r16];
        } // seq_7
        // free r19,r17,r16,p15
      }
    } else {
      r13 = peg$FAILED;
    }
    // free r16,r17,r19,p15
    if (r13 === peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    // free r14
    r9 = [r11,r12,r13];
    } // seq_3
    // tbl <- r9
    // free r11,r12,r13,p10
    r8 = r9;
    if (r8 === peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    if (r6!== peg$FAILED) {
      peg$savedPos = p5;
      r6 = peg$c329(r6,r9);
      break choice_2;
    }
    // free r8,p7
    peg$savedPos = peg$currPos;
    r6 = peg$c330(r6);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
    }
    } // choice_2
    // r <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c32(r6);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_flags(silence) {
    var r1,p2,p3,r4,r5,r6,r7,r8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*48).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = [];
    r6 = peg$parsespace_or_newline(silence);
    while (r6 !== peg$FAILED) {
      r5.push(r6);
      r6 = peg$parsespace_or_newline(silence);
    }
    // sp1 <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parselang_variant_flag(silence);
    // f <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    r8 = peg$parsespace_or_newline(silence);
    while (r8 !== peg$FAILED) {
      r7.push(r8);
      r8 = peg$parsespace_or_newline(silence);
    }
    // sp2 <- r7
    // free r8
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p9 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 59) {
      r10 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c97);}
      r10 = peg$FAILED;
      r8 = peg$FAILED;
      break seq_2;
    }
    r11 = peg$parselang_variant_flags(silence);
    if (r11 === peg$FAILED) {
      r11 = null;
    }
    r8 = [r10,r11];
    } // seq_2
    if (r8 === peg$FAILED) {
      r8 = null;
    }
    // free r10,r11,p9
    // more <- r8
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c331(r5,r6,r7,r8);
      break choice_1;
    }
    // free r4,p3
    p3 = peg$currPos;
    r4 = [];
    r11 = peg$parsespace_or_newline(silence);
    while (r11 !== peg$FAILED) {
      r4.push(r11);
      r11 = peg$parsespace_or_newline(silence);
    }
    // sp <- r4
    // free r11
    r1 = r4;
    if (r1!== peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$c332(r4);
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_option(silence) {
    var r1,p2,p3,r4,r5,r6,r7,r8,r9,p10,r11,r12,r13,r14,r15,r16,r17;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*52).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = [];
    r6 = peg$parsespace_or_newline(silence);
    while (r6 !== peg$FAILED) {
      r5.push(r6);
      r6 = peg$parsespace_or_newline(silence);
    }
    // sp1 <- r5
    // free r6
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parselang_variant_name(silence);
    // lang <- r6
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    r8 = peg$parsespace_or_newline(silence);
    while (r8 !== peg$FAILED) {
      r7.push(r8);
      r8 = peg$parsespace_or_newline(silence);
    }
    // sp2 <- r7
    // free r8
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 58) {
      r4 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c48);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = [];
    r9 = peg$parsespace_or_newline(silence);
    while (r9 !== peg$FAILED) {
      r8.push(r9);
      r9 = peg$parsespace_or_newline(silence);
    }
    // sp3 <- r8
    // free r9
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    r9 = peg$parselang_variant_nowiki(silence);
    if (r9!== peg$FAILED) {
      break choice_2;
    }
    r9 = peg$parselang_variant_text_no_semi(silence);
    } // choice_2
    // lvtext <- r9
    r4 = r9;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c333(r5,r6,r7,r8,r9);
      break choice_1;
    }
    // free r4,p3
    p3 = peg$currPos;
    seq_2: {
    p10 = peg$currPos;
    r11 = [];
    r12 = peg$parsespace_or_newline(silence);
    while (r12 !== peg$FAILED) {
      r11.push(r12);
      r12 = peg$parsespace_or_newline(silence);
    }
    // sp1 <- r11
    // free r12
    r4 = r11;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_2;
    }
    choice_3: {
    r12 = peg$parselang_variant_nowiki(silence);
    if (r12!== peg$FAILED) {
      break choice_3;
    }
    r12 = peg$parselang_variant_text_no_semi_or_arrow(silence);
    } // choice_3
    // from <- r12
    r4 = r12;
    if (r4 === peg$FAILED) {
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_2;
    }
    r4 = input.substr(peg$currPos,2);
    if (r4 === "=>") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c334);}
      r4 = peg$FAILED;
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_2;
    }
    r13 = [];
    r14 = peg$parsespace_or_newline(silence);
    while (r14 !== peg$FAILED) {
      r13.push(r14);
      r14 = peg$parsespace_or_newline(silence);
    }
    // sp2 <- r13
    // free r14
    r4 = r13;
    if (r4 === peg$FAILED) {
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_2;
    }
    r14 = peg$parselang_variant_name(silence);
    // lang <- r14
    r4 = r14;
    if (r4 === peg$FAILED) {
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_2;
    }
    r15 = [];
    r16 = peg$parsespace_or_newline(silence);
    while (r16 !== peg$FAILED) {
      r15.push(r16);
      r16 = peg$parsespace_or_newline(silence);
    }
    // sp3 <- r15
    // free r16
    r4 = r15;
    if (r4 === peg$FAILED) {
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 58) {
      r4 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c48);}
      r4 = peg$FAILED;
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_2;
    }
    r16 = [];
    r17 = peg$parsespace_or_newline(silence);
    while (r17 !== peg$FAILED) {
      r16.push(r17);
      r17 = peg$parsespace_or_newline(silence);
    }
    // sp4 <- r16
    // free r17
    r4 = r16;
    if (r4 === peg$FAILED) {
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_2;
    }
    choice_4: {
    r17 = peg$parselang_variant_nowiki(silence);
    if (r17!== peg$FAILED) {
      break choice_4;
    }
    r17 = peg$parselang_variant_text_no_semi(silence);
    } // choice_4
    // to <- r17
    r4 = r17;
    if (r4 === peg$FAILED) {
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = true;
    } // seq_2
    if (r1!== peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$c335(r11,r12,r13,r14,r15,r16,r17);
    }
    // free r4,p10
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsespace_or_newline(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*105).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \t\n\r\f]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c112);}
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardrow_syntax_table_args(silence) {
    var r1,p2,p3,r4,r5,r6,r7,p8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*97).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c16();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsetable_attributes(silence);
    // as <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = [];
    r7 = peg$parsespace(silence);
    while (r7 !== peg$FAILED) {
      r6.push(r7);
      r7 = peg$parsespace(silence);
    }
    // s <- r6
    // free r7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsepipe(silence);
    // p <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p8 = peg$currPos;
    r4 = peg$discardpipe(true);
    if (r4 === peg$FAILED) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p8;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p8
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c17(r5,r6,r7);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c18();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_flag(silence) {
    var r1,p2,r3,p4,r5,p6,r7,r8,p9,r10,p11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*49).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    r3 = input.charAt(peg$currPos);
    // f <- r3
    if (/^[\-+A-Z]/.test(r3)) {
      peg$currPos++;
    } else {
      r3 = peg$FAILED;
      if (!silence) {peg$fail(peg$c336);}
    }
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c337(r3);
      break choice_1;
    }
    p4 = peg$currPos;
    r5 = peg$parselang_variant_name(silence);
    // v <- r5
    r1 = r5;
    if (r1!== peg$FAILED) {
      peg$savedPos = p4;
      r1 = peg$c338(r5);
      break choice_1;
    }
    p6 = peg$currPos;
    seq_1: {
    p9 = peg$currPos;
    p11 = peg$currPos;
    r10 = peg$discardspace_or_newline(true);
    if (r10 === peg$FAILED) {
      r10 = void 0;
    } else {
      r10 = peg$FAILED;
      peg$currPos = p11;
      r8 = peg$FAILED;
      break seq_1;
    }
    // free p11
    p11 = peg$currPos;
    r12 = peg$discardnowiki(true);
    if (r12 === peg$FAILED) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      peg$currPos = p11;
      peg$currPos = p9;
      r8 = peg$FAILED;
      break seq_1;
    }
    // free p11
    r13 = input.charAt(peg$currPos);
    if (/^[^{}|;]/.test(r13)) {
      peg$currPos++;
    } else {
      r13 = peg$FAILED;
      if (!silence) {peg$fail(peg$c339);}
      peg$currPos = p9;
      r8 = peg$FAILED;
      break seq_1;
    }
    r8 = [r10,r12,r13];
    } // seq_1
    if (r8!== peg$FAILED) {
      r7 = [];
      while (r8 !== peg$FAILED) {
        r7.push(r8);
        seq_2: {
        p9 = peg$currPos;
        p11 = peg$currPos;
        r13 = peg$discardspace_or_newline(true);
        if (r13 === peg$FAILED) {
          r13 = void 0;
        } else {
          r13 = peg$FAILED;
          peg$currPos = p11;
          r8 = peg$FAILED;
          break seq_2;
        }
        // free p11
        p11 = peg$currPos;
        r12 = peg$discardnowiki(true);
        if (r12 === peg$FAILED) {
          r12 = void 0;
        } else {
          r12 = peg$FAILED;
          peg$currPos = p11;
          peg$currPos = p9;
          r8 = peg$FAILED;
          break seq_2;
        }
        // free p11
        r10 = input.charAt(peg$currPos);
        if (/^[^{}|;]/.test(r10)) {
          peg$currPos++;
        } else {
          r10 = peg$FAILED;
          if (!silence) {peg$fail(peg$c339);}
          peg$currPos = p9;
          r8 = peg$FAILED;
          break seq_2;
        }
        r8 = [r13,r12,r10];
        } // seq_2
        // free r13,r12,r10,p9
      }
    } else {
      r7 = peg$FAILED;
    }
    // free r10,r12,r13,p9
    // b <- r7
    // free r8
    r1 = r7;
    if (r1!== peg$FAILED) {
      peg$savedPos = p6;
      r1 = peg$c340(r7);
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_name(silence) {
    var r1,p2,p3,r4,r5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*50).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = input.charAt(peg$currPos);
    // h <- r5
    if (/^[a-z]/.test(r5)) {
      peg$currPos++;
    } else {
      r5 = peg$FAILED;
      if (!silence) {peg$fail(peg$c341);}
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = input.charAt(peg$currPos);
    if (/^[\-a-z]/.test(r7)) {
      peg$currPos++;
      r6 = [];
      while (r7 !== peg$FAILED) {
        r6.push(r7);
        r7 = input.charAt(peg$currPos);
        if (/^[\-a-z]/.test(r7)) {
          peg$currPos++;
        } else {
          r7 = peg$FAILED;
          if (!silence) {peg$fail(peg$c342);}
        }
      }
    } else {
      r7 = peg$FAILED;
      if (!silence) {peg$fail(peg$c342);}
      r6 = peg$FAILED;
    }
    // t <- r6
    // free r7
    r4 = r6;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c343(r5,r6);
      break choice_1;
    }
    // free r4,p3
    r1 = peg$parsenowiki_text(silence);
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_nowiki(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*53).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p6 = peg$currPos;
    r5 = '';
    // start <- r5
    if (r5!== peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$c310(r5);
    }
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsenowiki_text(silence);
    // n <- r7
    r4 = r7;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p9 = peg$currPos;
    r8 = '';
    // end <- r8
    if (r8!== peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$c344(r5,r7,r8);
    }
    r4 = r8;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r10 = peg$discardspace_or_newline(silence);
    while (r10 !== peg$FAILED) {
      r10 = peg$discardspace_or_newline(silence);
    }
    // free r10
    r4 = true;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c345(r5,r7,r8);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_text_no_semi(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*55).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c346();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parselang_variant_text(silence);
    // lvtext <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c347(r5);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c348();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parselang_variant_text_no_semi_or_arrow(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*56).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$c349();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parselang_variant_text_no_semi(silence);
    // lvtext <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c350(r5);
      break choice_1;
    }
    // free r4,p3
    peg$savedPos = peg$currPos;
    r1 = peg$c351();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$discardnowiki(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (1+2*64).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parseextension_tag(silence);
    // extToken <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c352(r5);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c165(r5);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsenowiki_text(silence) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*66).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    r3 = peg$parsenowiki(silence);
    // extToken <- r3
    r1 = r3;
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c353(r3);
    }
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

  function peg$parsenowiki(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = (0+2*64).toString() + stops.key;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
    } else {
      visitCounts[peg$currPos]++;
    }
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r5 = peg$parseextension_tag(silence);
    // extToken <- r5
    r4 = r5;
    if (r4 === peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$c352(r5);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!== peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$c165(r5);
    }
    // free r4,p3
    if (checkCache) {
      peg$cache[bucket][key] = { nextPos: peg$currPos, result: r1 };
    }
    return r1;
  }

    // start

    var peg$startRuleFunctions = {start: peg$parsestart,table_start_tag: peg$parsetable_start_tag,url: peg$parseurl,row_syntax_table_args: peg$parserow_syntax_table_args,table_attributes: peg$parsetable_attributes,generic_newline_attributes: peg$parsegeneric_newline_attributes,tplarg_or_template_or_bust: peg$parsetplarg_or_template_or_bust,nowiki_content: peg$parsenowiki_content,extlink: peg$parseextlink},
        peg$startRuleFunction = peg$parsestart,
        peg$streamRuleFunctions = {start_async: peg$streamstart_async},
        peg$streamRuleFunction;

    if (options.stream) {
      peg$streamRuleFunction = peg$streamstart_async;
      if ("startRule" in options) {
        if (!(options.startRule in peg$streamRuleFunctions)) {
          throw new Error("Can't stream rule \"" + options.startRule + "\".");
        }
        peg$streamRuleFunction = peg$streamRuleFunctions[options.startRule];
      }
    } else if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }


        var pegIncludes = options.pegIncludes;
        var pegTokenizer = options.pegTokenizer;

        var env = pegTokenizer.env;
        var pipelineOpts = pegTokenizer.options;

        var DU = pegIncludes.DOMUtils;
        var TokenUtils = pegIncludes.TokenUtils;
        var Util = pegIncludes.Util;
        var JSUtils = pegIncludes.JSUtils;
        var PegTokenizer = pegIncludes.PegTokenizer;
        var TokenTypes = pegIncludes.TokenTypes;
        var constants = pegIncludes.constants;
        var tu = pegIncludes.tu;

        // define some constructor shortcuts
        const { KV, TagTk, EndTagTk, SelfclosingTagTk, NlTk, EOFTk, CommentTk } = TokenTypes;
        var lastItem = JSUtils.lastItem;

        var inlineBreaks = tu.inlineBreaks;
        var stops = new tu.SyntaxStops();

        var prevOffset = 0;

        // Some shorthands for legibility
        var startOffset = function() {
          return location().start.offset;
        };
        var endOffset = function() {
          return location().end.offset;
        };
        var tsrOffsets = function(flag) {
          return tu.tsrOffsets(location(), flag);
        };

        /*
         * Emit a chunk of tokens to our consumers.  Once this has been done, the
         * current expression can return an empty list (true).
         */
        var emitChunk = function(tokens) {
            if (env.immutable) {
                // Tokens placed in the tokenizer's cache have been frozen to
                // to catch any mutations while testing, which may have led to
                // subtle, spooky action at a distance.
                tokens = Util.unFreeze(tokens, true);
            }

            // Shift tsr of all tokens by the pipeline offset
            TokenUtils.shiftTokenTSR(tokens, options.pipelineOffset);
            env.log("trace/peg", pegTokenizer.pipelineId, "---->  ", tokens);

            var i;
            var n = tokens.length;

            // Enforce parsing resource limits
            for (i = 0; i < n; i++) {
                tu.enforceParserResourceLimits(env, tokens[i]);
            }

            // limit the size of individual chunks
            var chunkLimit = 100000;
            if (n > chunkLimit) {
                i = 0;
                while (i < n) {
                    options.cb(tokens.slice(i, i + chunkLimit));
                    i += chunkLimit;
                }
            } else {
                options.cb(tokens);
            }
        };

        /* ------------------------------------------------------------------------
         * Extension tags should be parsed with higher priority than anything else.
         *
         * The trick we use is to strip out the content inside a matching tag-pair
         * and not tokenize it. The content, if it needs to parsed (for example,
         * for <ref>, <*include*> tags), is parsed in a fresh tokenizer context
         * which means any error correction that needs to happen is restricted to
         * the scope of the extension content and doesn't spill over to the higher
         * level.  Ex: <math><!--foo</math>.
         *
         * IGNORE: {{ this just balances the blocks in this comment for pegjs
         *
         * This trick also lets us prevent extension content (that don't accept WT)
         * from being parsed as wikitext (Ex: <math>\frac{foo\frac{bar}}</math>)
         * We don't want the "}}" being treated as a template closing tag and
         * closing outer templates.
         * --------------------------------------------------------------------- */

        var isXMLTag = function(name, block) {
            var lName = name.toLowerCase();
            var uName = name.toUpperCase();

            var isInstalledExt = env.conf.wiki.extConfig.tags.has(lName);
            var isIncludeTag = tu.isIncludeTag(lName);

            var isHtmlTag = block ?
                    TokenUtils.isBlockTag(uName) :
                    constants.HTML.HTML5Tags.has(uName) || constants.HTML.OlderHTMLTags.has(uName);

            // WARNING: Be careful to pop this when `isXMLTag` is used.
            stops.push('extTag', isInstalledExt);

            return isHtmlTag || isInstalledExt || isIncludeTag;
        };

        var maybeExtensionTag = function(t) {
            var tagName = t.name.toLowerCase();

            var isInstalledExt = env.conf.wiki.extConfig.tags.has(tagName);
            var isIncludeTag = tu.isIncludeTag(tagName);

            // Extensions have higher precedence when they shadow html tags.
            if (!(isInstalledExt || isIncludeTag)) {
                return t;
            }

            var dp = t.dataAttribs;
            var skipLen = 0;

            switch (t.constructor) {
            case EndTagTk:
                if (isIncludeTag) {
                    return t;
                }
                // Similar to TagTk, we rely on the sanitizer to convert to text
                // where necessary and emit tokens to ease the wikitext escaping
                // code.  However, extension tags that shadow html tags will see
                // their unmatched end tags dropped while tree building, since
                // the sanitizer will let them through.
                return t;  // not text()
            case SelfclosingTagTk:
                dp.src = input.substring(dp.tsr[0], dp.tsr[1]);
                dp.tagWidths = [dp.tsr[1] - dp.tsr[0], 0];
                if (isIncludeTag) {
                    return t;
                }
                break;
            case TagTk:
                var tsr0 = dp.tsr[0];
                var endTagRE = new RegExp("^[\\s\\S]*?(</\\s*" + tagName + "\\s*>)", "mi");
                var restOfInput = input.substring(tsr0);
                var tagContent = restOfInput.match(endTagRE);

                if (!tagContent) {
                    dp.src = input.substring(dp.tsr[0], dp.tsr[1]);
                    dp.tagWidths = [dp.tsr[1] - dp.tsr[0], 0];
                    if (isIncludeTag) {
                        return t;
                    } else {
                        // This is undefined behaviour.  The php parser currently
                        // returns text here (see core commit 674e8388cba),
                        // whereas this results in unclosed
                        // extension tags that shadow html tags falling back to
                        // their html equivalent.  The sanitizer will take care
                        // of converting to text where necessary.  We do this to
                        // simplify `hasWikitextTokens` when escaping wikitext,
                        // which wants these as tokens because it's otherwise
                        // lacking in context.
                        return t;  // not text()
                    }
                }

                var extSrc = tagContent[0];
                var endTagWidth = tagContent[1].length;

                if (pipelineOpts.inTemplate) {
                    // Support 1-level of nesting in extensions tags while
                    // tokenizing in templates to support the #tag parser function.
                    //
                    // It's necessary to permit this broadly in templates because
                    // there's no way to distinguish whether the nesting happened
                    // while expanding the #tag parser function, or just a general
                    // syntax errors.  In other words,
                    //
                    //   hi<ref>ho<ref>hi</ref>ho</ref>
                    //
                    // and
                    //
                    //   hi{{#tag:ref|ho<ref>hi</ref>ho}}
                    //
                    // found in template are returned indistinguishably after a
                    // preprocessing request, though the php parser renders them
                    // differently.  #tag in template is probably a common enough
                    // use case that we want to accept these false positives,
                    // though another approach could be to drop this code here, and
                    // invoke a native #tag handler and forgo those in templates.
                    //
                    // Expand `extSrc` as long as there is a <tagName> found in the
                    // extension source body.
                    var s = extSrc.substring(endOffset() - tsr0);
                    while (s && s.match(new RegExp("<" + tagName + "[^/<>]*>"))) {
                        tagContent = restOfInput.substring(extSrc.length).match(endTagRE);
                        if (tagContent) {
                            s = tagContent[0];
                            endTagWidth = tagContent[1].length;
                            extSrc += s;
                        } else {
                            s = null;
                        }
                    }
                }

                // Extension content source
                dp.src = extSrc;
                dp.tagWidths = [endOffset() - tsr0, endTagWidth];

                skipLen = extSrc.length - dp.tagWidths[0] - dp.tagWidths[1];

                // If the xml-tag is a known installed (not native) extension,
                // skip the end-tag as well.
                if (isInstalledExt) {
                    skipLen += endTagWidth;
                }
                break;
            default:
                console.assert(false, 'Should not be reachable.');
            }

            peg$currPos += skipLen;

            if (isInstalledExt) {
                // update tsr[1] to span the start and end tags.
                dp.tsr[1] = endOffset();  // was just modified above
                return new SelfclosingTagTk('extension', [
                    new KV('typeof', 'mw:Extension'),
                    new KV('name', tagName),
                    new KV('about', env.newAboutId()),
                    new KV('source', dp.src),
                    new KV('options', t.attribs),
                ], dp);
            } else if (isIncludeTag) {
                // Parse ext-content, strip eof, and shift tsr
                var extContent = dp.src.substring(dp.tagWidths[0], dp.src.length - dp.tagWidths[1]);
                var extContentToks = (new PegTokenizer(env)).tokenizeSync(extContent);
                if (dp.tagWidths[1] > 0) {
                    extContentToks = TokenUtils.stripEOFTkfromTokens(extContentToks);
                }
                TokenUtils.shiftTokenTSR(extContentToks, dp.tsr[0] + dp.tagWidths[0]);
                return [t].concat(extContentToks);
            } else {
                console.assert(false, 'Should not be reachable.');
            }
        };


    peg$currPos = 0;

    if (options.stream) {
      return peg$streamRuleFunction(false);
    }

    var peg$result = peg$startRuleFunction(false);

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(
        null,
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }
  exports.parse = peg$parse;

  return exports;
})();
